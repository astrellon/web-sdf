{
  "version": 3,
  "sources": ["../node_modules/simple-data-store/src/index.ts", "../node_modules/fast-deep-equal/index.js", "../node_modules/preact/src/constants.js", "../node_modules/preact/src/util.js", "../node_modules/preact/src/options.js", "../node_modules/preact/src/create-element.js", "../node_modules/preact/src/component.js", "../node_modules/preact/src/diff/props.js", "../node_modules/preact/src/create-context.js", "../node_modules/preact/src/diff/children.js", "../node_modules/preact/src/diff/index.js", "../node_modules/preact/src/render.js", "../node_modules/preact/src/clone-element.js", "../node_modules/preact/src/diff/catch-error.js", "../src/store/store.ts", "../src/ray-marching/scene-tree.ts", "../src/store/store-state.ts", "../src/shaders/vert.glsl", "../src/shaders/frag.glsl", "../src/shaders/sdf-functions.glsl", "../src/shaders/shader.ts", "../src/gl-matrix-ts/mathf.ts", "../src/gl-matrix-ts/vec3.ts", "../src/gl-matrix-ts/vec4.ts", "../src/gl-matrix-ts/quat.ts", "../src/webgl/webgl-sdf-renderer.ts", "../src/components/webgl-viewport-options.tsx", "../src/components/webgl-viewport.tsx", "../src/components/vector-view.tsx", "../src/components/shape-view.tsx", "../src/components/light-view.tsx", "../src/components/scene-node-view.tsx", "../src/components/scene-node-tree-item.tsx", "../src/components/scene-node-tree.tsx", "../src/components/scene-tree-view.tsx", "../src/ray-marching/scene-converter.ts", "../src/ray-marching/scene-entities.ts", "../src/components/webgl-app.tsx", "../src/webgl/webgl-index.tsx"],
  "sourcesContent": ["// A function to create a patch for the state.\n// Meaning this should return a partial state to be merged with the current state.\nexport type Modifier<TState> = (state: TState) => Partial<TState> | null;\n\n// A function that takes part of the state and returns a sub set of that state.\n// Used to look for specific parts of the state that have changed.\nexport type Selector<TState, TValue> = (state: TState) => TValue;\n\n// A function used to compare if two parts of the state have actually changed.\n// By default a strict equals is used when comparing however sometimes something more complex is needed.\n// The TValue refers to the value returned by the Selector.\nexport type SelectorComparer<TValue> = (prevValue: TValue, newValue: TValue) => boolean;\n\n// A callback function to be triggered when a selector has returned a new value.\n// The callback is given the new state and result of the selector that triggered the callback.\n// The TValue refers to the value returned by the Selector.\nexport type Subscription<TState, TValue> = (state: TState, newValue: TValue, triggeringModifier: Modifier<TState>, isNewState: boolean) => void;\n\n// A function used to remove a subscription. This can be called multiple times.\nexport type RemoveSubscription = () => void;\n\n// An empty modifier, recommended to use when you want to return a modifier that does nothing.\nexport const EmptyModifier: Modifier<any> = () => null;\n\n// Pairing of the selector function and subscription callback.\ninterface SubscriptionSelectorPair<TState, TValue>\n{\n    readonly selector: SelectorContext<TState, TValue>;\n    readonly subscription: Subscription<TState, TValue>;\n}\n\n/**\n * The main data store class. Keeps track of the current state, any subscriptions and optionally a history of the state.\n *\n * By default history is disabled.\n */\nexport default class DataStore<TState>\n{\n    private currentState: TState;\n    private subscriptions: Array<SubscriptionSelectorPair<TState, any>> = [];\n\n    /**\n     * Creates a new DataStore.\n     *\n     * @param initialState The starting values for the data store.\n     */\n    public constructor (initialState: TState)\n    {\n        this.currentState = initialState;\n    }\n\n    /**\n     * Returns the current state.\n     *\n     * @returns The current state.\n     */\n    public state = (): Readonly<TState> => this.currentState;\n\n    /**\n     * Executes a modifier on the state.\n     * The modifier is recommended to return a partial state that is merged.\n     *\n     * If the modifier returns the same state (as compared with strict equals) or null then\n     * the state is not updated nor is any subscription triggered.\n     *\n     * @param modifier Modifier function to update the state with.\n     * @param isNewState Marks if this state is a new one. Can be used for history subscriptions to know if to record this state update or not.\n     */\n    public execute(modifier: Modifier<TState>, isNewState: boolean = true)\n    {\n        const newState = modifier(this.currentState);\n        if (newState === null || newState === undefined || newState === this.currentState)\n        {\n            return;\n        }\n\n        this.currentState = Object.assign({}, this.currentState, newState);\n        this.triggerSubscriptions(modifier, isNewState);\n    }\n\n    /**\n     * Subscribe to when a part of the state has changed. This will be called on all dispatches.\n     *\n     * @param selector A function for picking the values out of the store you want to check has changed.\n     * @param subscription A callback that will be triggered when the values returned in the selector have changed.\n     * @param comparer An optional comparer for old and new values, these values will the old and new results from the selector, *NOT* the state as a whole.\n     * @param selectorName An optional name to link with the selector to help with debugging.\n     * @returns A function to remove the subscription from the store.\n     */\n    public subscribe<TValue>(selector: Selector<TState, TValue>, subscription: Subscription<TState, TValue>, comparer?: SelectorComparer<TValue>, selectorName?: string): RemoveSubscription\n    {\n        const startValue = selector(this.currentState);\n        const obj = { selector: new SelectorContext(selector, startValue, comparer, selectorName), subscription };\n        this.subscriptions.push(obj);\n\n        return () =>\n        {\n            const index = this.subscriptions.indexOf(obj);\n            if (index >= 0)\n            {\n                this.subscriptions.splice(index, 1);\n            }\n        };\n    }\n\n    /**\n     * Adds a callback for anytime the store has changed.\n     *\n     * @param callback A callback for when the store has changed.\n     * @param selectorName An optional name to link with the selector to help with debugging.\n     * @returns A function to remove the subscription from the store.\n     */\n    public subscribeAny (callback: Subscription<TState, TState>, selectorName?: string): RemoveSubscription\n    {\n        return this.subscribe((state) => state, callback, undefined, selectorName);\n    }\n\n    /**\n     * Removes all subscriptions.\n     */\n    public unsubscribeAll ()\n    {\n        this.subscriptions = [];\n    }\n\n    /**\n     * Trigger all the subscriptions that an update has executed.\n     *\n     * @param isNewState Marks if this update is for a new state or not. Used by history subscriptions to know if to record the state change or not.\n     */\n    private triggerSubscriptions(modifier: Modifier<TState>, isNewState: boolean)\n    {\n        for (const subscription of this.subscriptions)\n        {\n            const newValue = subscription.selector.getValue(this.currentState);\n            if (subscription.selector.checkIfChanged(newValue))\n            {\n                subscription.subscription(this.currentState, newValue, modifier, isNewState);\n            }\n        }\n    }\n}\n\n/**\n * A selector context is a pairing of a selector function, a comparer and a previous value.\n * This is used to actual keep track of when something has changed and the way to compare the change.\n *\n * NOTE: Not indented to be a public class.\n */\nclass SelectorContext<TState, TValue>\n{\n    public readonly selector: Selector<TState, TValue>;\n    public readonly comparer?: SelectorComparer<TValue>;\n    public readonly name?: string;\n    private prevValue: any;\n\n    constructor (selector: Selector<TState, TValue>, startValue: any = undefined, comparer?: SelectorComparer<TValue>, name?: string)\n    {\n        this.selector = selector;\n        this.prevValue = startValue;\n        this.comparer = comparer;\n        this.name = name;\n    }\n\n    /**\n     * Select the value from the state using the selector function provided.\n     *\n     * @param state The state to get the value from.\n     * @returns Whatever the selector returns.\n     */\n    public getValue = (state: TState): any => this.selector(state);\n\n    /**\n     * Check if the new value is different from the old one using the comparer.\n     *\n     * @param newValue The new value from the selector.\n     */\n    public checkIfChanged (newValue: any): boolean\n    {\n        let result = false;\n        if (this.comparer !== undefined)\n        {\n            result = !this.comparer(this.prevValue, newValue);\n        }\n        else\n        {\n            result = newValue !== this.prevValue;\n        }\n\n        this.prevValue = newValue;\n        return result;\n    }\n}", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {import('./index').ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tif (node && node.parentNode) node.parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\nimport { NULL, UNDEFINED } from './constants';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != NULL) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === UNDEFINED) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, NULL);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {import('./internal').VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: NULL,\n\t\t_parent: NULL,\n\t\t_depth: 0,\n\t\t_dom: NULL,\n\t\t_component: NULL,\n\t\tconstructor: UNDEFINED,\n\t\t_original: original == NULL ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == NULL && options.vnode != NULL) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: NULL };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != NULL && vnode.constructor == UNDEFINED;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE, NULL } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != NULL && this._nextState != this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == NULL) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](https://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == NULL) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: NULL;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != NULL && sibling._dom != NULL) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : NULL;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : NULL,\n\t\t\tcommitQueue,\n\t\t\toldDom == NULL ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != NULL && vnode._component != NULL) {\n\t\tvnode._dom = vnode._component.base = NULL;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != NULL && child._dom != NULL) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce != options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {import('./internal').Component} a\n * @param {import('./internal').Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c,\n\t\tl = 1;\n\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile (rerenderQueue.length) {\n\t\t// Keep the rerender queue sorted by (depth, insertion order). The queue\n\t\t// will initially be sorted on the first iteration only if it has more than 1 item.\n\t\t//\n\t\t// New items can be added to the queue e.g. when rerendering a provider, so we want to\n\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t// single pass\n\t\tif (rerenderQueue.length > l) {\n\t\t\trerenderQueue.sort(depthSort);\n\t\t}\n\n\t\tc = rerenderQueue.shift();\n\t\tl = rerenderQueue.length;\n\n\t\tif (c._dirty) {\n\t\t\trenderComponent(c);\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL, NULL, SVG_NAMESPACE } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] == '-') {\n\t\tstyle.setProperty(key, value == NULL ? '' : value);\n\t} else if (value == NULL) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\nconst CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name == 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] != oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] == 'o' && name[1] == 'n') {\n\t\tuseCapture = name != (name = name.replace(CAPTURE_REGEX, '$1'));\n\t\tconst lowerCaseName = name.toLowerCase();\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (lowerCaseName in dom || name == 'onFocusOut' || name == 'onFocusIn')\n\t\t\tname = lowerCaseName.slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == SVG_NAMESPACE) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == NULL ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != NULL && (value !== false || name[4] == '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {import('../internal').PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == NULL) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\nimport { NULL } from './constants';\n\nexport let i = 0;\n\nexport function createContext(defaultValue) {\n\tfunction Context(props) {\n\t\tif (!this.getChildContext) {\n\t\t\t/** @type {Set<import('./internal').Component> | null} */\n\t\t\tlet subs = new Set();\n\t\t\tlet ctx = {};\n\t\t\tctx[Context._id] = this;\n\n\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tsubs = NULL;\n\t\t\t};\n\n\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t// @ts-expect-error even\n\t\t\t\tif (this.props.value != _props.value) {\n\t\t\t\t\tsubs.forEach(c => {\n\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.sub = c => {\n\t\t\t\tsubs.add(c);\n\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\tif (subs) {\n\t\t\t\t\t\tsubs.delete(c);\n\t\t\t\t\t}\n\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\treturn props.children;\n\t}\n\n\tContext._id = '__cC' + i++;\n\tContext._defaultValue = defaultValue;\n\n\t/** @type {import('./internal').FunctionComponent} */\n\tContext.Consumer = (props, contextValue) => {\n\t\treturn props.children(contextValue);\n\t};\n\n\t// we could also get rid of _contextRef entirely\n\tContext.Provider =\n\t\tContext._contextRef =\n\t\tContext.Consumer.contextType =\n\t\t\tContext;\n\n\treturn Context;\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport {\n\tEMPTY_OBJ,\n\tEMPTY_ARR,\n\tINSERT_VNODE,\n\tMATCHED,\n\tUNDEFINED,\n\tNULL\n} from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\toldDom = constructNewChildrenArray(\n\t\tnewParentVNode,\n\t\trenderResult,\n\t\toldChildren,\n\t\toldDom,\n\t\tnewChildrenLength\n\t);\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (childVNode == NULL) continue;\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index == -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tlet result = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, NULL, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == NULL && newDom != NULL) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (typeof childVNode.type == 'function' && result !== UNDEFINED) {\n\t\t\toldDom = result;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(\n\tnewParentVNode,\n\trenderResult,\n\toldChildren,\n\toldDom,\n\tnewChildrenLength\n) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = new Array(newChildrenLength);\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == NULL ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tnewParentVNode._children[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tNULL,\n\t\t\t\tchildVNode,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (childVNode.constructor == UNDEFINED && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : NULL,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tconst matchingIndex = (childVNode._index = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t));\n\n\t\toldVNode = NULL;\n\t\tif (matchingIndex != -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original == null\n\t\tconst isMounting = oldVNode == NULL || oldVNode._original == NULL;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\t// When the array of children is growing we need to decrease the skew\n\t\t\t\t// as we are adding a new element to the array.\n\t\t\t\t// Example:\n\t\t\t\t// [1, 2, 3] --> [0, 1, 2, 3]\n\t\t\t\t// oldChildren   newChildren\n\t\t\t\t//\n\t\t\t\t// The new element is at index 0, so our skew is 0,\n\t\t\t\t// we need to decrease the skew as we are adding a new element.\n\t\t\t\t// The decrease will cause us to compare the element at position 1\n\t\t\t\t// with value 1 with the element at position 0 with value 0.\n\t\t\t\t//\n\t\t\t\t// A linear concept is applied when the array is shrinking,\n\t\t\t\t// if the length is unchanged we can assume that no skew\n\t\t\t\t// changes are needed.\n\t\t\t\tif (newChildrenLength > oldChildrenLength) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else if (newChildrenLength < oldChildrenLength) {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex != skewedIndex) {\n\t\t\t// When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n\t\t\t// --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n\t\t\t//     we set the skew to 1 as we found an offset.\n\t\t\t// --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n\t\t\t//     this makes us increase the skew again.\n\t\t\t// --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n\t\t\t//\n\t\t\t// this becomes an optimization question where currently we see a 1 element offset as an insertion\n\t\t\t// or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n\t\t\t// while a more than 1 offset we see as a swap.\n\t\t\t// We could probably build heuristics for having an optimized course of action here as well, but\n\t\t\t// might go at the cost of some bytes.\n\t\t\t//\n\t\t\t// If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n\t\t\t// only the first item be a re-scouting and all the others fall in their skewed counter-part.\n\t\t\t// We could also further optimize for swaps\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else {\n\t\t\t\tif (matchingIndex > skewedIndex) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\n\t\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t\t// match the new skew index (i + new skew)\n\t\t\t\t// In the former two branches we know that it matches after skewing\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != NULL && (oldVNode._flags & MATCHED) == 0) {\n\t\t\t\tif (oldVNode._dom == oldDom) {\n\t\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (oldDom && parentVNode.type && !parentDom.contains(oldDom)) {\n\t\t\toldDom = getDomSibling(parentVNode);\n\t\t}\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || NULL);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != NULL && oldDom.nodeType == 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == NULL || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\t//\n\t// If there is an unkeyed functional VNode, that isn't a built-in like our Fragment,\n\t// we should not search as we risk re-using state of an unrelated VNode. (reverted for now)\n\tlet shouldSearch =\n\t\t// (typeof type != 'function' || type === Fragment || key) &&\n\t\tremainingOldChildren >\n\t\t(oldVNode != NULL && (oldVNode._flags & MATCHED) == 0 ? 1 : 0);\n\n\tif (\n\t\t(oldVNode === NULL && childVNode.key == null) ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype == oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) == 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\tlet x = skewedIndex - 1;\n\t\tlet y = skewedIndex + 1;\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype == oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype == oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMATH_NAMESPACE,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tNULL,\n\tRESET_MODE,\n\tSVG_NAMESPACE,\n\tUNDEFINED,\n\tXHTML_NAMESPACE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * @template {any} T\n * @typedef {import('../internal').Ref<T>} Ref<T>\n */\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor != UNDEFINED) return NULL;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == NULL) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != NULL) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tc.componentWillMount != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != NULL &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original == oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original != oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.some(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != NULL) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != NULL) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != NULL) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != NULL && tmp.type === Fragment && tmp.key == NULL;\n\t\t\tlet renderResult = tmp;\n\n\t\t\tif (isTopLevelFragment) {\n\t\t\t\trenderResult = cloneNode(tmp.props.children);\n\t\t\t}\n\n\t\t\toldDom = diffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = NULL;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = NULL;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != NULL) {\n\t\t\t\tif (e.then) {\n\t\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t\t: MODE_SUSPENDED;\n\n\t\t\t\t\twhile (oldDom && oldDom.nodeType == 8 && oldDom.nextSibling) {\n\t\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = NULL;\n\t\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = excessDomChildren.length; i--; ) {\n\t\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == NULL &&\n\t\tnewVNode._original == oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\toldDom = newVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n\n\treturn newVNode._flags & MODE_SUSPENDED ? undefined : oldDom;\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\nfunction cloneNode(node) {\n\tif (\n\t\ttypeof node != 'object' ||\n\t\tnode == NULL ||\n\t\t(node._depth && node._depth > 0)\n\t) {\n\t\treturn node;\n\t}\n\n\tif (isArray(node)) {\n\t\treturn node.map(cloneNode);\n\t}\n\n\treturn assign({}, node);\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType == 'svg') namespace = SVG_NAMESPACE;\n\telse if (nodeType == 'math') namespace = MATH_NAMESPACE;\n\telse if (!namespace) namespace = XHTML_NAMESPACE;\n\n\tif (excessDomChildren != NULL) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value == !!nodeType &&\n\t\t\t\t(nodeType ? value.localName == nodeType : value.nodeType == 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == NULL) {\n\t\tif (nodeType == NULL) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tif (isHydrating) {\n\t\t\tif (options._hydrationMismatch)\n\t\t\t\toptions._hydrationMismatch(newVNode, excessDomChildren);\n\t\t\tisHydrating = false;\n\t\t}\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = NULL;\n\t}\n\n\tif (nodeType == NULL) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data != newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != NULL) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (!(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, NULL, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html != oldHtml.__html && newHtml.__html != dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\t// @ts-expect-error\n\t\t\t\tnewVNode.type == 'template' ? dom.content : dom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType == 'foreignObject' ? XHTML_NAMESPACE : namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != NULL) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (nodeType == 'progress' && inputValue == NULL) {\n\t\t\t\tdom.removeAttribute('value');\n\t\t\t} else if (\n\t\t\t\tinputValue != UNDEFINED &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType == 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType == 'option' && inputValue != oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked != UNDEFINED && checked != dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != NULL) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current == vnode._dom) {\n\t\t\tapplyRef(r, NULL, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != NULL) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = NULL;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\tvnode._component = vnode._parent = vnode._dom = UNDEFINED;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ, NULL } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\t// https://github.com/preactjs/preact/issues/3794\n\tif (parentDom == document) {\n\t\tparentDom = document.documentElement;\n\t}\n\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? NULL\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, NULL, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? NULL\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: NULL,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\nimport { NULL, UNDEFINED } from './constants';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === UNDEFINED && defaultProps != UNDEFINED) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tNULL\n\t);\n}\n", "import { NULL } from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {import('../internal').VNode} [oldVNode]\n * @param {import('../internal').ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {import('../internal').Component} */\n\tlet component,\n\t\t/** @type {import('../internal').ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != NULL) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != NULL) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "import DataStore from \"simple-data-store\";\nimport { AppState, ViewportOptions, ViewportState } from \"./store-state\";\n\nexport const defaultRenderOptions: ViewportOptions = {\n    renderScale: 1.0,\n    maxMarchingStep: 255,\n    enableShadows: true,\n    enableShowMarching: false,\n    epsilon: 0.001,\n    pixelated: false\n}\nexport const defaultViewport: ViewportState = {\n    options: defaultRenderOptions\n}\nexport const store = new DataStore<AppState>({\n    viewports: [defaultViewport],\n    sdfTree: {\n        nodes: {}\n    }\n});", "import { SceneNode, SceneNodes, ShapeNodeId } from \"./scene-entities\";\n\nexport interface SceneTree\n{\n    readonly nodes: SceneNodes;\n    readonly rootNodeId?: ShapeNodeId;\n}\ninterface SceneNodeAtDepth\n{\n    readonly node: SceneNode;\n    readonly depth: number;\n}\n\nexport function sdfTreeUpdateNode(tree: SceneTree, node: SceneNode): SceneTree\n{\n    const newNodes = {\n        ...tree.nodes,\n        [node.id]: node\n    };\n\n    return {\n        ...tree,\n        nodes: newNodes\n    }\n}\n\nexport function sdfTreeSetRootNodeId(tree: SceneTree, rootNodeId: ShapeNodeId): SceneTree\n{\n    return { ...tree, rootNodeId }\n}\n\nexport function sdfTreeSetNodes(tree: SceneTree, nodes: SceneNodes): SceneTree\n{\n    return { ...tree, nodes }\n}\n\nexport function sdfTreeFlatten(tree: SceneTree): SceneNodeAtDepth[]\n{\n    const rootNode = tree.nodes[tree.rootNodeId];\n    if (!rootNode)\n    {\n        return [];\n    }\n\n    const result = new Array<SceneNodeAtDepth>(Object.keys(tree.nodes).length);\n    addToTree(rootNode, tree.nodes, 0, 0, result);\n    return result;\n}\n\nfunction addToTree(node: SceneNode, nodes: SceneNodes, depth: number, index: number, result: SceneNodeAtDepth[])\n{\n    result[index] = {node, depth};\n    if (node.childrenIds != null)\n    {\n        for (const childId of node.childrenIds)\n        {\n            const child = nodes[childId];\n            if (child)\n            {\n                index = addToTree(child, nodes, depth + 1, index + 1, result);\n            }\n        }\n    }\n    return index;\n}", "import { Modifier } from \"simple-data-store\";\nimport { defaultRenderOptions, defaultViewport } from \"./store\";\nimport { SceneTree, sdfTreeUpdateNode, sdfTreeSetRootNodeId, sdfTreeSetNodes } from \"../ray-marching/scene-tree\";\nimport { SceneNode, SceneNodes, ShapeNodeId } from \"../ray-marching/scene-entities\";\n\nexport interface ViewportOptions\n{\n    readonly enableShadows: boolean;\n    readonly enableShowMarching: boolean;\n    readonly renderScale: number;\n    readonly maxMarchingStep: number;\n    readonly epsilon: number;\n    readonly pixelated: boolean;\n}\n\nexport interface ViewportState\n{\n    readonly options: ViewportOptions;\n}\n\nexport interface AppState\n{\n    readonly viewports: ViewportState[];\n    readonly sdfTree: SceneTree;\n    readonly selectedNodeId?: ShapeNodeId;\n}\n\nexport function setViewportOptions(index: number, options: Partial<ViewportOptions>): Modifier<AppState>\n{\n    return (state: AppState) =>\n    {\n        const viewport = state.viewports[index] ?? defaultViewport;\n        const newViewport = {\n            ...viewport,\n            options: { ...viewport.options, ...options }\n        };\n\n        const viewports = [ ...state.viewports ];\n        viewports[index] = newViewport;\n\n        return { viewports }\n    }\n}\n\nexport function updateNode(node: SceneNode): Modifier<AppState>\n{\n    return (state: AppState) =>\n    {\n        const sdfTree = sdfTreeUpdateNode(state.sdfTree, node);\n        return { sdfTree };\n    }\n}\n\nexport function setNodes(nodes: SceneNodes): Modifier<AppState>\n{\n    return (state: AppState) =>\n    {\n        const sdfTree = sdfTreeSetNodes(state.sdfTree, nodes);\n        return { sdfTree }\n    }\n}\n\nexport function setRootNode(rootNodeId?: ShapeNodeId): Modifier<AppState>\n{\n    return (state: AppState) =>\n    {\n        const sdfTree = sdfTreeSetRootNodeId(state.sdfTree, rootNodeId);\n        return { sdfTree };\n    };\n}\n\nexport function setSelectedNode(selectedNodeId?: ShapeNodeId): Modifier<AppState>\n{\n    return () => { return { selectedNodeId } };\n}", "#version 300 es\n\nin vec2 aPosition;\nout vec2 oPosition;\n\nuniform float uAspectRatio;\n\nvoid main()\n{\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n    oPosition = aPosition * vec2(uAspectRatio, 1.0);\n}", "#version 300 es\n\nprecision lowp float;\n\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\n\nlayout(location = 0) out vec4 fragColour;\n\nin vec2 oPosition;\n\nuniform mat2x4 uLights[8];\nuniform int uNumLights;\nuniform mat3 uCameraMatrix;\nuniform vec3 uCameraPosition;\n\nuniform mat2x4 uMaterials[32];\n\nuniform mat4 uShapes[128];\nuniform int uOperations[128];\nuniform int uNumOperations;\nuniform int uMaxMarchingSteps;\nuniform float uEpsilon;\n\nuniform bvec4 uFlags;\n\n#include <sdf-functions>\n\nvec3 quatMul( vec4 q, vec3 v )\n{\n    return v + 2.0 * cross(cross(v, q.xyz ) + q.w * v, q.xyz);\n}\n\nvec2 getDistanceToShape(int index, vec3 samplePoint)\n{\n    mat4 shape = uShapes[index];\n\n    vec3 point = shape[0].xyz;\n    float maxSize = shape[0].w;\n\n    vec3 testPoint = point - samplePoint;\n    // if (maxSize > 0.0)\n    // {\n    //     float testDist = length(testPoint);\n    //     if (testDist > maxSize + 3.0)\n    //     {\n    //         return vec2(testDist - 3.0, -1.0);\n    //     }\n    // }\n\n    vec4 rotation = shape[1];\n\n    vec3 transPoint = quatMul(rotation, testPoint);\n\n    int type = int(round(shape[2].x));\n    vec3 params = shape[2].yzw;\n\n    float dist = getDistToType(type, transPoint, params);\n    float material = shape[3].x;\n\n    return vec2(dist, material);\n}\n\nvec2 sceneSDF(vec3 point)\n{\n    int depthStackIndex = -1;\n    vec2 depthStack[32];\n\n    for (int operationsIndex = 0; operationsIndex < uNumOperations; operationsIndex++)\n    {\n        int operationOrIndex = uOperations[operationsIndex];\n\n        if (operationOrIndex <= SdfOpCodeNone)\n        {\n            vec2 lastD2 = depthStack[depthStackIndex--];\n            vec2 lastD1 = depthStack[depthStackIndex--];\n            vec2 dist = applyOpCode(operationOrIndex, lastD2, lastD1);\n            depthStack[++depthStackIndex] = dist;\n        }\n        else\n        {\n            vec2 dist = getDistanceToShape(operationOrIndex, point);\n            depthStack[++depthStackIndex] = dist;\n        }\n    }\n\n    return depthStack[0];\n}\n\nvec3 createRayDirection(float fieldOfView, vec2 fragCoord)\n{\n    vec2 xy = fragCoord / 2.0;\n    float z = 2.0 / tan(radians(fieldOfView));\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormalPhong(vec3 point, vec3 currentDepth)\n{\n    vec2 eps_zero = vec2(currentDepth.x * 0.0015, 0.0);\n    return normalize(vec3(\n        sceneSDF(point + eps_zero.xyy).x - sceneSDF(point - eps_zero.xyy).x,\n        sceneSDF(point + eps_zero.yxy).x - sceneSDF(point - eps_zero.yxy).x,\n        sceneSDF(point + eps_zero.yyx).x - sceneSDF(point - eps_zero.yyx).x\n    ));\n}\n\n// https://github.com/electricsquare/raymarching-workshop?tab=readme-ov-file#diffuse-term\nvec3 estimateNormalLambert(vec3 point, vec3 currentDepth)\n{\n    // Use offset samples to compute gradient / normal\n    float d = currentDepth.y;\n    vec2 eps_zero = vec2(currentDepth.x * 0.0015, 0.0);\n    return normalize(vec3(\n        sceneSDF(point + eps_zero.xyy).x - d,\n        sceneSDF(point + eps_zero.yxy).x - d,\n        sceneSDF(point + eps_zero.yyx).x - d));\n}\n\nvec3 estimateNormalTetrahedron(vec3 point, vec3 currentDepth)\n{\n    float h = 0.0015 * currentDepth.x;\n    const vec2 k = vec2(1, -1);\n\n    return normalize(\n        k.xyy * sceneSDF(point + k.xyy * h).x +\n        k.yyx * sceneSDF(point + k.yyx * h).x +\n        k.yxy * sceneSDF(point + k.yxy * h).x +\n        k.xxx * sceneSDF(point + k.xxx * h).x );\n\n}\n\nconst float shadowSharpness = 128.0;\nvec2 softShadow(vec3 rayOrigin, vec3 rayDirection, float near, float far)\n{\n    float depth = near;\n    float result = 1.0;\n    int i = 0;\n\n    for (; i < uMaxMarchingSteps; i++)\n    {\n        float dist = sceneSDF(rayOrigin + depth * rayDirection).x;\n        if (dist < uEpsilon)\n        {\n            return vec2(0.0, float(i));\n        }\n\n        result = min(result, shadowSharpness * dist / depth);\n        depth += dist;\n        if (depth >= far)\n        {\n            return vec2(result, float(i));\n        }\n    }\n\n    return vec2(result, float(i));\n}\n\nconst vec3 ambientLight = 0.5 * 0.2 * vec3(1.0, 1.0, 1.0);\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n *\n * The vec3 returned is the RGB color of the light's contribution.\n *\n * diffuse: Diffuse color\n * specular: Specular color\n * shininess: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 currentDepth, vec3 diffuse, vec3 specular, float shininess, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormalPhong(p, currentDepth);\n\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (diffuse * dotLN);\n    }\n    return lightIntensity * (diffuse * dotLN + specular * pow(dotRV, shininess));\n}\n\n\n/**\n * Lighting via Phong illumination.\n *\n * The vec3 returned is the RGB color of that point after lighting is applied.\n * diffuse: Diffuse color\n * specular: Specular color\n * alpha: Shininess coefficient\n * worldPoint: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec4 phongIllumination(vec3 currentDepth, vec3 diffuse, vec3 specular, float shininess, vec3 worldPoint, vec3 cameraPoint)\n{\n    vec3 colour = ambientLight;\n    float light0Rays;\n\n    for (int i = 0; i < uNumLights; i++)\n    {\n        mat2x4 light = uLights[i];\n        vec3 lightPos = light[0].xyz;\n\n        vec2 shadow = vec2(1.0, 0.0);\n        if (uFlags.x)\n        {\n            vec3 toLight = normalize(lightPos - worldPoint);\n            shadow = softShadow(worldPoint, toLight, 0.005 * currentDepth.x, 100.0);\n\n            if (i == 1)\n            {\n                light0Rays = shadow.y;\n            }\n        }\n\n        vec3 lightContrib = phongContribForLight(currentDepth, diffuse, specular, shininess, worldPoint, cameraPoint, lightPos, light[1].xyz);\n        colour += lightContrib * shadow.x;\n    }\n\n    // colour = pow(colour, vec3(1.0 / 2.2)); // Gamma correction\n    return vec4(colour, light0Rays);\n}\n\n/**\n * Lighting contribution of a single point light source via Lambert illumination.\n *\n * The vec3 returned is the RGB color of the light's contribution.\n *\n * diffuse: Diffuse color\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n */\nvec3 lambertContribForLight(vec3 currentDepth, vec3 diffuse, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormalTetrahedron(p, currentDepth);\n\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n\n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    return lightIntensity * (diffuse * dotLN);\n}\n\n/**\n * Lighting via Phong illumination.\n *\n * The vec3 returned is the RGB color of that point after lighting is applied.\n * diffuse: Diffuse color\n * specular: Specular color\n * alpha: Shininess coefficient\n * worldPoint: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec4 lambertIllumination(vec3 currentDepth, vec3 diffuse, vec3 worldPoint, vec3 cameraPoint)\n{\n    vec3 colour = ambientLight;\n    float light0Rays;\n\n    for (int i = 0; i < uNumLights; i++)\n    {\n        mat2x4 light = uLights[i];\n        vec3 lightPos = light[0].xyz;\n\n        vec2 shadow = vec2(1.0, 0.0);\n        if (uFlags.x)\n        {\n            vec3 toLight = normalize(lightPos - worldPoint);\n            shadow = softShadow(worldPoint, toLight, 0.005 * currentDepth.x, 100.0);\n\n            if (i == 1)\n            {\n                light0Rays = shadow.y;\n            }\n        }\n\n        vec3 lightContrib = lambertContribForLight(currentDepth, diffuse, worldPoint, cameraPoint, lightPos, light[1].xyz);\n        colour += lightContrib * shadow.x;\n    }\n\n    // colour = pow(colour, vec3(1.0 / 2.2)); // Gamma correction\n    return vec4(colour, light0Rays);\n}\n\nvec4 rayMarch(vec3 rayOrigin, vec3 rayDirection, float near, float far)\n{\n    float depth = near;\n    for (int i = 0; i < uMaxMarchingSteps; i++)\n    {\n        vec2 dist = sceneSDF(rayOrigin + depth * rayDirection);\n        if (dist.x < uEpsilon)\n        {\n            return vec4(depth, dist.x, float(i), dist.y);\n        }\n\n        depth += dist.x;\n        if (depth >= far)\n        {\n            return vec4(far, dist.x, float(i), dist.y);\n        }\n    }\n\n    return vec4(far, far, float(uMaxMarchingSteps), -1);\n}\n\nvoid main()\n{\n    vec3 rayDir = uCameraMatrix * createRayDirection(45.0, oPosition);\n    vec3 rayOrigin = uCameraPosition;\n\n    vec4 dist = rayMarch(rayOrigin, rayDir, MIN_DIST, MAX_DIST);\n    vec4 litColour;\n\n    if (dist.x > MAX_DIST - uEpsilon)\n    {\n        if (uFlags.y)\n        {\n            float r = dist.z / float(uMaxMarchingSteps);\n            fragColour = vec4(r, 0, 0, 1);\n            return;\n        }\n\n        fragColour = vec4(0, 0, 0, 0);\n    }\n    else\n    {\n        // The closest point on the surface to the eyepoint along the view ray\n        vec3 worldPoint = rayOrigin + dist.x * rayDir;\n\n        int lightingModel = 0;\n        vec3 diffuse = vec3(0.7, 0.2, 0.2);\n        vec3 specular = vec3(1.0, 1.0, 1.0);\n        float shininess = 10.0;\n        if (dist.w >= 0.0)\n        {\n            mat2x4 material = uMaterials[int(dist.w)];\n            diffuse = material[0].xyz;\n            lightingModel = int(round(material[0].w));\n\n            specular = material[1].xyz;\n            shininess = material[1].w;\n        }\n\n        if (lightingModel == 0)\n        {\n            litColour = vec4(diffuse, 1.0);\n        }\n        else if (lightingModel == 1)\n        {\n            litColour = lambertIllumination(dist.xyz, diffuse, worldPoint, rayOrigin);\n        }\n        else if (lightingModel == 2)\n        {\n            litColour = phongIllumination(dist.xyz, diffuse, specular, shininess, worldPoint, rayOrigin);\n        }\n\n        fragColour = vec4(litColour.xyz, 1.0);\n    }\n\n    if (uFlags.y)\n    {\n        float r = dist.z / float(uMaxMarchingSteps);\n        float g = litColour.w / float(uMaxMarchingSteps);\n        fragColour = vec4(r, g, 0, 1);\n    }\n}", "const int ShapeTypeNone = -5000;\nconst int ShapeTypeBox = -6000;\nconst int ShapeTypeSphere = -7000;\nconst int ShapeTypeHexPrism = -8000;\n\nconst int SdfOpCodeNone = -500;\nconst int SdfOpCodeUnion = -600;\nconst int SdfOpCodeIntersection = -700;\nconst int SdfOpCodeSubtraction = -800;\n\nfloat sdfSphere(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat sdfHexPrism(vec3 point, vec2 params)\n{\n    vec3 absPoint = abs(point);\n    float d1 = absPoint.z - params.y;\n    float d2 = max((absPoint.x * 0.866025 + absPoint.y * 0.5), absPoint.y) - params.x;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat sdfBox(vec3 point, vec3 size)\n{\n    vec3 d = abs(point) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0)   // inside distance\n        + length(max(d, 0.0));              // outside distance\n}\n\nvec2 opUnion(vec2 d1, vec2 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n    // return min(d1, d2);\n}\n\nvec2 opSubtraction(vec2 d1, vec2 d2)\n{\n    return -d1.x > d2.x ? vec2(-d1.x, d1.y) : d2;\n    // return max(-d1, d2);\n}\n\nvec2 opIntersection(vec2 d1, vec2 d2)\n{\n    return d1.x > d2.x ? d1 : d2;\n    // return max(d1, d2);\n}\n\nvec2 applyOpCode(int opCode, vec2 dist1, vec2 dist2)\n{\n    switch (opCode)\n    {\n        case SdfOpCodeUnion: return opUnion(dist1, dist2);\n        case SdfOpCodeIntersection: return opIntersection(dist1, dist2);\n        case SdfOpCodeSubtraction: return opSubtraction(dist1, dist2);\n    }\n\n    return vec2(100.0, -1);\n}\n\nfloat getDistToType(int type, vec3 point, vec3 params)\n{\n    switch (type)\n    {\n        case ShapeTypeBox: return sdfBox(point, params);\n        case ShapeTypeSphere: return sdfSphere(point, params.x);\n        case ShapeTypeHexPrism: return sdfHexPrism(point, params.xy);\n    }\n\n    return 100.0;\n}", "interface ShaderLookup\n{\n    readonly [name: string]: string\n}\n\nconst includePragma = /^#include\\s+\\<([^\\>]+)\\>/gmi;\n\nexport default class Shader\n{\n    public readonly program: WebGLProgram;\n\n    constructor(program: WebGLProgram)\n    {\n        this.program = program;\n    }\n\n    public static assembleShader(includes: ShaderLookup, text: string)\n    {\n        const matches = text.matchAll(includePragma);\n        for (const match of matches)\n        {\n            let toInclude = includes[match[1]];\n            if (toInclude === undefined)\n            {\n                console.error(`Unknown shader include ${match[1]}`);\n                toInclude = '';\n            }\n\n            text = text.replace(match[0], toInclude);\n        }\n\n        return text;\n    }\n\n    public static create(gl: WebGL2RenderingContext, includes: ShaderLookup, vertText: string, fragText: string): Shader\n    {\n        function cleanup()\n        {\n            if (program != null)\n            {\n                gl.detachShader(program, vert);\n                gl.detachShader(program, frag);\n            }\n\n            if (vert != null)\n            {\n                gl.deleteShader(vert);\n            }\n\n            if (frag != null)\n            {\n                gl.deleteShader(frag);\n            }\n        }\n\n        const vert = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vert, this.assembleShader(includes, vertText));\n        gl.compileShader(vert);\n\n        if (!gl.getShaderParameter(vert, gl.COMPILE_STATUS))\n        {\n            const error = gl.getShaderInfoLog(vert);\n            console.error('Vertex shader compile error', error);\n\n            cleanup();\n            throw new Error(`Vertex shader compile error ${error}`);\n        }\n\n        const frag = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(frag, this.assembleShader(includes, fragText));\n        gl.compileShader(frag);\n        if (!gl.getShaderParameter(frag, gl.COMPILE_STATUS))\n        {\n            const error = gl.getShaderInfoLog(frag);\n            console.error('Fragment shader compile error', error);\n\n            cleanup();\n            throw new Error(`Fragment shader compile error ${error}`);\n        }\n\n        const program = gl.createProgram();\n        gl.attachShader(program, vert);\n        gl.attachShader(program, frag);\n        gl.linkProgram(program);\n\n        cleanup();\n\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n        {\n            gl.useProgram(null);\n            gl.deleteProgram(program);\n\n            const error = gl.getProgramInfoLog(program);\n            console.error('Shader link error', error);\n\n            throw new Error(`Shader link error ${error}`);\n        }\n\n        return new Shader(program);\n    }\n}", "/**\n * Common utilities\n * @module glMatrix\n */\nexport type AngleOrder = 'xyz' | 'xzy' | 'yxz' | 'yzx' | 'zxy' | 'zyx';\n\nexport default class mathf {\n    // Configuration Constants\n    static readonly EPSILON = 0.000001;\n    static readonly ANGLE_ORDER: AngleOrder = \"zyx\";\n    static readonly DegToRad = Math.PI / 180;\n    static readonly RadToDeg = 180 / Math.PI;\n\n    /**\n     * Convert Degree To Radian\n     *\n     * @param {number} a Angle in Degrees\n     */\n    static toRadian(a: number) {\n        return a * this.DegToRad;\n    }\n\n    /**\n     * Tests whether or not the arguments have approximately the same value, within an absolute\n     * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n     * than or equal to 1.0, and a relative tolerance is used for larger values)\n     *\n     * @param {number} a The first number to test.\n     * @param {number} b The second number to test.\n     * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n     */\n    equals(a: number, b: number) {\n        return Math.abs(a - b) <= mathf.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n    }\n\n    /**\n     * \u9650\u5B9A\u5728\u6700\u5C0F\u503C\u548C\u6700\u5927\u503C\u4E4B\u95F4\n     * @param value\n     * @param min\n     * @param max\n     * @returns\n     */\n    public static clamp(value: number, min: number, max: number) {\n        return Math.max(Math.min(value, max), min);\n    }\n\n    /**\n     * \u63D2\u503C\n     * @param a\n     * @param b\n     * @param t\n     * @returns\n     */\n    public static lerp(a: number, b: number, t: number) {\n        return a + (b - a) * t;\n    }\n\n    /**\n     * \u5F53\u524D\u503C\u5411target\u6BCF\u6B21\u6700\u591A\u79FB\u52A8maxDelta\u8DDD\u79BB\n     * @param current\n     * @param target\n     * @param maxDelta\n     * @returns\n     */\n    public static moveTowards(current: number, target: number, maxDelta: number) {\n        const difference = target - current;\n        if (Math.abs(difference) <= maxDelta) {\n            return target;\n        } else {\n            return current + Math.sign(difference) * maxDelta;\n        }\n    }\n\n    /**\n     * \u53CD\u63D2\u503C\n     * @param a\n     * @param b\n     * @param t\n     * @returns\n     */\n    inverseLerp(a: number, b: number, t: number) {\n        if (a === b) {\n            return 0;\n        } else {\n            return (t - a) / (b - a);\n        }\n    }\n}", "import { rmat3 } from \"./mat3\";\nimport { rmat4 } from \"./mat4\";\nimport { rquat } from \"./quat\";\n\nexport interface vec3\n{\n    x: number;\n    y: number;\n    z: number;\n}\n\nexport type rvec3 = Readonly<vec3>;\n\n/**\n * Clones this vector\n *\n * @param v the vector to clone\n * @returns a new vector\n */\nexport function vec3Clone(v: rvec3): vec3\n{\n    return {x: v.x, y: v.y, z: v.z};\n}\n\n/**\n * Copy the values from one vec3 to another\n * @param v the target vector\n * @param a the copy vector\n * @returns the target vector\n */\nexport function vec3Copy(v: vec3, a: rvec3)\n{\n    v.x = a.x;\n    v.y = a.y;\n    v.z = a.z;\n    return v;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param v the target vector\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @returns the target vector\n */\nexport function vec3Set(v: vec3, x: number, y: number, z: number)\n{\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Calculates the length vector v\n *\n * @params the source vector\n * @returns length of v\n */\nexport function vec3Length(v: rvec3)\n{\n    return Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2);\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @returns squared length of v\n */\nexport function vec3SquaredLength(v: rvec3)\n{\n    return v.x ** 2 + v.y ** 2 + v.z ** 2;\n}\n\n/**\n * Adds vector other into vec\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3AddTo(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x + right.x;\n    v.y = left.y + right.y;\n    v.z = left.z + right.z;\n    return v;\n}\n\n/**\n * Adds two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Add(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n    }\n}\n\n/**\n * Subtracts vector other from vector vec\n\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3SubFrom(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x - right.x;\n    v.y = left.y - right.y;\n    v.z = left.z - right.z;\n    return v;\n}\n\n/**\n * Subtracts vector other from vector vec into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Sub(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n    }\n}\n\n/**\n * Multiplies the left vector by the right vector\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3MulTo(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x * right.x;\n    v.y = left.y * right.y;\n    v.z = left.z * right.z;\n    return v;\n}\n\n/**\n * Multiplies the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Mul(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x * right.x,\n        y: left.y * right.y,\n        z: left.z * right.z,\n    }\n}\n\n/**\n * Divides the left vector by the right vector\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3DivBy(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x / right.x;\n    v.y = left.y / right.y;\n    v.z = left.z / right.z;\n    return v;\n}\n\n/**\n * Divides the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Div(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x / right.x,\n        y: left.y / right.y,\n        z: left.z / right.z,\n    }\n}\n\n/**\n * Scales the target vector by a scalar number\n * @param v the target vector\n * @param left the left vector\n * @param right amount to scale the vector by\n * @returns the target vector\n */\nexport function vec3ScaleBy(v: vec3, left: vec3 | rvec3, right: number)\n{\n    v.x = left.x * right;\n    v.y = left.y * right;\n    v.z = left.z * right;\n    return v;\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec3Scale(v: rvec3, scale: number): vec3\n{\n    return {\n        x: v.x * scale,\n        y: v.y * scale,\n        z: v.z * scale\n    };\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec3ScaleAndAddBy(target: vec3, left: rvec3, right: rvec3, scale: number): vec3\n{\n    target.x = left.x + (right.x * scale);\n    target.y = left.y + (right.y * scale);\n    target.z = left.z + (right.z * scale);\n    return target;\n}\n\n/**\n * Calculates the Euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns the distance between left and right\n */\nexport function vec3Distance(left: rvec3, right: rvec3)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    return Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);\n}\n\n/**\n * Calculates the squared euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns the square distance between left and right\n */\nexport function vec3SquaredDistance(left: rvec3, right: rvec3)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    return dx ** 2 + dy ** 2 + dz ** 2;\n}\n\n/**\n * Negates the components of vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec3Negate(v: vec3)\n{\n    v.x = -v.x;\n    v.y = -v.y;\n    v.z = -v.z;\n    return v;\n}\n\n/**\n * Negates the components of vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Negated(v: rvec3): vec3\n{\n    return {\n        x: -v.x,\n        y: -v.y,\n        z: -v.z\n    }\n}\n\n/**\n * Inverse of the components of a vector\n *\n * @param v the target vector\n * @param source the source vector\n * @returns the target vector\n */\nexport function vec3Inverse(v: vec3, source: vec3 | rvec3)\n{\n    v.x = 1.0 / source.x;\n    v.y = 1.0 / source.y;\n    v.z = 1.0 / source.z;\n    return v;\n}\n\n/**\n * Returns the inverse of the components of a vector into a new vector\n *\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Inversed(v: rvec3): vec3\n{\n    return {\n        x: 1.0 / v.x,\n        y: 1.0 / v.y,\n        z: 1.0 / v.z\n    };\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec3Normalize(v: vec3, source: vec3 | rvec3)\n{\n    let sqrtLen = vec3SquaredLength(source);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x = source.x * sqrtLen;\n    v.y = source.y * sqrtLen;\n    v.z = source.z * sqrtLen;\n    return v;\n}\n\nexport function vec3NormalizeValues(v: vec3, x: number, y: number, z: number)\n{\n    let sqrtLen = x ** 2 + y ** 2 + z ** 2;\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x = x * sqrtLen;\n    v.y = y * sqrtLen;\n    v.z = z * sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Normalized(v: rvec3): vec3\n{\n    let sqrtLen = vec3SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen\n    }\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3NormalizedValues(x: number, y: number, z: number): vec3\n{\n    let sqrtLen = x ** 2 + y ** 2 + z ** 2;\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: x * sqrtLen,\n        y: y * sqrtLen,\n        z: z * sqrtLen\n    }\n}\n\n/**\n * Calculates the dot product of two vec3's\n * @param left the left vector\n * @param right the right vector\n * @returns dot product of left and right\n */\nexport function vec3Dot(left: rvec3, right: rvec3)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z;\n}\n\n/**\n * Computes the cross product of two vectors into the target vector\n *\n * @param v the  target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3CrossBy(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    const x = left.y * right.z - left.z * right.y;\n    const y = left.z * right.x - left.x * right.z;\n    const z = left.x * right.y - left.y * right.x;\n\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Computes the cross product of two vectors into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Cross(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.y * right.z - left.z * right.y,\n        y: left.z * right.x - left.x * right.z,\n        z: left.x * right.y - left.y * right.x\n    };\n}\n\n/**\n * Performs a linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs (not clamped)\n * @returns a new vector\n */\nexport function vec3Lerp(left: rvec3, right: rvec3, t: number): vec3\n{\n    return {\n        x: left.x + t * (right.x - left.x),\n        y: left.y + t * (right.y - left.y),\n        z: left.z + t * (right.z - left.z)\n    };\n}\n\n/**\n * Performs a spherical linear interpolation between two vectors\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3SlerpBy(v: vec3, left: vec3 | rvec3, right: rvec3, t: number)\n{\n    const angle = Math.acos(Math.min(Math.max(vec3Dot(left, right), -1), 1));\n    const sinTotal = 1.0 / Math.sin(angle);\n\n    const ratioA = Math.sin((1 - t) * angle) * sinTotal;\n    const ratioB = Math.sin(t * angle) * sinTotal;\n\n    const x = ratioA * left.x + ratioB * right.x;\n    const y = ratioA * left.y + ratioB * right.y;\n    const z = ratioA * left.z + ratioB * right.z;\n\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Performs a spherical linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns a new vector\n */\nexport function vec3Slerp(left: rvec3, right: rvec3, t: number): vec3\n{\n    const angle = Math.acos(Math.min(Math.max(vec3Dot(left, right), -1), 1));\n    const sinTotal = 1.0 / Math.sin(angle);\n\n    const ratioA = Math.sin((1 - t) * angle) * sinTotal;\n    const ratioB = Math.sin(t * angle) * sinTotal;\n\n    return {\n        x: ratioA * left.x + ratioB * right.x,\n        y: ratioA * left.y + ratioB * right.y,\n        z: ratioA * left.z + ratioB * right.z\n    };\n}\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param v the target vector\n * @param v1 the first operand\n * @param v2 the second operand\n * @param v3 the third operand\n * @param v4 the fourth operand\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3Hermite(v: vec3, v1: rvec3, v2: rvec3, v3: rvec3, v4: rvec3, t: number)\n{\n    const factorTimes2 = t * t;\n    const factor1 = factorTimes2 * (2 * t - 3) + 1;\n    const factor2 = factorTimes2 * (t - 2) + t;\n    const factor3 = factorTimes2 * (t - 1);\n    const factor4 = factorTimes2 * (3 - 2 * t);\n\n    v.x = v1.x * factor1 + v2.x * factor2 + v3.x * factor3 + v4.x * factor4;\n    v.y = v1.y * factor1 + v2.y * factor2 + v3.y * factor3 + v4.y * factor4;\n    v.z = v1.z * factor1 + v2.z * factor2 + v3.z * factor3 + v4.z * factor4;\n    return v;\n}\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param v the target vector\n * @param v1 the first operand\n * @param v2 the second operand\n * @param v3 the third operand\n * @param v4 the fourth operand\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3Bezier(v: vec3, v1: rvec3, v2: rvec3, v3: rvec3, v4: rvec3, t: number)\n{\n    const inverseFactor = 1 - t;\n    const inverseFactorTimesTwo = inverseFactor * inverseFactor;\n    const factorTimes2 = t * t;\n    const factor1 = inverseFactorTimesTwo * inverseFactor;\n    const factor2 = 3 * t * inverseFactorTimesTwo;\n    const factor3 = 3 * factorTimes2 * inverseFactor;\n    const factor4 = factorTimes2 * t;\n\n    v.x = v1.x * factor1 + v2.x * factor2 + v3.x * factor3 + v4.x * factor4;\n    v.y = v1.y * factor1 + v2.y * factor2 + v3.y * factor3 + v4.y * factor4;\n    v.z = v1.z * factor1 + v2.z * factor2 + v3.z * factor3 + v4.z * factor4;\n    return v;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param out the target vector\n * @param m the matrix to transform with\n * @returns the target matrix\n */\nexport function vec3TransformMat4(out: vec3, v: vec3 | rvec3, m: rmat4)\n{\n    const vx = v.x,\n        vy = v.y,\n        vz = v.z;\n\n    let w = m.m03 * vx + m.m13 * vy + m.m23 * vz + m.m33;\n    if (w != 0)\n    {\n        w = 1.0 / w;\n    }\n    else\n    {\n        w = 1.0;\n    }\n\n    out.x = (m.m00 * vx + m.m10 * vy + m.m20 * vz + m.m30) / w;\n    out.y = (m.m01 * vx + m.m11 * vy + m.m21 * vz + m.m31) / w;\n    out.z = (m.m02 * vx + m.m12 * vy + m.m22 * vz + m.m32) / w;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param v the target vector\n * @param m the 3x3 matrix to transform with\n * @returns the target vector\n */\nexport function vec3TransformMat3(out: vec3, v: vec3 | rvec3, m: rmat3)\n{\n    const vx = v.x,\n        vy = v.y,\n        vz = v.z;\n\n    out.x = vx * m.m00 + vy * m.m10 + vz * m.m20,\n    out.y = vx * m.m01 + vy * m.m11 + vz * m.m21,\n    out.z = vx * m.m02 + vy * m.m12 + vz * m.m22\n    return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param out the target vector\n * @param v the vector transform\n * @param q quaternion to transform with\n * @returns the target vector\n */\nexport function vec3TransformQuat(out: vec3, v: vec3 | rvec3, q: rquat)\n{\n    if (q.x === 0 && q.y === 0 && q.z === 0 && q.w === 1)\n    {\n        out.x = v.x;\n        out.y = v.y;\n        out.z = v.z;\n        return out;\n    }\n\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n    const x = v.x,\n        y = v.y,\n        z = v.z;\n\n    const w2 = q.w * 2;\n    let uvx = q.y * z - q.z * y,\n        uvy = q.z * x - q.x * z,\n        uvz = q.x * y - q.y * x;\n\n    const uuvx = (q.y * uvz - q.z * uvy) * 2,\n        uuvy = (q.z * uvx - q.x * uvz) * 2,\n        uuvz = (q.x * uvy - q.y * uvx) * 2;\n\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n\n    // return vec3.add(out, a, vec3.add(out, uv, uuv));\n    out.x = x + uvx + uuvx;\n    out.y = y + uvy + uuvy;\n    out.z = z + uvz + uuvz;\n    return out;\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} origin The origin of the rotation\n * @param {number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n/*\nexport function vec3RotateX(out: vec3, v: vec3 | rvec3, origin: rvec3, rad: number)\n{\n    //Translate point to the origin\n    const px = v.x - origin.x,\n        py = v.y - origin.y,\n        pz = v.z - origin.z;\n\n    const srad = Math.sin(rad),\n        crad = Math.cos(rad);\n\n    //perform rotation\n    //rx = px;\n    const ry = py * crad - pz * srad,\n        rz = py * srad + pz * crad;\n\n    //translate to correct position\n    out.x = px + origin.x;\n    out.y = ry + origin.y;\n    out.z = rz + origin.z;\n    return out;\n}\n    */\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     * @param {vec3} origin The origin of the rotation\n     * @param {number} rad The angle of rotation in radians\n     * @returns {vec3} out\n     */\n    /*\n    rotateY(origin: vec3, rad: number) {\n        const data = this.data;\n        const b = origin.data;\n        let p = ,\n            r = [];\n        //Translate point to the origin\n        p[0] = data[0] - b[0];\n        p[1] = data[1] - b[1];\n        p[2] = data[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n\n        //translate to correct position\n\n        return this.set(r[0] + b[0], r[1] + b[1], r[2] + b[2]);\n    }\n        */\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     * @param {vec3} origin The origin of the rotation\n     * @param {number} rad The angle of rotation in radians\n     * @returns {vec3} out\n     */\n    /*\n    rotateZ(origin: vec3, rad: number) {\n        const data = this.data;\n        const b = origin.data;\n        let p = [],\n            r = [];\n        //Translate point to the origin\n        p[0] = data[0] - b[0];\n        p[1] = data[1] - b[1];\n        p[2] = data[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n        r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n        r[2] = p[2];\n\n        //translate to correct position\n\n        return this.set(r[0] + b[0], r[1] + b[1], r[2] + b[2]);\n    }\n        */\n\n    /**\n     * Get the angle between two 3D vectors\n     * @param {vec3} vector The second operand\n     * @returns {number} The angle in radians\n     */\n    /*\n    angle(vector: vec3) {\n        const data = this.data;\n        const b = vector.data;\n        let ax = data[0],\n            ay = data[1],\n            az = data[2],\n            bx = b[0],\n            by = b[1],\n            bz = b[2],\n            mag = Math.sqrt(\n                (ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)\n            ),\n            cosine = mag && this.dot(vector) / mag;\n        return Math.acos(Math.min(Math.max(cosine, -1), 1));\n    }\n        */\n\n/**\n * Creates a zero vector\n */\nexport function vec3Zero(): vec3\n{\n    return {x: 0, y: 0, z: 0}\n}\n\n/**\n * Creates a zero vector\n */\nexport function vec3One(): vec3\n{\n    return {x: 1, y: 1, z: 1}\n}\n\nexport function vec3Abs(v: rvec3): vec3\n{\n    return {\n        x: Math.abs(v.x),\n        y: Math.abs(v.y),\n        z: Math.abs(v.z),\n    }\n}\n\nexport function vec3Max(v: rvec3, s: number): vec3\n{\n    return {\n        x: Math.max(v.x, s),\n        y: Math.max(v.y, s),\n        z: Math.max(v.z, s),\n    }\n}\n\nexport function vec3Min(v: rvec3, s: number): vec3\n{\n    return {\n        x: Math.min(v.x, s),\n        y: Math.min(v.y, s),\n        z: Math.min(v.z, s),\n    }\n}\n\nexport function vec3ApproxEquals(left: rvec3, right: rvec3, delta: number = 0.0001)\n{\n    // Checked if doing a Math.abs check on the diff of each element was faster or not\n    // https://jsperf.app/nukupa\n    // Looked like using the distance was faster in general.\n    return vec3Distance(left, right) < delta;\n}", "export interface vec4\n{\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\nexport type rvec4 = Readonly<vec4>;\n\n/**\n * Clones this vector\n *\n * @param v the vector to clone\n * @returns a new vector\n */\nexport function vec4Clone(v: rvec4): vec4\n{\n    return {x: v.x, y: v.y, z: v.z, w: v.w};\n}\n\n/**\n * Copy the values from one vec4 to another\n * @param v the target vector\n * @param a the copy vector\n * @returns the target vector\n */\nexport function vec4Copy(v: vec4, a: rvec4)\n{\n    v.x = a.x;\n    v.y = a.y;\n    v.z = a.z;\n    v.w = a.w;\n    return v;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param v the target vector\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @param w W component\n * @returns the target vector\n */\nexport function vec4Set(v: vec4, x: number, y: number, z: number, w: number)\n{\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    v.w = w;\n    return v;\n}\n\n/**\n * Calculates the length vector v\n *\n * @params the source vector\n * @returns length of v\n */\nexport function vec4Length(v: rvec4)\n{\n    return Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2 + v.w ** 2);\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @params the source vector\n * @returns squared length of v\n */\nexport function vec4SquaredLength(v: rvec4)\n{\n    return v.x ** 2 + v.y ** 2 + v.z ** 2 + v.w ** 2;\n}\n\n/**\n * Adds vector other into vec\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec4AddTo(left: vec4, right: rvec4)\n{\n    left.x += right.x;\n    left.y += right.y;\n    left.z += right.z;\n    left.w += right.w;\n    return left;\n}\n\n/**\n * Adds two vectors into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Add(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n        w: left.w + right.w\n    }\n}\n\n/**\n * Subtracts vector other from vector vec\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function vec4SubFrom(left: vec4, right: rvec4)\n{\n    left.x -= right.x;\n    left.y -= right.y;\n    left.z -= right.z;\n    left.w -= right.w;\n    return left;\n}\n\n/**\n * Subtracts vector other from vector vec into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Sub(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n        w: left.w - right.w,\n    }\n}\n\n/**\n * Multiplies the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function vec4MulTo(left: vec4, right: rvec4)\n{\n    left.x *= right.x;\n    left.y *= right.y;\n    left.z *= right.z;\n    left.w *= right.w;\n    return left;\n}\n\n/**\n * Multiplies the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Mul(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x * right.x,\n        y: left.y * right.y,\n        z: left.z * right.z,\n        w: left.w * right.w,\n    }\n}\n\n/**\n * Divides the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4DivBy(vec: vec4, other: rvec4)\n{\n    vec.x /= other.x;\n    vec.y /= other.y;\n    vec.z /= other.z;\n    vec.w /= other.w;\n    return vec;\n}\n\n/**\n * Divides the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Div(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x / right.x,\n        y: left.y / right.y,\n        z: left.z / right.z,\n        w: left.w / right.w,\n    }\n}\n\n/**\n * Scales the target vector by a scalar number\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns the target vector\n */\nexport function vec4ScaleBy(v: vec4, scale: number)\n{\n    v.x *= scale;\n    v.y *= scale;\n    v.z *= scale;\n    v.w *= scale;\n    return v;\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec4Scale(v: rvec4, scale: number): vec4\n{\n    return {\n        x: v.x * scale,\n        y: v.y * scale,\n        z: v.z * scale,\n        w: v.w * scale\n    };\n}\n\n/**\n * Calculates the Euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns distance between left and right\n */\nexport function vec4Distance(left: rvec4, right: rvec4)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    const dw = left.w - right.w;\n    return Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2 + dw ** 2);\n}\n\n/**\n * Calculates the squared euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns squery distance between left and right\n */\nexport function vec4SquaredDistance(left: rvec4, right: rvec4)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    const dw = left.w - right.w;\n    return dx ** 2 + dy ** 2 + dz ** 2 + dw ** 2;\n}\n\n/**\n * Negates the components of vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec4Negate(v: vec4)\n{\n    v.x = -v.x;\n    v.y = -v.y;\n    v.z = -v.z;\n    v.w = -v.w;\n    return v;\n}\n\n/**\n * Negates the components of vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec4Negated(v: rvec4): vec4\n{\n    return {\n        x: -v.x,\n        y: -v.y,\n        z: -v.z,\n        w: -v.w\n    }\n}\n\n/**\n * Inverse of the components of a vector\n *\n * @params v the target vector\n * @returns the target vector\n */\nexport function vec4Inverse(v: vec4)\n{\n    v.x = 1.0 / v.x;\n    v.y = 1.0 / v.y;\n    v.z = 1.0 / v.z;\n    v.w = 1.0 / v.w;\n    return v;\n}\n\n/**\n * Returns the inverse of the components of a vector into a new vector\n *\n * @params v the target vector\n * @returns a new vector\n */\nexport function vec4Inversed(v: rvec4): vec4\n{\n    return {\n        x: 1.0 / v.x,\n        y: 1.0 / v.y,\n        z: 1.0 / v.z,\n        w: 1.0 / v.w\n    };\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec4Normalize(v: vec4)\n{\n    let sqrtLen = vec4SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x *= sqrtLen;\n    v.y *= sqrtLen;\n    v.z *= sqrtLen;\n    v.w *= sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec4Normalized(v: rvec4): vec4\n{\n    let sqrtLen = vec4SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen,\n        w: v.w * sqrtLen\n    }\n}\n\n/**\n * Calculates the dot product of two vec4's\n * @param left the left vector\n * @param right the right vector\n * @returns dot product of left and right\n */\nexport function vec4Dot(left: rvec4, right: rvec4)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n}\n\n\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param v1 the first vector\n * @param v2 the second vector\n * @param v3 the third vector\n * @returns a new vector\n */\nexport function vec4Cross(v1: rvec4, v2: rvec4, v3: rvec4): vec4\n{\n    const A = v2.x * v3.y - v2.y * v3.x,\n      B = v2.x * v3.z - v2.z * v3.x,\n      C = v2.x * v3.w - v2.w * v3.x,\n      D = v2.y * v3.z - v2.z * v3.y,\n      E = v2.y * v3.w - v2.w * v3.y,\n      F = v2.z * v3.w - v2.w * v3.z;\n    const G = v1.x;\n    const H = v1.y;\n    const I = v1.z;\n    const J = v1.w;\n\n    return {\n      x: H * F - I * E + J * D,\n      y: -(G * F) + I * C - J * B,\n      z: G * E - H * C + J * A,\n      w: -(G * D) + H * B - I * A\n    };\n}\n\n/**\n * Performs a linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs (not clamped)\n * @returns a new vector\n */\nexport function vec4Lerp(left: rvec4, right: rvec4, t: number): vec4\n{\n    return {\n        x: left.x + t * (right.x - left.x),\n        y: left.y + t * (right.y - left.y),\n        z: left.z + t * (right.z - left.z),\n        w: left.w + t * (right.w - left.w)\n    };\n}\n\n\n  /**\n   * Transforms the vec4 with a mat4.\n   * @param {mat4} matrix matrix to transform with\n   * @returns {vec4} out\n   */\n  /*\n  transformMat4(matrix: mat4) {\n    const { data: out, data: a } = this;\n    const m = matrix.data;\n    let x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return this;\n  }\n    */\n\n  /**\n   * Transforms the vec4 with a quat\n   * @param {ReadonlyQuat} rotation quaternion to transform with\n   * @returns {vec4} out\n   */\n  /*\n  transformQuat(rotation: quat) {\n    const { data: out, data: a } = this;\n    const q = rotation.data;\n    let x = a[0],\n      y = a[1],\n      z = a[2];\n    let qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n\n    // calculate quat * vec\n    let ix = qw * x + qy * z - qz * y;\n    let iy = qw * y + qz * x - qx * z;\n    let iz = qw * z + qx * y - qy * x;\n    let iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    out[3] = a[3];\n    return this;\n  }*/\n\n/**\n * Creates a zero vector\n */\nexport function vec4Zero(): vec4\n{\n    return {x: 0, y: 0, z: 0, w: 0}\n}\n\nexport function vec4One(): vec4\n{\n    return {x: 1, y: 1, z: 1, w: 1}\n}\n\nexport function vec4ApproxEquals(left: rvec4, right: rvec4, delta: number = 0.0001)\n{\n    // Checked if doing a Math.abs check on the diff of each element was faster or not\n    // https://jsperf.app/nukupa\n    // Looked like using the distance was faster in general.\n    return vec4Distance(left, right) < delta;\n}", "import mathf, { AngleOrder } from \"./mathf\";\nimport { rvec3, vec3, vec3Cross, vec3CrossBy, vec3Dot, vec3Normalize, vec3SquaredLength } from \"./vec3\";\n\nexport interface quat\n{\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\nexport type rquat = Readonly<quat>;\n\nexport function quatIdentity(): quat\n{\n    return {x: 0, y: 0, z: 0, w: 1}\n}\n\n/**\n * Clones this quat\n *\n * @param v the quat to clone\n * @returns a new quat\n */\nexport function quatClone(v: rquat): quat\n{\n    return {x: v.x, y: v.y, z: v.z, w: v.w};\n}\n\n/**\n * Calculates the length quat q\n *\n * @params the source quat\n * @returns length of q\n */\nexport function quatLength(q: rquat)\n{\n    return Math.sqrt(q.x ** 2 + q.y ** 2 + q.z ** 2 + q.w ** 2);\n}\n\n/**\n * Calculates the squared length of a quat\n *\n * @params the source quat\n * @returns squared length of q\n */\nexport function quatSquaredLength(q: rquat)\n{\n    return q.x ** 2 + q.y ** 2 + q.z ** 2 + q.w ** 2;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis, then returns it.\n * @param q the target quat\n * @param axis the axis around which to rotate\n * @param rad the angle in radians\n * @returns the target quat\n */\nexport function quatSetAxisAngle(q: quat, axis: rvec3, rad: number)\n{\n    rad = rad * 0.5;\n    const s = Math.sin(rad);\n\n    q.x = s * axis.x;\n    q.y = s * axis.y;\n    q.z = s * axis.z;\n    q.w = Math.cos(rad);\n    return q\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as provided in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param out Vector receiving the axis of rotation\n * @param q Quaternion to be decomposed\n * @return Angle, in radians, of the rotation\n */\nexport function quatGetAxisAngle(out: vec3, q: rquat)\n{\n    const rad = Math.acos(q.w) * 2.0;\n    const s = Math.sin(rad / 2.0);\n\n    if (s > mathf.EPSILON)\n    {\n      out.x = q.x / s;\n      out.y = q.y / s;\n      out.z = q.z / s;\n    }\n    else\n    {\n      // If s is zero, return any axis (no rotation - axis does not matter)\n      out.x = 1;\n      out.y = 0;\n      out.z = 0;\n    }\n    return rad;\n}\n\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param left the left quat\n * @param right the right quat\n * @return Angle, in radians, between the two quaternions\n */\nexport function quatGetAngle(left: rquat, right: rquat)\n{\n    const dot = quatDot(left, right);\n    return Math.acos(2 * dot * dot - 1);\n}\n\n/**\n * Calculates the dot product of two quat's\n * @param left the left quat\n * @param right the right quat\n * @returns dot product of left and right\n */\nexport function quatDot(left: rquat, right: rquat)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n}\n\n  /**\n * Set the components of a quat to the given values\n *\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @param w W component\n * @returns the target quat\n */\nexport function quatSet(q: quat, x: number, y: number, z: number, w: number)\n{\n    q.x = x;\n    q.y = y;\n    q.z = z;\n    q.w = w;\n    return q;\n}\n\n/**\n * Multiplies the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function quatMulTo(left: quat, right: rquat)\n{\n    const ax = left.x,\n      ay = left.y,\n      az = left.z,\n      aw = left.w;\n    const bx = right.x,\n      by = right.y,\n      bz = right.z,\n      bw = right.w;\n\n    left.x = ax * bw + aw * bx + ay * bz - az * by;\n    left.y = ay * bw + aw * by + az * bx - ax * bz;\n    left.z = az * bw + aw * bz + ax * by - ay * bx;\n    left.w = aw * bw - ax * bx - ay * by - az * bz;\n\n    return left;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function quatRotateX(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const bx = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw + aw * bx;\n    q.y = ay * bw + az * bx;\n    q.z = az * bw - ay * bx;\n    q.w = aw * bw - ax * bx;\n    return q;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function quatRotateY(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const by = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw - az * by;\n    q.y = ay * bw + aw * by;\n    q.z = az * bw + ax * by;\n    q.w = aw * bw - ay * by;\n    return q;\n}\n\n  /**\n   * Rotates a quaternion by the given angle about the Z axis\n   *\n   * @param {quat} out quat receiving operation result\n   * @param {quat} a quat to rotate\n   * @param {number} rad angle (in radians) to rotate\n   * @returns {quat} out\n   */\nexport function quatRotateZ(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const bz = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw + ay * bz;\n    q.y = ay * bw - ax * bz;\n    q.z = az * bw + aw * bz;\n    q.w = aw * bw - az * bz;\n    return q;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @returns a new quat\n */\nexport function quatCalculateW(q: rquat): quat\n{\n    return {\n      x: q.x,\n      y: q.y,\n      z: q.z,\n      w: Math.sqrt(Math.abs(1.0 - q.x * q.x - q.y * q.y - q.z * q.z))\n    };\n}\n\n/**\n * Adds vector other into vec\n * @param left the left quat\n * @param right the right quat\n * @returns the target quat\n */\nexport function quatAddTo(left: quat, right: rquat)\n{\n    left.x += right.x;\n    left.y += right.y;\n    left.z += right.z;\n    left.w += right.w;\n    return left;\n}\n\n/**\n * Adds two vectors into a new quat\n * @param left the left quat\n * @param right the right quat\n * @returns a new quat\n */\nexport function quatAdd(left: rquat, right: rquat): quat\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n        w: left.w + right.w\n    }\n}\n\n/**\n * Subtracts quat other from quat vec\n * @param left the left quat\n * @param right the right quat\n * @returns the left quat\n */\nexport function quatSubFrom(left: quat, right: rquat)\n{\n    left.x -= right.x;\n    left.y -= right.y;\n    left.z -= right.z;\n    left.w -= right.w;\n    return left;\n}\n\n/**\n * Subtracts quat other from quat vec into a new quat\n * @param left the left quat\n * @param right the right quat\n * @returns a new quat\n */\nexport function quatSub(left: rquat, right: rquat): quat\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n        w: left.w - right.w,\n    }\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n * @param {quat} q the second operand\n * @param {number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function quatSlerp(left: rquat, right: rquat, t: number): quat\n{\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n    const ax = left.x,\n      ay = left.y,\n      az = left.z,\n      aw = left.w;\n    let bx = right.x,\n      by = right.y,\n      bz = right.z,\n      bw = right.w;\n\n    let omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    }\n\n    // calculate coefficients\n    if (1.0 - cosom > mathf.EPSILON)\n    {\n      // standard case (slerp)\n      omega = Math.acos(cosom);\n      sinom = Math.sin(omega);\n      scale0 = Math.sin((1.0 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    }\n    else\n    {\n      // \"from\" and \"to\" quaternions are very close\n      //  ... so we can do a linear interpolation\n      scale0 = 1.0 - t;\n      scale1 = t;\n    }\n    // calculate final values\n    return {\n      x: scale0 * ax + scale1 * bx,\n      y: scale0 * ay + scale1 * by,\n      z: scale0 * az + scale1 * bz,\n      w: scale0 * aw + scale1 * bw\n    };\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @returns {quat} out\n */\nexport function quatInvert(q: quat)\n{\n    const a0 = q.x,\n      a1 = q.y,\n      a2 = q.z,\n      a3 = q.w;\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1.0 / dot : 0;\n\n    q.x = -a0 * invDot;\n    q.y = -a1 * invDot;\n    q.z = -a2 * invDot;\n    q.w = a3 * invDot;\n    return q;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @returns {quat} out\n */\nexport function quatInverted(q: rquat): quat\n{\n    const a0 = q.x,\n      a1 = q.y,\n      a2 = q.z,\n      a3 = q.w;\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1.0 / dot : 0;\n\n    return {\n      x: -a0 * invDot,\n      y: -a1 * invDot,\n      z: -a2 * invDot,\n      w: a3 * invDot\n    };\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n * @returns {quat} out\n */\nexport function quatConjugate(q: quat)\n{\n    q.x = -q.x;\n    q.y = -q.y;\n    q.z = -q.z;\n    q.w = q.w;\n    return q;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n * @returns {quat} out\n */\nexport function quatConjugated(q: rquat): quat\n{\n    return {\n        x: -q.x,\n        y: -q.y,\n        z: -q.z,\n        w: -q.w\n    }\n}\n\n  /**\n   * Creates a quaternion from the given 3x3 rotation matrix.\n   *\n   * NOTE: The resultant quaternion is not normalized, so you should be sure\n   * to renormalize the quaternion yourself where necessary.\n   * @param {mat3} matrix rotation matrix\n   * @returns {quat} out\n   * @function\n   */\n  /*\n  fromMat3(matrix: mat3) {\n    const data=this.data\n    const m=matrix.data;\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    let fTrace = m[0] + m[4] + m[8];\n    let fRoot;\n\n    if (fTrace > 0.0) {\n      // |w| > 1/2, may as well choose w > 1/2\n      fRoot = Math.sqrt(fTrace + 1.0); // 2w\n      data[3] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot; // 1/(4w)\n      data[0] = (m[5] - m[7]) * fRoot;\n      data[1] = (m[6] - m[2]) * fRoot;\n      data[2] = (m[1] - m[3]) * fRoot;\n    } else {\n      // |w| <= 1/2\n      let i = 0;\n      if (m[4] > m[0]) i = 1;\n      if (m[8] > m[i * 3 + i]) i = 2;\n      let j = (i + 1) % 3;\n      let k = (i + 2) % 3;\n\n      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n      data[i] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot;\n      data[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n      data[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n      data[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n    return this;\n  }\n    */\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @params q the target quat\n * @param x Angle to rotate around X axis in degrees.\n * @param y Angle to rotate around Y axis in degrees.\n * @param z Angle to rotate around Z axis in degrees.\n * @param order Intrinsic order for conversion, default is zyx.\n * @returns the target quat\n */\nexport function quatFromEuler(q: quat, x: number, y: number, z: number, order: AngleOrder = mathf.ANGLE_ORDER)\n{\n    const halfToRad = Math.PI / 360;\n    x *= halfToRad;\n    z *= halfToRad;\n    y *= halfToRad;\n\n    const sx = Math.sin(x);\n    const cx = Math.cos(x);\n    const sy = Math.sin(y);\n    const cy = Math.cos(y);\n    const sz = Math.sin(z);\n    const cz = Math.cos(z);\n\n    switch (order) {\n      case \"xyz\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"xzy\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      case \"yxz\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      case \"yzx\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"zxy\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"zyx\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      default:\n        throw new Error('Unknown angle order ' + order);\n    }\n\n    return this;\n}\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nexport function quatRotationTo(q: quat, a: rvec3, right: rvec3)\n{\n    const dot = vec3Dot(a, right);\n    if (dot < -0.999999)\n    {\n        const xUnit = {x: 1, y: 0, z: 0};\n        let tmpVec3 = vec3CrossBy(xUnit, xUnit, a);\n        if (vec3SquaredLength(tmpVec3) < mathf.EPSILON)\n        {\n            const yUnit = {x: 0, y: 1, z : 0};\n            tmpVec3 = vec3CrossBy(yUnit, yUnit, a);\n        }\n\n        vec3Normalize(tmpVec3, tmpVec3);\n\n        quatSetAxisAngle(q, tmpVec3, Math.PI);\n        return q;\n    }\n    else if (dot > 0.999999)\n    {\n        q.x = 0;\n        q.y = 0;\n        q.z = 0;\n        q.w = 1;\n        return this;\n    }\n    else\n    {\n        const tmpVec3 = vec3Cross(a, right);\n        q.x = tmpVec3.x;\n        q.y = tmpVec3.y;\n        q.z = tmpVec3.z;\n        q.w = 1 + dot;\n        return quatNormalize(q);\n    }\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function quatNormalize(v: quat)\n{\n    let sqrtLen = quatSquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x *= sqrtLen;\n    v.y *= sqrtLen;\n    v.z *= sqrtLen;\n    v.w *= sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function quatNormalized(v: rquat): quat\n{\n    let sqrtLen = quatSquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen,\n        w: v.w * sqrtLen\n    }\n}\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} b the second operand\n * @param {quat} c the third operand\n * @param {quat} d the fourth operand\n * @param {number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function quatSQlerp(a: rquat, b: rquat, c: rquat, d: rquat, t: number)\n{\n    const temp1 = quatSlerp(a, d, t);\n    const temp2 = quatSlerp(b, c, t);\n    return quatSlerp(temp1, temp2, 2 * t * (1 - t));\n};\n\n  /**\n   * Sets the specified quaternion with values corresponding to the given\n   * axes. Each axis is a vec3 and is expected to be unit length and\n   * perpendicular to all other specified axes.\n   *\n   * @param {vec3} view  the vector representing the viewing direction\n   * @param {vec3} right the vector representing the local \"right\" direction\n   * @param {vec3} up    the vector representing the local \"up\" direction\n   * @returns {quat} out\n   */\n//   export function quatSetAxes(view: vec3, right: vec3, up: vec3) {\n//     let _matrix = new mat3();\n//     const { data: matr } = _matrix;\n//     const { data: r } = right;\n//     const { data: v } = view;\n//     const { data: u } = up;\n//     matr[0] = r[0];\n//     matr[3] = r[1];\n//     matr[6] = r[2];\n\n//     matr[1] = u[0];\n//     matr[4] = u[1];\n//     matr[7] = u[2];\n\n//     matr[2] = -v[0];\n//     matr[5] = -v[1];\n//     matr[8] = -v[2];\n//     return this.fromMat3(_matrix).normalize();\n//   }", "// @ts-ignore These are handled by esbuild\nimport vertText from \"../shaders/vert.glsl\";\n// @ts-ignore\nimport fragText from \"../shaders/frag.glsl\";\n// @ts-ignore\nimport sdfFunctionsText from \"../shaders/sdf-functions.glsl\";\n\nimport Shader from \"../shaders/shader\";\nimport { SceneConverter } from \"../ray-marching/scene-converter\";\nimport { quatFromEuler, quatIdentity, rquat, vec3, vec3ScaleAndAddBy, vec3TransformQuat, vec3Zero } from \"../gl-matrix-ts\";\n\nconst positions = [\n    -1, -1,\n    1, -1,\n    1, 1,\n\n    -1, -1,\n    1, 1,\n    -1, 1\n];\n\nconst tempAxisQuat = quatIdentity();\nfunction mat3ArraySetFromQuat(m: Float32Array, q: rquat)\n{\n    const x2 = q.x + q.x;\n    const y2 = q.y + q.y;\n    const z2 = q.z + q.z;\n\n    const xx = q.x * x2;\n    const yx = q.y * x2;\n    const yy = q.y * y2;\n    const zx = q.z * x2;\n    const zy = q.z * y2;\n    const zz = q.z * z2;\n    const wx = q.w * x2;\n    const wy = q.w * y2;\n    const wz = q.w * z2;\n\n    m[0] = 1 - yy - zz;\n    m[1] = yx - wz;\n    m[2] = zx + wy;\n\n    m[3] = yx + wz;\n    m[4] = 1 - xx - zz;\n    m[5] = zy - wx;\n\n    m[6] = zx - wy;\n    m[7] = zy + wx;\n    m[8] = 1 - xx - yy;\n\n    return m;\n}\n\nexport default class WebGLSdfRenderer\n{\n    public readonly gl: WebGL2RenderingContext;\n    public readonly shader:Shader;\n    public readonly positionBuffer: WebGLBuffer;\n\n    public readonly uShapes: WebGLUniformLocation;\n    public readonly uOperations: WebGLUniformLocation;\n    public readonly uNumOperations: WebGLUniformLocation;\n\n    public readonly uMaterials: WebGLUniformLocation;\n\n    public readonly uLights: WebGLUniformLocation;\n    public readonly uNumLights: WebGLUniformLocation;\n\n    public readonly uCameraPosition: WebGLUniformLocation;\n    public readonly uCameraMatrix: WebGLUniformLocation;\n\n    public readonly uAspectRatio: WebGLUniformLocation;\n\n    public readonly uMaxMarchingSteps: WebGLUniformLocation;\n    public readonly uEpsilon: WebGLUniformLocation;\n    public readonly uFlags: WebGLUniformLocation;\n\n    public cameraPosition: vec3 = vec3Zero();\n    public cameraTarget: vec3 = vec3Zero();\n    public cameraRotationX = 0;\n    public cameraRotationY = 0;\n    public cameraDistance = 10;\n\n    public maxMarchingSteps = 255;\n    public epsilon = 0.001;\n\n    public enableShadows = true;\n    public enableShowMarches = false;\n\n    public canvasScale = 1;\n\n    private readonly cameraMatrixArray = new Float32Array(9);\n\n    private prevShapes: any;\n    private prevOperations: any;\n    private prevMaterials: any;\n    private prevLights: any;\n\n    constructor(gl: WebGL2RenderingContext,\n        shader: Shader,\n        positionBuffer: WebGLBuffer,\n        uShapes: WebGLUniformLocation,\n        uOperations: WebGLUniformLocation,\n        uNumOperations: WebGLUniformLocation,\n        uLights: WebGLUniformLocation,\n        uNumLights: WebGLUniformLocation,\n        uMaterials: WebGLUniformLocation,\n        uCameraPosition: WebGLUniformLocation,\n        uCameraMatrix: WebGLUniformLocation,\n        uAspectRatio: WebGLUniformLocation,\n        uMaxMarchingSteps: WebGLUniformLocation,\n        uEpsilon: WebGLUniformLocation,\n        uFlags: WebGLUniformLocation,\n    )\n    {\n        this.gl = gl;\n        this.shader = shader;\n        this.positionBuffer = positionBuffer;\n\n        this.uShapes = uShapes;\n\n        this.uOperations = uOperations;\n        this.uNumOperations = uNumOperations;\n\n        this.uMaterials = uMaterials;\n\n        this.uLights = uLights;\n        this.uNumLights = uNumLights;\n\n        this.uCameraPosition = uCameraPosition;\n        this.uCameraMatrix = uCameraMatrix;\n        this.uAspectRatio = uAspectRatio;\n\n        this.uMaxMarchingSteps = uMaxMarchingSteps;\n        this.uEpsilon = uEpsilon;\n        this.uFlags = uFlags;\n    }\n\n    public setupCanvas()\n    {\n        // Firefox doesn't like having the canvas rendered to until something has happened, like a fillRect\n        this.gl.clearColor(0, 0, 0, 0);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    }\n\n    public orbitCamera(horizontal: number, vertical: number)\n    {\n        this.cameraRotationX += horizontal;\n        this.cameraRotationY += vertical;\n\n        this.updateCamera();\n    }\n\n    public updateCamera()\n    {\n        quatFromEuler(tempAxisQuat, this.cameraRotationX, this.cameraRotationY, 0);\n        const forward = vec3TransformQuat(vec3Zero(), {x: 0, y: 0, z: 1}, tempAxisQuat);\n\n        vec3ScaleAndAddBy(this.cameraPosition, this.cameraTarget, forward, this.cameraDistance);\n        mat3ArraySetFromQuat(this.cameraMatrixArray, tempAxisQuat);\n    }\n\n    public resizeCanvas = (width: number, height: number) =>\n    {\n        const scaledWidth = width * this.canvasScale;\n        const scaledHeight = height * this.canvasScale;\n        this.gl.canvas.width = scaledWidth;\n        this.gl.canvas.height = scaledHeight;\n\n        this.gl.viewport(0, 0, scaledWidth, scaledHeight);\n\n        const aspectRatio = scaledWidth / scaledHeight;\n        this.gl.uniform1f(this.uAspectRatio, aspectRatio);\n    }\n\n    public render(scene: SceneConverter)\n    {\n        if (this.prevLights !== scene.getLights())\n        {\n            console.info('Rendering new lights');\n            this.gl.uniformMatrix2x4fv(this.uLights, false, scene.getLightDataArray());\n            this.gl.uniform1i(this.uNumLights, scene.getNumLights());\n            this.prevLights = scene.getLights();\n        }\n\n        if (this.prevOperations !== scene.getOperations())\n        {\n            console.info('Rendering new operations');\n            const ops = scene.getOperationNumbers();\n            this.gl.uniform1i(this.uNumOperations, ops.length);\n            this.gl.uniform1iv(this.uOperations, ops);\n            this.prevOperations = scene.getOperations();\n        }\n\n        if (this.prevShapes !== scene.getShapes())\n        {\n            console.info('Rendering new shapes');\n            this.gl.uniformMatrix4fv(this.uShapes, false, scene.getShapeDataArray());\n            this.prevShapes = scene.getShapes();\n        }\n\n        if (this.prevMaterials !== scene.getMaterials())\n        {\n            this.prevMaterials = scene.getMaterials();\n            console.info('Rendering new materials', this.prevMaterials);\n            this.gl.uniformMatrix2x4fv(this.uMaterials, false, scene.getMaterialDataArray());\n        }\n\n        this.gl.uniform4i(this.uFlags, this.enableShadows ? 1 : 0, this.enableShowMarches ? 1 : 0, 0, 0);\n        this.gl.uniform1f(this.uEpsilon, this.epsilon);\n        this.gl.uniform1i(this.uMaxMarchingSteps, this.maxMarchingSteps);\n\n        this.gl.uniform3f(\n            this.uCameraPosition,\n            this.cameraPosition.x,\n            this.cameraPosition.y,\n            this.cameraPosition.z\n        );\n        this.gl.uniformMatrix3fv(this.uCameraMatrix, true, this.cameraMatrixArray);\n\n        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    }\n\n    public static create(canvas: HTMLCanvasElement): WebGLSdfRenderer\n    {\n        const gl = canvas.getContext('webgl2');\n        if (gl == null)\n        {\n            throw new Error('Unable to get webgl2 context');\n        }\n\n        const positionBuffer = gl.createBuffer();\n        if (positionBuffer == null)\n        {\n            throw new Error('Unable to create position buffer');\n        }\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n        const includeLookup = {\n            'sdf-functions': sdfFunctionsText\n        }\n\n        const shader = Shader.create(gl, includeLookup, vertText, fragText);\n        gl.useProgram(shader.program);\n\n        const positionAttributeLoc = this.getAttribute(gl, shader, 'aPosition');\n        gl.enableVertexAttribArray(positionAttributeLoc);\n        gl.vertexAttribPointer(positionAttributeLoc, 2, gl.FLOAT, false, 0, 0);\n\n        const uCameraMatrix = this.getUniform(gl, shader, 'uCameraMatrix');\n        const uCameraPosition = this.getUniform(gl, shader, 'uCameraPosition');\n        const uAspectRatio = this.getUniform(gl, shader, 'uAspectRatio');\n\n        const uShapes = this.getUniform(gl, shader, 'uShapes');\n        const uOperations = this.getUniform(gl, shader, 'uOperations');\n        const uNumOperations = this.getUniform(gl, shader, 'uNumOperations');\n\n        const uMaterials = this.getUniform(gl, shader, 'uMaterials');\n\n        const uLights = this.getUniform(gl, shader, 'uLights');\n        const uNumLights = this.getUniform(gl, shader, 'uNumLights');\n\n        const uMaxMarchingSteps = this.getUniform(gl, shader, 'uMaxMarchingSteps');\n        const uEpsilon = this.getUniform(gl, shader, 'uEpsilon');\n        const uFlags = this.getUniform(gl, shader, 'uFlags');\n\n        return new WebGLSdfRenderer(gl, shader, positionBuffer,\n            uShapes, uOperations, uNumOperations,\n            uLights, uNumLights,\n            uMaterials,\n            uCameraPosition, uCameraMatrix, uAspectRatio,\n            uMaxMarchingSteps, uEpsilon, uFlags);\n    }\n\n    private static getAttribute(gl: WebGL2RenderingContext, shader: Shader, name: string)\n    {\n        const attribute = gl.getAttribLocation(shader.program, name);\n        if (attribute < 0)\n        {\n            throw new Error(`Unable to find attribute ${name}`);\n        }\n        return attribute;\n    }\n\n    private static getUniform(gl: WebGL2RenderingContext, shader: Shader, name: string)\n    {\n        const location = gl.getUniformLocation(shader.program, name);\n        if (location == null)\n        {\n            throw new Error(`Unable to find uniform ${name}`);\n        }\n        return location;\n    }\n}", "import { h, Component, Attributes } from 'preact';\nimport { setViewportOptions, ViewportOptions } from '../store/store-state';\nimport { store } from '../store/store';\nimport \"./webgl-viewport-options.scss\";\n\ninterface Props\n{\n    readonly viewportIndex: number;\n    readonly options: ViewportOptions;\n}\n\ninterface LabeledRangeProps\n{\n    readonly label: string;\n    readonly inputProps: any;\n}\nconst LabeledRange = (props: LabeledRangeProps) =>\n{\n    return <label style={{'display': 'inline-block'}}>\n        {props.label}\n        <input style={{'display': 'block'}} type='range' {...props.inputProps} />\n    </label>\n}\n\nexport default class WebGLViewportOptions extends Component<Props>\n{\n    public render(props: Props)\n    {\n        const { pixelated, renderScale, enableShadows, enableShowMarching, epsilon, maxMarchingStep } = this.props.options;\n\n        return <div class=\"viewport-options\">\n            <button onClick={this.togglePixelated}>{ pixelated ? 'Smooth' : 'Pixelated' }</button>\n            <select onChange={this.changeRenderScale} value={renderScale}>\n                <option value=\"2\">2x</option>\n                <option value=\"1.5\">1.5x</option>\n                <option value=\"1\">1x</option>\n                <option value=\"0.5\">0.5x</option>\n                <option value=\"0.25\">0.25x</option>\n                <option value=\"0.125\">0.125x</option>\n            </select>\n            <button onClick={this.toggleShadows}>{ enableShadows ? 'Hide Shadows' : 'Show Shadows' }</button>\n            <button onClick={this.toggleMarching}>{ enableShowMarching ? 'Hide Marching' : 'Show Marching' }</button>\n            <LabeledRange label={`Epsilon ${epsilon}`} inputProps={{value: epsilon, min: 0, max: 0.1, step: 0.000001, onInput: this.changeEpsilon}} />\n            <LabeledRange label={`Marching Steps ${maxMarchingStep}`} inputProps={{value: maxMarchingStep, min: 0, max: 1000, step: 1, onInput: this.changeMarchingSteps}} />\n        </div>;\n    }\n\n    private changeEpsilon = (e: Event) =>\n    {\n        const value = parseFloat((e.target as HTMLInputElement).value);\n        if (!isFinite(value))\n        {\n            console.warn(`Epsilon parse failed`);\n            return;\n        }\n\n        this.updateOptions({ epsilon: value });\n    }\n\n    private changeMarchingSteps = (e: Event) =>\n    {\n        const value = parseFloat((e.target as HTMLInputElement).value);\n        if (!isFinite(value))\n        {\n            console.warn(`Marching steps parse failed`);\n            return;\n        }\n\n        this.updateOptions({ maxMarchingStep: Math.round(value) });\n    }\n\n    private togglePixelated = (e: Event) =>\n    {\n        this.updateOptions({ pixelated: !this.props.options.pixelated });\n    }\n\n    private toggleShadows = (e: Event) =>\n    {\n        this.updateOptions({ enableShadows: !this.props.options.enableShadows });\n    }\n\n    private toggleMarching = (e: Event) =>\n    {\n        this.updateOptions({ enableShowMarching: !this.props.options.enableShowMarching });\n    }\n\n    private updateOptions = (options: Partial<ViewportOptions>) =>\n    {\n        console.log('Options', options);\n        store.execute(setViewportOptions(this.props.viewportIndex, options));\n    }\n\n    private changeRenderScale = (e: Event) =>\n    {\n        const selectedValue = (e.target as HTMLSelectElement).value;\n        const value = Number.parseFloat(selectedValue);\n        if (isFinite(value))\n        {\n            store.execute(setViewportOptions(this.props.viewportIndex, { renderScale: value }));\n        }\n        else\n        {\n            console.warn('Unable to parse canvas scale', selectedValue);\n        }\n    }\n}", "import { h, Component, createRef } from \"preact\";\nimport { ViewportOptions } from \"../store/store-state\";\nimport WebGLSdfRenderer from \"../webgl/webgl-sdf-renderer\";\nimport WebGLViewportOptions from \"./webgl-viewport-options\";\nimport { SceneConverter } from \"../ray-marching/scene-converter\";\nimport \"./webgl-viewport.scss\";\n\ninterface Props\n{\n    readonly viewportIndex: number;\n    readonly options: ViewportOptions;\n    readonly sdfScene: SceneConverter;\n}\n\nexport class WebGLViewport extends Component<Props>\n{\n    private canvasRef = createRef<HTMLCanvasElement>();\n    private renderer?: WebGLSdfRenderer;\n\n    private zoom = 20;\n    private zoomMin = 1;\n    private zoomMax = 80;\n\n    private mousePosX = 0;\n    private mousePosY = 0;\n    private mouseDown = false;\n    private renderFrameCallback: number = -1;\n\n    public componentDidMount(): void\n    {\n        const canvasEl = this.canvasRef.current;\n        this.renderer = WebGLSdfRenderer.create(canvasEl);\n        this.renderer.canvasScale = this.props.options.renderScale;\n        this.renderer.cameraDistance = 10.0;\n        this.renderer.updateCamera();\n        this.updateCanvasSize();\n\n        this.renderer.setupCanvas();\n\n        window.addEventListener('resize', this.onViewportResize);\n\n        canvasEl.parentElement.addEventListener('pointerdown', this.onPointerDown);\n        canvasEl.parentElement.addEventListener('pointermove', this.onPointerMove);\n        canvasEl.parentElement.addEventListener('pointerup', this.onPointerUp);\n        canvasEl.parentElement.addEventListener('wheel', this.onMouseWheel);\n\n        this.requestRender();\n    }\n\n    public componentWillUnmount(): void\n    {\n        window.removeEventListener('resize', this.onViewportResize);\n\n        const canvasEl = this.canvasRef.current;\n        canvasEl.parentElement.removeEventListener('pointerdown', this.onPointerDown);\n        canvasEl.parentElement.removeEventListener('pointermove', this.onPointerMove);\n        canvasEl.parentElement.removeEventListener('pointerup', this.onPointerUp);\n        canvasEl.parentElement.removeEventListener('wheel', this.onMouseWheel);\n    }\n\n    public render()\n    {\n        this.requestRender();\n\n        let canvasClassName = 'viewport__canvas';\n        if (this.props.options.pixelated)\n        {\n            canvasClassName += ' is-pixelated';\n        }\n\n        return <div class='viewport outer-panel'>\n            <canvas className={canvasClassName} ref={this.canvasRef} />\n            <WebGLViewportOptions viewportIndex={this.props.viewportIndex} options={this.props.options} />\n        </div>\n    }\n\n    private updateCanvasSize = () =>\n    {\n        const size = this.canvasRef.current.getBoundingClientRect();\n        this.renderer.resizeCanvas(size.width, size.height);\n    }\n\n    private onViewportResize = () =>\n    {\n        this.updateCanvasSize();\n        this.manualRenderTrigger();\n    }\n\n    private renderScene = () =>\n    {\n        this.renderFrameCallback = -1;\n        const options = this.props.options;\n        this.renderer.epsilon = options.epsilon;\n        this.renderer.maxMarchingSteps = options.maxMarchingStep;\n        this.renderer.enableShadows = options.enableShadows;\n        this.renderer.enableShowMarches = options.enableShowMarching;\n        if (this.renderer.canvasScale !== options.renderScale)\n        {\n            this.renderer.canvasScale = options.renderScale;\n            this.updateCanvasSize();\n        }\n        this.renderer.render(this.props.sdfScene);\n    }\n\n    private onPointerDown = (e: PointerEvent) =>\n    {\n        if (e.target !== this.canvasRef.current)\n        {\n            return;\n        }\n        console.log(e);\n\n        this.mousePosX = e.clientX;\n        this.mousePosY = e.clientY;\n        this.mouseDown = true;\n    }\n\n    private onPointerMove = (e: PointerEvent) =>\n    {\n        if (!this.mouseDown)\n        {\n            return;\n        }\n\n        const dx = e.clientX - this.mousePosX;\n        const dy = e.clientY - this.mousePosY;\n\n        this.mousePosX = e.clientX;\n        this.mousePosY = e.clientY;\n\n        this.renderer.orbitCamera(-dy, -dx);\n\n        this.manualRenderTrigger();\n    }\n\n    private onPointerUp = (e: PointerEvent) =>\n    {\n        this.mouseDown = false;\n    }\n\n    private onMouseWheel = (e: WheelEvent) =>\n    {\n        const delta = e.deltaY > 0 ? 1 : -1;\n        const newZoom = this.zoom + delta;\n        this.zoom = Math.max(Math.min(100, newZoom), 0);\n        this.renderer.cameraDistance = (this.zoom * 0.01) * (this.zoomMax - this.zoomMin) + this.zoomMin;\n        this.renderer.updateCamera();\n\n        this.manualRenderTrigger();\n    }\n\n    private manualRenderTrigger = () =>\n    {\n        this.requestRender();\n    }\n\n    private requestRender = () =>\n    {\n        if (this.renderFrameCallback < 0)\n        {\n            this.renderFrameCallback = requestAnimationFrame(this.renderScene);\n        }\n    }\n}", "import { h, Component } from 'preact';\nimport { rvec2, rvec3, rvec4 } from '../gl-matrix-ts';\nimport \"./vector-view.scss\";\n\ntype basicVector = rvec2 | rvec3 | rvec4;\ninterface Props\n{\n    readonly disabled?: boolean;\n    readonly vector: basicVector;\n    readonly onChange: (oldVector: basicVector, newVector: basicVector) => void;\n}\n\nfunction isVec3(x: basicVector): x is rvec3\n{\n    return Object.hasOwn(x, 'z');\n}\n\nfunction isVec4(x: basicVector): x is rvec4\n{\n    return Object.hasOwn(x, 'w');\n}\n\nexport default class VectorView extends Component<Props>\n{\n    public render()\n    {\n        const v = this.props.vector;\n        const disabled = this.props.disabled;\n        const isV3 = isVec3(v);\n        const isV4 = isVec4(v);\n\n        return <div class=\"vector\">\n            <input disabled={disabled} type='number' value={v.x} onChange={this.onChangeX} placeholder='x' step={0.1} />\n            <input disabled={disabled} type='number' value={v.y} onChange={this.onChangeY} placeholder='y' step={0.1} />\n\n            { isV3 &&\n            <input disabled={disabled} type='number' value={v.z} onChange={this.onChangeZ} placeholder='z' step={0.1} />\n            }\n            { isV4 &&\n            <input disabled={disabled} type='number' value={v.w} onChange={this.onChangeW} placeholder='w' step={0.1} />\n            }\n        </div>;\n    }\n\n    private onChangeX = (e: Event) =>\n    {\n        this.updateVector(e, 'x');\n    }\n\n    private onChangeY = (e: Event) =>\n    {\n        this.updateVector(e, 'y');\n    }\n\n    private onChangeZ = (e: Event) =>\n    {\n        this.updateVector(e, 'z');\n    }\n\n    private onChangeW = (e: Event) =>\n    {\n        this.updateVector(e, 'w');\n    }\n\n    private updateVector = (e: Event, field: string) =>\n    {\n        const v = this.props.vector;\n        const strValue = (e.target as HTMLInputElement).value;\n        const value = parseFloat(strValue);\n        if (!isFinite(value))\n        {\n            console.error('Unable to process vector field', field, strValue);\n            return;\n        }\n\n        console.log('Update vector field', field, value);\n\n        this.props.onChange(v, {...v, [field]: value});\n    }\n}", "import { h, Component } from 'preact';\nimport VectorView from './vector-view';\nimport { vec3, vec4 } from '../gl-matrix-ts';\nimport { Shape } from '../ray-marching/scene-entities';\n\ninterface Props\n{\n    readonly shape: Shape;\n    readonly onChange: (newShape: Shape) => void;\n}\nexport default class ShapeView extends Component<Props>\n{\n    public render()\n    {\n        const shape = this.props.shape;\n\n        if (shape === undefined)\n        {\n            return <div>Empty shape</div>;\n        }\n\n        const isPhong = shape.lightingModel === 'phong';\n\n        return <div>\n            <div>\n                <strong>Type</strong> <select value={shape.type ?? 'none'} onChange={this.onChangeType}>\n                    <option value='none'>None</option>\n                    <option value='box'>Box</option>\n                    <option value='sphere'>Sphere</option>\n                    <option value='hexPrism'>Hex Prism</option>\n                </select>\n            </div>\n            <div>\n                <strong>Shape Params</strong> <VectorView vector={shape.shapeParams} onChange={this.onChangeShapeParams} />\n            </div>\n            <div>\n                <strong>Lighting Model</strong> <select value={shape.lightingModel} onChange={this.onChangeLightingModel}>\n                    <option value='unlit'>Unlit</option>\n                    <option value='lambert'>Lambert</option>\n                    <option value='phong'>Phong</option>\n                </select>\n            </div>\n            <div>\n                <strong>Diffuse Colour</strong> <VectorView vector={shape.diffuseColour} onChange={this.onChangeDiffuseColour} />\n            </div>\n            <div>\n                <strong>Specular Colour</strong> <VectorView disabled={!isPhong} vector={shape.specularColour} onChange={this.onChangeSpecularColour} />\n            </div>\n            <div>\n                <strong>Shininess</strong> <input disabled={!isPhong} type='number' min={0} max={100} step={0.1} value={shape.shininess} placeholder='Shininess' onChange={this.onChangeShininess} />\n            </div>\n        </div>\n    }\n\n    private onChangeType = (e: Event) =>\n    {\n        const value = (e.target as HTMLSelectElement).value;\n        this.updateField(value, 'type');\n    }\n\n    private onChangeLightingModel = (e: Event) =>\n    {\n        const value = (e.target as HTMLSelectElement).value;\n        this.updateField(value, 'lightingModel');\n    }\n\n    private onChangeShininess = (e: Event) =>\n    {\n        const value = parseFloat((e.target as HTMLInputElement).value);\n        if (isFinite(value))\n        {\n            this.updateField(value, 'shininess');\n        }\n    }\n\n    private onChangeShapeParams = (oldVec: vec3, newVec: vec3) =>\n    {\n        this.updateField(newVec, 'shapeParams');\n    }\n\n    private onChangeDiffuseColour = (oldVec: vec4, newVec: vec4) =>\n    {\n        this.updateField(newVec, 'diffuseColour');\n    }\n\n    private onChangeSpecularColour = (oldVec: vec4, newVec: vec4) =>\n    {\n        this.updateField(newVec, 'specularColour');\n    }\n\n    private updateField = (value: any, field: keyof Required<Shape>) =>\n    {\n        console.log('Update shape', field, value);\n        const newShape = {...this.props.shape, [field]: value};\n        this.props.onChange(newShape);\n    }\n}", "import { h, Component } from 'preact';\nimport VectorView from './vector-view';\nimport { vec4 } from '../gl-matrix-ts';\nimport { Light } from '../ray-marching/scene-entities';\n\ninterface Props\n{\n    readonly light: Light;\n    readonly onChange: (newLight: Light) => void;\n}\nexport default class LightView extends Component<Props>\n{\n    public render()\n    {\n        const light = this.props.light;\n\n        if (light === undefined)\n        {\n            return <div>Empty Light</div>;\n        }\n\n        return <div>\n            <div>\n                <strong>Colour</strong> <VectorView vector={light.colour} onChange={this.onChangeColour} />\n            </div>\n        </div>\n    }\n\n    private onChangeColour = (oldVec: vec4, newVec: vec4) =>\n    {\n        this.updateField(newVec, 'colour');\n    }\n\n    private updateField = (value: any, field: keyof Required<Light>) =>\n    {\n        console.log('Update light', field, value);\n        const newShape = {...this.props.light, [field]: value};\n        this.props.onChange(newShape);\n    }\n}", "import { h, Component } from 'preact';\nimport ShapeView from './shape-view';\nimport { Light, SceneNode, SdfOpCode, Shape } from '../ray-marching/scene-entities';\nimport VectorView from './vector-view';\nimport { quat, vec3 } from '../gl-matrix-ts';\nimport LightView from './light-view';\nimport \"./scene-node-view.scss\";\n\ninterface Props\n{\n    readonly node: SceneNode;\n    readonly onChange: (newShapeNode: SceneNode, oldShapeNode: SceneNode) => void;\n}\n\ninterface State\n{\n    readonly show: boolean;\n}\n\nexport default class SceneNodeView extends Component<Props, State>\n{\n    constructor()\n    {\n        super();\n        this.state = {\n            show: false\n        }\n    }\n\n    public render()\n    {\n        const { node } = this.props;\n        if (node == undefined)\n        {\n            return <div class=\"scene-node-view\">\n                No node selected\n            </div>\n        }\n\n        const selectedOpCode = node.childOpCode ?? 'none';\n\n        return <div class=\"scene-node-view\">\n            <div>\n                <strong>Name</strong> <input type='text' placeholder='Name' value={node.name} onChange={this.onChangeName} />\n            </div>\n            <div>\n                <strong>Position</strong> <VectorView vector={node.position} onChange={this.onChangePosition} />\n            </div>\n            <div>\n                <strong>Rotation</strong> <VectorView vector={node.rotation} onChange={this.onChangeRotation} />\n            </div>\n            <div>\n                <strong>Op Code</strong> <select value={selectedOpCode} onChange={this.onChangeOpCode}>\n                    <option value='none'>None</option>\n                    <option value='union'>Union</option>\n                    <option value='intersection'>Intersection</option>\n                    <option value='subtraction'>Subtraction</option>\n                </select>\n            </div>\n            <div>\n                <strong>Shape</strong> <ShapeView shape={node.shape} onChange={this.onChangeShape} />\n            </div>\n            <div>\n                <strong>Light</strong> <LightView light={node.light} onChange={this.onChangeLight} />\n            </div>\n            {/* <div>\n                <strong>Children</strong> {\n                    children.map((child, i) => <ShapeNodeView key={i} node={child} onChange={(n) => this.onChangeChild(i, n)}/>)\n                }\n            </div> */}\n        </div>\n    }\n\n    private onChangeName = (e: Event) =>\n    {\n        const value = (e.target as HTMLInputElement).value;\n        this.updateField(value, 'name');\n    }\n\n    private onChangePosition = (oldVec: vec3, newVec: vec3) =>\n    {\n        this.updateField(newVec, 'position');\n    }\n\n    private onChangeRotation = (oldQuat: quat, newQuat: quat) =>\n    {\n        this.updateField(newQuat, 'rotation');\n    }\n\n\n    private onChangeOpCode = (e: Event) =>\n    {\n        const value = (e.target as HTMLSelectElement).value as SdfOpCode;\n        this.updateField(value, 'childOpCode');\n    }\n\n    private onChangeShape = (shape: Shape) =>\n    {\n        this.updateField(shape, 'shape');\n    }\n\n    private onChangeLight = (light: Light) =>\n    {\n        this.updateField(light, 'light');\n    }\n\n    // private onChangeChild = (index: number, child: SceneNode) =>\n    // {\n    //     const children = this.props.node.children !== undefined ? [...this.props.node.children] : [];\n    //     children[index] = child;\n\n    //     this.updateField(children, 'children');\n    // }\n\n    private updateField = (value: any, field: keyof SceneNode) =>\n    {\n        console.log('Update shape node', field, value);\n        const newNode = {...this.props.node, [field]: value};\n        this.props.onChange(newNode, this.props.node);\n    }\n}", "import { h, Component } from 'preact';\nimport { SceneNode } from '../ray-marching/scene-entities';\nimport './scene-node-tree-item.scss';\n\ninterface Props\n{\n    readonly node: SceneNode;\n    readonly depth: number;\n    readonly isSelected: boolean;\n    readonly onClicked: (node: SceneNode) => void;\n}\n\nexport default class ShapeNodeTreeItem extends Component<Props>\n{\n    public render()\n    {\n        const { depth, node, isSelected } = this.props;\n\n        const className = 'scene-node-tree-item' + (isSelected ? ' is-selected' : '');\n        return <div class={className} style={{'paddingLeft': (depth + 1) * 0.5 + 'rem'}} onClick={this.onClick}>\n            + {node.name}\n        </div>\n    }\n\n    private onClick = () =>\n    {\n        this.props.onClicked(this.props.node);\n    }\n}", "import { h, Component } from 'preact';\nimport { SceneTree, sdfTreeFlatten } from '../ray-marching/scene-tree';\nimport ShapeNodeTreeItem from './scene-node-tree-item';\nimport { SceneNode, ShapeNodeId } from '../ray-marching/scene-entities';\nimport './scene-node-tree.scss';\n\ninterface Props\n{\n    readonly sdfTree: SceneTree;\n    readonly selectedNodeId?: ShapeNodeId;\n    readonly onItemClicked: (node: SceneNode) => void;\n}\n\nexport default class SceneNodeTree extends Component<Props>\n{\n    public render()\n    {\n        return <div class='scene-node-tree'>\n            { this.renderNodeTree() }\n        </div>\n    }\n\n    private renderNodeTree = () =>\n    {\n        const { sdfTree, selectedNodeId, onItemClicked } = this.props;\n        const rootNode = sdfTree.nodes[sdfTree.rootNodeId];\n        const result: h.JSX.Element[] = [];\n        if (rootNode == undefined)\n        {\n            return result;\n        }\n\n        const flattenedTree = sdfTreeFlatten(sdfTree);\n        console.log(flattenedTree);\n        for (const entry of flattenedTree)\n        {\n            const isSelected = entry.node.id === selectedNodeId;\n            result.push(<ShapeNodeTreeItem isSelected={isSelected} depth={entry.depth} key={entry.node.id} node={entry.node} onClicked={onItemClicked} />);\n        }\n\n        return result;\n    }\n}", "import { h, Component } from 'preact';\nimport { SceneConverter } from '../ray-marching/scene-converter';\nimport SceneNodeView from './scene-node-view';\nimport { store } from '../store/store';\nimport { setSelectedNode, updateNode } from '../store/store-state';\nimport SceneNodeTree from './scene-node-tree';\nimport { SceneTree } from '../ray-marching/scene-tree';\nimport { SceneNode, ShapeNodeId } from '../ray-marching/scene-entities';\nimport \"./scene-tree-view.scss\";\n\ninterface Props\n{\n    readonly sdfTree: SceneTree;\n    readonly selectedNodeId?: ShapeNodeId;\n    readonly sdfScene: SceneConverter;\n}\n\nexport default class SceneGraphView extends Component<Props>\n{\n    public render()\n    {\n        const { sdfTree, selectedNodeId } = this.props;\n\n        return <div class=\"scene-tree\">\n            <div class=\"scene-tree__contents outer-panel\">\n                <div class=\"inner-panel\">\n                    <SceneNodeTree sdfTree={sdfTree} selectedNodeId={selectedNodeId} onItemClicked={this.onNodeClicked} />\n                </div>\n                <div class=\"inner-panel\">\n                    <SceneNodeView node={sdfTree.nodes[selectedNodeId]} onChange={this.onChangeSelectedNode} />\n                </div>\n            </div>\n        </div>\n    }\n\n    private onNodeClicked = (node: SceneNode) =>\n    {\n        store.execute(setSelectedNode(node.id));\n    }\n\n    private onChangeSelectedNode = (newNode: SceneNode, oldNode: SceneNode) =>\n    {\n        store.execute(updateNode(newNode));\n    }\n}", "import equal from \"fast-deep-equal\";\nimport { quatIdentity, rquat, rvec3, rvec4, vec3ApproxEquals, vec3One, vec3Zero, vec4One } from \"../gl-matrix-ts\";\nimport { SceneTree } from \"./scene-tree\";\nimport { LightingModelInt, LightingModelLambert, LightingModelPhong, LightingModelType, LightingModelUnlit, SceneNode, SceneNodes, SdfOpCode, SdfOpCodeInt, SdfOpCodeIntersection, SdfOpCodeNone, SdfOpCodeSubtraction, SdfOpCodeUnion, SdfOpCodeXor, ShapeType, ShapeTypeBox, ShapeTypeHexPrism, ShapeTypeInt, ShapeTypeNone, ShapeTypeSphere } from \"./scene-entities\";\n\ninterface ShaderLight\n{\n    readonly position: rvec3;\n    readonly radius: number;\n    readonly colour: rvec4;\n}\nexport const lightDataSize = 3 + 1 + 4;\n\ninterface ShaderMaterialIndex\n{\n    readonly index: number;\n    readonly weight: number;\n}\ninterface ShaderShape\n{\n    readonly position: rvec3;\n    readonly maxSize: number;\n    readonly rotation: rquat;\n    readonly shapeType: ShapeTypeInt;\n    readonly shapeParams: rvec3;\n    readonly material: number;\n}\nexport const shapeDataSize = 4 + 4 + 4 + 4;\n\ninterface ShaderMaterial\n{\n    readonly diffuseColour: rvec3;\n    readonly lightingModel: LightingModelInt;\n    readonly specularColour: rvec3;\n    readonly shininess: number;\n}\nexport const materialDataSize = 4 + 4;\n\nconst SdfOpCodeMap: { readonly [key: string]: SdfOpCodeInt } =\n{\n    'none': SdfOpCodeNone,\n    'union': SdfOpCodeUnion,\n    'intersection': SdfOpCodeIntersection,\n    'subtraction': SdfOpCodeSubtraction,\n    'xor': SdfOpCodeXor,\n}\nconst ShapeTypeMap: { readonly [key: string]: ShapeTypeInt } =\n{\n    'none': ShapeTypeNone,\n    'box': ShapeTypeBox,\n    'sphere': ShapeTypeSphere,\n    'hexPrism': ShapeTypeHexPrism,\n}\nconst LightingModelMap: { readonly [key: string]: LightingModelInt} =\n{\n    'unlit': LightingModelUnlit,\n    'lambert': LightingModelLambert,\n    'phong': LightingModelPhong\n}\n\nfunction toShapeTypeInt(type: ShapeType): ShapeTypeInt\n{\n    return ShapeTypeMap[type] || ShapeTypeNone;\n}\nfunction toOpCodeInt(type: SdfOpCode): SdfOpCodeInt\n{\n    return SdfOpCodeMap[type] || SdfOpCodeNone;\n}\nfunction toLightingModelInt(type: LightingModelType): LightingModelInt\n{\n    return LightingModelMap[type] || LightingModelUnlit;\n}\n\nexport type ShapeOperation = number | SdfOpCode;\n\nexport class SceneConverter\n{\n    private lights: ShaderLight[] = [];\n    private lightDataArray: number[] = [];\n\n    private materials: ShaderMaterial[] = [];\n    private materialDataArray: number[] = [];\n\n    private shapes: ShaderShape[] = [];\n    private shapeDataArray: number[] = [];\n\n    private operations: ShapeOperation[] = [];\n    private numberOperations: number[] = [];\n\n    private previousTree?: SceneTree;\n\n    public getLightDataArray()\n    {\n        return this.lightDataArray;\n    }\n\n    public getLights()\n    {\n        return this.lights;\n    }\n\n    public getNumLights()\n    {\n        return this.lights.length;\n    }\n\n    public getMaterials()\n    {\n        return this.materials;\n    }\n\n    public getMaterialDataArray()\n    {\n        return this.materialDataArray;\n    }\n\n    public getNumMaterials()\n    {\n        return this.materials.length;\n    }\n\n    public getShapeDataArray()\n    {\n        return this.shapeDataArray;\n    }\n\n    public getShapes()\n    {\n        return this.shapes;\n    }\n\n    public getNumTotalShapes()\n    {\n        return this.shapes.length;\n    }\n\n    public setOperations(operations: ShapeOperation[])\n    {\n        this.operations = operations;\n        this.updateOperationNumbers();\n    }\n\n    public getOperations()\n    {\n        return this.operations;\n    }\n\n    public getOperationNumbers()\n    {\n        return this.numberOperations;\n    }\n\n    public setLight(index: number, light: Partial<ShaderLight>)\n    {\n        if (index < 0)\n        {\n            throw new Error(`Out of bounds light index ${index}`);\n        }\n\n        if (index >= this.lights.length)\n        {\n            this.lights[index] = { ...SceneConverter.createNewLight(), ...light };\n        }\n        else\n        {\n            this.lights[index] = { ...this.lights[index], ...light };\n        }\n\n        this.updateLight(index);\n    }\n\n    public setMaterial(index: number, material: Partial<ShaderMaterial>)\n    {\n        if (index < 0)\n        {\n            throw new Error(`Out of bounds material index ${index}`);\n        }\n\n        if (index >= this.materials.length)\n        {\n            this.materials[index] = { ...SceneConverter.createNewMaterial(), ...material };\n        }\n        else\n        {\n            this.materials[index] = { ...this.materials[index], ...material };\n        }\n\n        this.updateMaterial(index);\n    }\n\n    public updateShapesFromTree(sdfTree: SceneTree)\n    {\n        if (this.previousTree === sdfTree)\n        {\n            return;\n        }\n\n        const rootNode = sdfTree.nodes[sdfTree.rootNodeId];\n        if (!rootNode)\n        {\n            return;\n        }\n\n        const { operations, shapes, lights, materials } = SceneConverter.createShapesFromNode(sdfTree);\n        if (!equal(this.operations, operations))\n        {\n            this.operations = operations;\n            console.log('Operations', this.operations);\n\n            this.updateOperationNumbers();\n        }\n\n        if (!equal(this.shapes, shapes))\n        {\n            console.log('Shapes', this.shapes);\n            this.shapes = shapes;\n            this.shapeDataArray.length = 0;\n            for (let i = 0; i < this.shapes.length; i++)\n            {\n                this.updateShape(i);\n            }\n        }\n\n        if (!equal(this.lights, lights))\n        {\n            this.lights = lights;\n            console.log('Lights', this.lights);\n            this.lightDataArray.length = 0;\n            for (let i = 0; i < this.lights.length; i++)\n            {\n                this.updateLight(i);\n            }\n        }\n\n        if (!equal(this.materials, materials))\n        {\n            this.materials = materials;\n            console.log('Materials', this.materials);\n            this.materialDataArray.length = 0;\n            for (let i = 0; i < this.materials.length; i++)\n            {\n                this.updateMaterial(i);\n            }\n        }\n    }\n\n    public static createShapesFromNode(sdfTree: SceneTree)\n    {\n        const rootNode = sdfTree.nodes[sdfTree.rootNodeId];\n        if (!rootNode)\n        {\n            return;\n        }\n\n        const opsStack: ShapeOperation[] = [];\n        const shapeStack: ShaderShape[] = [];\n        const lights: ShaderLight[] = [];\n        const materials: ShaderMaterial[] = [];\n        this.pushToStack(opsStack, shapeStack, lights, materials, rootNode, sdfTree.nodes);\n\n        opsStack.reverse();\n\n        return {\n            operations: opsStack,\n            shapes: shapeStack,\n            lights, materials\n        };\n    }\n\n    private static pushToStack(opsStack: ShapeOperation[], shapeStack: ShaderShape[], lights: ShaderLight[], materials: ShaderMaterial[], node: SceneNode, nodes: SceneNodes)\n    {\n        if (node.childOpCode !== undefined && node.childOpCode !== 'none')\n        {\n            opsStack.push(node.childOpCode);\n        }\n\n        if (node.shape != undefined)\n        {\n            let index = shapeStack.findIndex(s => equal(s, node.shape));\n            if (index < 0)\n            {\n                index = shapeStack.length;\n                const converted = SceneConverter.convertToShape(node, materials);\n                if (converted != null)\n                {\n                    shapeStack.push(converted);\n                }\n            }\n\n            opsStack.push(index);\n        }\n\n        if (node.light != undefined)\n        {\n            const converted = SceneConverter.convertToLight(node);\n            if (converted != null)\n            {\n                lights.push(converted);\n            }\n        }\n\n        if (node.childrenIds !== undefined)\n        {\n            for (const childId of node.childrenIds)\n            {\n                this.pushToStack(opsStack, shapeStack, lights, materials, nodes[childId], nodes);\n            }\n        }\n    }\n\n    public setShape(index: number, shape: Partial<ShaderShape>)\n    {\n        if (index < 0)\n        {\n            throw new Error(`Out of bounds shape index ${index}`);\n        }\n\n        if (index >= this.shapes.length)\n        {\n            this.shapes[index] = SceneConverter.createNewShape(shape);\n        }\n        else\n        {\n            this.shapes[index] = { ...this.shapes[index], ...shape };\n        }\n\n        this.updateShape(index);\n    }\n\n    private updateLight(index: number)\n    {\n        const dataIndex = index * lightDataSize;\n        const light = this.lights[index];\n\n        this.lightDataArray[dataIndex    ] = light.position.x;\n        this.lightDataArray[dataIndex + 1] = light.position.y;\n        this.lightDataArray[dataIndex + 2] = light.position.z;\n        this.lightDataArray[dataIndex + 3] = light.radius;\n        this.lightDataArray[dataIndex + 4] = light.colour.x;\n        this.lightDataArray[dataIndex + 5] = light.colour.y;\n        this.lightDataArray[dataIndex + 6] = light.colour.z;\n        this.lightDataArray[dataIndex + 7] = light.colour.w;\n    }\n\n    private updateMaterial(index: number)\n    {\n        const dataIndex = index * materialDataSize;\n        const material = this.materials[index];\n\n        this.materialDataArray[dataIndex    ] = material.diffuseColour.x;\n        this.materialDataArray[dataIndex + 1] = material.diffuseColour.y;\n        this.materialDataArray[dataIndex + 2] = material.diffuseColour.z;\n        this.materialDataArray[dataIndex + 3] = material.lightingModel;\n        this.materialDataArray[dataIndex + 4] = material.specularColour.x;\n        this.materialDataArray[dataIndex + 5] = material.specularColour.y;\n        this.materialDataArray[dataIndex + 6] = material.specularColour.z;\n        this.materialDataArray[dataIndex + 7] = material.shininess;\n    }\n\n    private updateShape(index: number)\n    {\n        const dataIndex = index * shapeDataSize;\n        const shape = this.shapes[index];\n\n        this.shapeDataArray[dataIndex     ] = shape.position.x;\n        this.shapeDataArray[dataIndex +  1] = shape.position.y;\n        this.shapeDataArray[dataIndex +  2] = shape.position.z;\n        this.shapeDataArray[dataIndex +  3] = shape.maxSize;\n\n        this.shapeDataArray[dataIndex +  4] = shape.rotation.x;\n        this.shapeDataArray[dataIndex +  5] = shape.rotation.y;\n        this.shapeDataArray[dataIndex +  6] = shape.rotation.z;\n        this.shapeDataArray[dataIndex +  7] = shape.rotation.w;\n\n        this.shapeDataArray[dataIndex +  8] = shape.shapeType;\n        this.shapeDataArray[dataIndex +  9] = shape.shapeParams.x;\n        this.shapeDataArray[dataIndex + 10] = shape.shapeParams.y;\n        this.shapeDataArray[dataIndex + 11] = shape.shapeParams.z;\n\n        this.shapeDataArray[dataIndex + 12] = Math.round(shape.material);\n        this.shapeDataArray[dataIndex + 13] = 0; // Unused, but needed for padding\n        this.shapeDataArray[dataIndex + 14] = 0;\n        this.shapeDataArray[dataIndex + 15] = 0;\n    }\n\n    private updateOperationNumbers()\n    {\n        this.numberOperations = this.operations.map(i =>\n        {\n            if (typeof(i) === 'string')\n            {\n                return toOpCodeInt(i);\n            }\n            return i;\n        });\n    }\n\n    public static convertToShape(sceneNode: SceneNode, materials: ShaderMaterial[]): ShaderShape | null\n    {\n        const shape = sceneNode.shape;\n        if (shape == null)\n        {\n            return null;\n        }\n\n        const material: ShaderMaterial = {\n            diffuseColour: shape.diffuseColour,\n            lightingModel: toLightingModelInt(shape.lightingModel),\n            specularColour: shape.specularColour,\n            shininess: shape.shininess\n        }\n        let materialIndex = this.findApproxMaterial(material, materials);\n        if (materialIndex < 0)\n        {\n            materialIndex = materials.length;\n            materials.push(material);\n        }\n\n        return {\n            material: materialIndex,\n            maxSize: shape.maxSize,\n            position: sceneNode.position,\n            rotation: sceneNode.rotation,\n            shapeParams: shape.shapeParams,\n            shapeType: toShapeTypeInt(shape.type)\n        }\n    }\n\n    public static convertToLight(sceneNode: SceneNode): ShaderLight | null\n    {\n        const light = sceneNode.light;\n        if (light == null)\n        {\n            return null;\n        }\n\n        return {\n            colour: light.colour,\n            position: sceneNode.position,\n            radius: light.radius\n        }\n    }\n\n    public static createNewMaterial(): ShaderMaterial\n    {\n        return {\n            diffuseColour: vec3One(),\n            lightingModel: LightingModelLambert,\n            specularColour: vec3One(),\n            shininess: 10\n        }\n    }\n\n    public static createNewLight(): ShaderLight\n    {\n        return {\n            position: vec3Zero(),\n            radius: 10,\n            colour: vec4One()\n        }\n    }\n\n    public static createNewShape(partial: Partial<ShaderShape>): ShaderShape\n    {\n        return {\n            position: vec3Zero(),\n            rotation: quatIdentity(),\n            maxSize: 0,\n            shapeType: ShapeTypeNone,\n            shapeParams: vec3Zero(),\n            material: 0,\n\n            ...partial\n        }\n    }\n\n    private static findApproxMaterial(material: ShaderMaterial, materials: ShaderMaterial[])\n    {\n        for (let i = 0; i < materials.length; i++)\n        {\n            const current = materials[i];\n            if (current.lightingModel !== material.lightingModel ||\n                Math.abs(current.shininess - material.shininess) < 0.0001)\n            {\n                continue;\n            }\n            if (!vec3ApproxEquals(current.diffuseColour, material.diffuseColour))\n            {\n                continue;\n            }\n            if (!vec3ApproxEquals(current.specularColour, material.specularColour))\n            {\n                continue;\n            }\n\n            return i;\n        }\n\n        return -1;\n    }\n}", "import { Opaque } from \"../common\";\nimport { rquat, rvec3, vec3, rvec4, vec4 } from \"../gl-matrix-ts\";\n\nexport type SdfOpCode = 'none' | 'union' | 'intersection' | 'subtraction' | 'xor';\nexport type SdfOpCodeInt = Opaque<number, 'sdfOpCode'>;\nexport const SdfOpCodeNone = -5e2 as SdfOpCodeInt;\nexport const SdfOpCodeUnion = -6e2 as SdfOpCodeInt;\nexport const SdfOpCodeIntersection = -7e2 as SdfOpCodeInt;\nexport const SdfOpCodeSubtraction = -8e2 as SdfOpCodeInt;\nexport const SdfOpCodeXor = -9e2 as SdfOpCodeInt;\n\nexport type ShapeType = 'none' | 'box' | 'sphere' | 'hexPrism';\nexport type ShapeTypeInt = Opaque<number, 'shapeType'>;\nexport const ShapeTypeNone = -5e3 as ShapeTypeInt;\nexport const ShapeTypeBox = -6e3 as ShapeTypeInt;\nexport const ShapeTypeSphere = -7e3 as ShapeTypeInt;\nexport const ShapeTypeHexPrism = -8e3 as ShapeTypeInt;\n\nexport type LightingModelInt = Opaque<number, 'lightingModel'>;\nexport const LightingModelUnlit = 0 as LightingModelInt;\nexport const LightingModelLambert = 1 as LightingModelInt;\nexport const LightingModelPhong = 2 as LightingModelInt;\n\nexport type ShapeNodeId = Opaque<string, 'ShapeNodeId'>;\n\nexport interface SceneNode\n{\n    readonly id: ShapeNodeId;\n    readonly name: string;\n\n    readonly position: rvec3;\n    readonly rotation: rquat;\n\n    readonly shape?: Shape;\n    readonly childOpCode?: SdfOpCode;\n    readonly parentId?: ShapeNodeId;\n    childrenIds?: ShapeNodeId[];\n    readonly light?: Light;\n}\n\nexport interface Light\n{\n    readonly radius: number;\n    readonly colour: rvec4;\n}\n\nexport type LightingModelType = 'unlit' | 'lambert' | 'phong';\nexport interface Shape\n{\n    readonly maxSize: number;\n    readonly type: ShapeType;\n    readonly shapeParams: vec3;\n    readonly diffuseColour: vec3;\n    readonly specularColour: vec3;\n    readonly shininess: number;\n    readonly lightingModel: LightingModelType;\n}\n\nexport interface SceneNodes\n{\n    [shapeNodeId: string /* ShapeNodeId */]: SceneNode\n}\n\nexport function makeShapeNodeId(): ShapeNodeId\n{\n    return crypto.randomUUID() as ShapeNodeId;\n}\n", "import { h, Component, Fragment } from \"preact\";\nimport { AppState, setNodes, setRootNode } from \"../store/store-state\";\nimport { WebGLViewport } from \"./webgl-viewport\";\nimport { quatIdentity, rquat, rvec3, vec3One, vec3Zero, vec4One } from \"../gl-matrix-ts\";\nimport SceneGraph from \"./scene-tree-view\";\nimport { store } from \"../store/store\";\nimport { SceneConverter } from \"../ray-marching/scene-converter\";\nimport { Light, makeShapeNodeId, SceneNode, SceneNodes, SdfOpCode, Shape } from \"../ray-marching/scene-entities\";\nimport \"./webgl-app.scss\"\n\ninterface Props\n{\n    readonly state: AppState;\n}\n\nconst sdfScene = new SceneConverter();\nstore.subscribe(state => state.sdfTree, updateFromStoreChange);\n\nfunction updateFromStoreChange(state: AppState)\n{\n    sdfScene.updateShapesFromTree(state.sdfTree);\n}\n\nexport class WebGLApp extends Component<Props>\n{\n    public render()\n    {\n        const { viewports, sdfTree, selectedNodeId } = this.props.state;\n        console.log('App render', this.props.state);\n\n        return <Fragment>\n            {/* <nav class=\"navbar outer-panel\">\n                <button>File</button>\n            </nav> */}\n\n            <div class=\"main-view\">\n                <div class=\"viewports\">\n                    <WebGLViewport viewportIndex={0} options={viewports[0].options} sdfScene={sdfScene} />\n                </div>\n                <SceneGraph sdfScene={sdfScene} sdfTree={sdfTree} selectedNodeId={selectedNodeId} />\n            </div>\n        </Fragment>\n    }\n}\n\nfunction createNewShape(shape: Partial<Shape>): Shape\n{\n    return {\n        maxSize: 0,\n        type: \"none\",\n        shapeParams: vec3Zero(),\n        diffuseColour: { x: 0.7, y: 0.3, z: 0.2 },\n        specularColour: { x: 1.0, y: 0.8, z: 0.9 },\n        lightingModel: 'lambert',\n        shininess: 10,\n\n        ...shape\n    };\n}\nfunction createNewLight(light: Partial<Light>): Light\n{\n    return {\n        colour: vec4One(),\n        radius: 10,\n\n        ...light\n    }\n}\n\nfunction createNewLightNode(name: string, light?: Partial<Light>, position?: rvec3, rotation?: rquat): SceneNode\n{\n    return {\n        name,\n        position: position ?? vec3Zero(),\n        rotation: rotation ?? quatIdentity(),\n        id: makeShapeNodeId(),\n        light: light != undefined ? createNewLight(light) : undefined\n    }\n}\n\nfunction createNewShapeNode(name: string, shape?: Partial<Shape>, position?: rvec3, rotation?: rquat, childOpCode?: SdfOpCode): SceneNode\n{\n    return {\n        name,\n        position: position ?? vec3Zero(),\n        rotation: rotation ?? quatIdentity(),\n        id: makeShapeNodeId(),\n        shape: shape != undefined ? createNewShape(shape) : undefined,\n        childOpCode\n    }\n}\n\nfunction addChild(parent: SceneNode, child: SceneNode)\n{\n    if (parent.childrenIds == undefined)\n    {\n        parent.childrenIds = [];\n    }\n    parent.childrenIds.push(child.id);\n}\n\nfunction makeNodeMap(...nodes: SceneNode[])\n{\n    const result: SceneNodes = {};\n    for (const node of nodes)\n    {\n        result[node.id] = node;\n    }\n    return result;\n}\n\nfunction loadDefaultSdfScene()\n{\n    // const defaultRootNode: SceneNode = {\n    //     name: 'Root',\n    //     children: [\n    //         {\n    //             name: 'Root',\n    //             childOpCode: \"subtraction\",\n    //             children: [\n    //                 {\n    //                     name: 'Hex Prism',\n    //                     shape: SdfScene.createNewShape({\n    //                         type: 'hexPrism',\n    //                         shapeParams: {x: 0.75, y: 2, z: 0},\n    //                         maxSize: 1.5\n    //                     })\n    //                 },\n    //                 {\n    //                     name: 'Box & Sphere',\n    //                     childOpCode: \"union\",\n    //                     children: [\n    //                         {\n    //                             name: 'Sphere',\n    //                             shape: createNewShape({\n    //                                 type: \"sphere\",\n    //                                 shapeParams: { x: 1, y: 2, z: 1 },\n    //                                 maxSize: 2.0,\n    //                                 diffuseColour: { x: 0.1, y: 0.9, z: 0.2, w: 1.0, },\n    //                             }),\n    //                         },\n    //                         {\n    //                             name: 'Box',\n    //                             shape: createNewShape({\n    //                                 type: \"box\",\n    //                                 shapeParams: { x: 6, y: 1, z: 6 },\n    //                                 position: { x: 0, y: -1.5, z: 0 },\n    //                                 diffuseColour: { x: 0.2, y: 0.25, z: 0.3, w: 1.0, },\n    //                             }),\n    //                         },\n    //                     ],\n    //                 },\n    //             ],\n    //         },\n    //     ]\n    // }\n    const rootNode = createNewShapeNode('Root', null, undefined, undefined, 'subtraction');\n    const hexPrism = createNewShapeNode('Hex Prism', {\n        type: 'hexPrism',\n        shapeParams: {x: 0.75, y: 2, z: 0},\n        maxSize: 1.5\n    });\n    const boxAndSphere = createNewShapeNode('Box & Sphere', undefined, undefined, undefined, 'union');\n\n    addChild(rootNode, hexPrism);\n    addChild(rootNode, boxAndSphere);\n\n    const box = createNewShapeNode('Box', {\n        type: \"box\",\n        shapeParams: { x: 6, y: 1, z: 6 },\n        diffuseColour: { x: 0.2, y: 0.25, z: 0.3 },\n        lightingModel: 'lambert'\n    }, { x: 0, y: -1.5, z: 0 });\n    const sphere = createNewShapeNode('Sphere', {\n        type: \"sphere\",\n        shapeParams: { x: 1, y: 2, z: 1 },\n        maxSize: 2.0,\n        diffuseColour: { x: 0.1, y: 0.9, z: 0.2 },\n        lightingModel: 'phong'\n    })\n    addChild(boxAndSphere, box);\n    addChild(boxAndSphere, sphere);\n\n    const redLight = createNewLightNode('Red Light', {\n        colour: {x: 1.0, y: 0.8, z: 0.6, w: 1}\n    }, {x: 4, y: 2, z: 3});\n    const greenLight = createNewLightNode('Green Light', {\n        colour: {x: 0.2, y: 1.0, z: 0.6, w: 1}\n    }, {x: -4, y: 2, z: 3});\n    addChild(rootNode, redLight);\n    addChild(rootNode, greenLight);\n\n    const nodes = makeNodeMap(rootNode, hexPrism, boxAndSphere, box, sphere, redLight, greenLight);\n\n    store.execute(setRootNode(rootNode.id));\n    store.execute(setNodes(nodes));\n}\n\nloadDefaultSdfScene();", "import { h, render } from 'preact';\nimport { WebGLApp } from \"../components/webgl-app\";\nimport { store } from \"../store/store\";\nimport \"../normalize.css\";\nimport \"./styles.scss\";\n\nconst appEl = document.getElementById(\"app\");\nfunction renderApp()\n{\n    render(<WebGLApp state={store.state()} />, appEl);\n}\n\nrenderApp();\nstore.subscribeAny(renderApp);"],
  "mappings": "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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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",
  "names": ["EmptyModifier", "exports", "DataStore", "initialState", "modifier", "isNewState", "newState", "selector", "subscription", "comparer", "selectorName", "startValue", "obj", "SelectorContext", "index", "callback", "state", "newValue", "name", "result", "require_fast_deep_equal", "__commonJSMin", "exports", "module", "equal", "a", "b", "length", "i", "keys", "key", "slice", "options", "vnodeId", "isValidElement", "rerenderQueue", "prevDebounce", "defer", "depthSort", "CAPTURE_REGEX", "eventClock", "eventProxy", "eventProxyCapture", "i", "EMPTY_OBJ", "EMPTY_ARR", "IS_NON_DIMENSIONAL", "isArray", "Array", "assign", "obj", "props", "removeNode", "node", "parentNode", "removeChild", "createElement", "type", "children", "key", "ref", "normalizedProps", "arguments", "length", "call", "defaultProps", "createVNode", "original", "vnode", "__k", "__", "__b", "__e", "__c", "constructor", "__v", "__i", "__u", "createRef", "current", "Fragment", "BaseComponent", "context", "this", "getDomSibling", "childIndex", "sibling", "updateParentDomPointers", "child", "base", "enqueueRender", "c", "__d", "push", "process", "__r", "debounceRendering", "component", "newVNode", "oldVNode", "oldDom", "commitQueue", "refQueue", "l", "sort", "shift", "__P", "diff", "__n", "namespaceURI", "commitRoot", "diffChildren", "parentDom", "renderResult", "newParentVNode", "oldParentVNode", "globalContext", "namespace", "excessDomChildren", "isHydrating", "childVNode", "newDom", "firstChildDom", "result", "oldChildren", "newChildrenLength", "constructNewChildrenArray", "applyRef", "insert", "nextSibling", "skewedIndex", "matchingIndex", "oldChildrenLength", "remainingOldChildren", "skew", "String", "undefined", "findMatchingIndex", "unmount", "parentVNode", "contains", "insertBefore", "nodeType", "findMatchingIndex", "childVNode", "oldChildren", "skewedIndex", "remainingOldChildren", "x", "y", "key", "type", "oldVNode", "__u", "length", "setStyle", "style", "value", "setProperty", "IS_NON_DIMENSIONAL", "test", "dom", "name", "oldValue", "namespace", "useCapture", "lowerCaseName", "o", "cssText", "replace", "CAPTURE_REGEX", "toLowerCase", "slice", "l", "_attached", "eventClock", "addEventListener", "eventProxyCapture", "eventProxy", "removeEventListener", "e", "removeAttribute", "setAttribute", "createEventProxy", "this", "eventHandler", "_dispatched", "options", "event", "diff", "parentDom", "newVNode", "globalContext", "excessDomChildren", "commitQueue", "oldDom", "isHydrating", "refQueue", "tmp", "c", "isNew", "oldProps", "oldState", "snapshot", "clearProcessingException", "newProps", "isClassComponent", "provider", "componentContext", "i", "renderHook", "count", "renderResult", "newType", "constructor", "undefined", "__e", "__b", "outer", "props", "prototype", "render", "contextType", "__c", "__", "__E", "BaseComponent", "doRender", "sub", "state", "context", "__n", "__d", "__h", "_sb", "__s", "getDerivedStateFromProps", "assign", "__v", "componentWillMount", "componentDidMount", "push", "componentWillReceiveProps", "shouldComponentUpdate", "__k", "some", "vnode", "componentWillUpdate", "componentDidUpdate", "__P", "__r", "getChildContext", "getSnapshotBeforeUpdate", "Fragment", "cloneNode", "children", "diffChildren", "isArray", "base", "then", "MODE_HYDRATE", "nodeType", "nextSibling", "indexOf", "removeNode", "diffElementNodes", "diffed", "commitRoot", "root", "applyRef", "cb", "call", "node", "map", "newHtml", "oldHtml", "newChildren", "inputValue", "checked", "localName", "document", "createTextNode", "createElementNS", "is", "__m", "data", "childNodes", "EMPTY_OBJ", "attributes", "__html", "innerHTML", "content", "getDomSibling", "ref", "hasRefUnmount", "current", "unmount", "parentVNode", "skipRemove", "r", "componentWillUnmount", "replaceNode", "documentElement", "createElement", "namespaceURI", "firstChild", "slice", "EMPTY_ARR", "options", "__e", "error", "vnode", "oldVNode", "errorInfo", "component", "ctor", "handled", "__", "__c", "constructor", "getDerivedStateFromError", "setState", "__d", "componentDidCatch", "__E", "e", "vnodeId", "isValidElement", "undefined", "BaseComponent", "prototype", "update", "callback", "s", "this", "__s", "state", "assign", "props", "__v", "_sb", "push", "enqueueRender", "forceUpdate", "__h", "render", "Fragment", "rerenderQueue", "defer", "Promise", "then", "bind", "resolve", "setTimeout", "depthSort", "a", "b", "__b", "process", "__r", "CAPTURE_REGEX", "eventClock", "eventProxy", "createEventProxy", "eventProxyCapture", "i", "import_simple_data_store", "defaultRenderOptions", "defaultViewport", "store", "DataStore", "sdfTreeUpdateNode", "tree", "node", "newNodes", "sdfTreeSetRootNodeId", "rootNodeId", "sdfTreeSetNodes", "nodes", "sdfTreeFlatten", "rootNode", "result", "addToTree", "depth", "index", "childId", "child", "setViewportOptions", "index", "options", "state", "viewport", "defaultViewport", "newViewport", "viewports", "updateNode", "node", "sdfTreeUpdateNode", "setNodes", "nodes", "sdfTreeSetNodes", "setRootNode", "rootNodeId", "sdfTreeSetRootNodeId", "setSelectedNode", "selectedNodeId", "vert_default", "frag_default", "sdf_functions_default", "includePragma", "Shader", "_Shader", "program", "includes", "text", "matches", "match", "toInclude", "gl", "vertText", "fragText", "cleanup", "vert", "frag", "error", "mathf", "_mathf", "a", "b", "value", "min", "max", "t", "current", "target", "maxDelta", "difference", "vec3ScaleAndAddBy", "target", "left", "right", "scale", "vec3Distance", "dx", "dy", "dz", "vec3TransformQuat", "out", "v", "q", "x", "y", "z", "w2", "uvx", "uvy", "uvz", "uuvx", "uuvy", "uuvz", "vec3Zero", "vec3One", "vec3ApproxEquals", "left", "right", "delta", "vec3Distance", "vec4One", "quatIdentity", "quatFromEuler", "q", "x", "y", "z", "order", "mathf", "halfToRad", "sx", "cx", "sy", "cy", "sz", "cz", "positions", "tempAxisQuat", "quatIdentity", "mat3ArraySetFromQuat", "m", "q", "x2", "y2", "z2", "xx", "yx", "yy", "zx", "zy", "zz", "wx", "wy", "wz", "WebGLSdfRenderer", "_WebGLSdfRenderer", "vec3Zero", "gl", "shader", "positionBuffer", "uShapes", "uOperations", "uNumOperations", "uLights", "uNumLights", "uMaterials", "uCameraPosition", "uCameraMatrix", "uAspectRatio", "uMaxMarchingSteps", "uEpsilon", "uFlags", "horizontal", "vertical", "quatFromEuler", "forward", "vec3TransformQuat", "vec3ScaleAndAddBy", "width", "height", "scaledWidth", "scaledHeight", "aspectRatio", "scene", "ops", "canvas", "includeLookup", "sdf_functions_default", "Shader", "vert_default", "frag_default", "positionAttributeLoc", "name", "attribute", "location", "LabeledRange", "props", "_", "WebGLViewportOptions", "x", "pixelated", "renderScale", "enableShadows", "enableShowMarching", "epsilon", "maxMarchingStep", "value", "options", "store", "setViewportOptions", "selectedValue", "WebGLViewport", "x", "b", "canvasEl", "WebGLSdfRenderer", "canvasClassName", "_", "WebGLViewportOptions", "size", "options", "dx", "dy", "delta", "newZoom", "isVec3", "x", "isVec4", "VectorView", "v", "disabled", "isV3", "isV4", "_", "field", "strValue", "value", "ShapeView", "x", "shape", "_", "isPhong", "VectorView", "value", "oldVec", "newVec", "field", "newShape", "LightView", "x", "light", "_", "VectorView", "oldVec", "newVec", "value", "field", "newShape", "SceneNodeView", "x", "node", "_", "selectedOpCode", "VectorView", "ShapeView", "LightView", "value", "oldVec", "newVec", "oldQuat", "newQuat", "shape", "light", "field", "newNode", "ShapeNodeTreeItem", "x", "depth", "node", "isSelected", "className", "_", "SceneNodeTree", "x", "_", "sdfTree", "selectedNodeId", "onItemClicked", "rootNode", "result", "flattenedTree", "sdfTreeFlatten", "entry", "isSelected", "ShapeNodeTreeItem", "SceneGraphView", "x", "sdfTree", "selectedNodeId", "_", "SceneNodeTree", "SceneNodeView", "node", "store", "setSelectedNode", "newNode", "oldNode", "updateNode", "import_fast_deep_equal", "SdfOpCodeNone", "SdfOpCodeUnion", "SdfOpCodeIntersection", "SdfOpCodeSubtraction", "SdfOpCodeXor", "ShapeTypeNone", "ShapeTypeBox", "ShapeTypeSphere", "ShapeTypeHexPrism", "LightingModelUnlit", "LightingModelLambert", "LightingModelPhong", "makeShapeNodeId", "lightDataSize", "shapeDataSize", "materialDataSize", "SdfOpCodeMap", "SdfOpCodeNone", "SdfOpCodeUnion", "SdfOpCodeIntersection", "SdfOpCodeSubtraction", "SdfOpCodeXor", "ShapeTypeMap", "ShapeTypeNone", "ShapeTypeBox", "ShapeTypeSphere", "ShapeTypeHexPrism", "LightingModelMap", "LightingModelUnlit", "LightingModelLambert", "LightingModelPhong", "toShapeTypeInt", "type", "toOpCodeInt", "toLightingModelInt", "SceneConverter", "_SceneConverter", "operations", "index", "light", "material", "sdfTree", "shapes", "lights", "materials", "equal", "i", "rootNode", "opsStack", "shapeStack", "node", "nodes", "s", "converted", "childId", "shape", "dataIndex", "sceneNode", "materialIndex", "vec3One", "vec3Zero", "vec4One", "partial", "quatIdentity", "current", "vec3ApproxEquals", "sdfScene", "SceneConverter", "store", "state", "updateFromStoreChange", "WebGLApp", "x", "viewports", "sdfTree", "selectedNodeId", "_", "k", "WebGLViewport", "SceneGraphView", "createNewShape", "shape", "vec3Zero", "createNewLight", "light", "vec4One", "createNewLightNode", "name", "position", "rotation", "quatIdentity", "makeShapeNodeId", "createNewShapeNode", "childOpCode", "addChild", "parent", "child", "makeNodeMap", "nodes", "result", "node", "loadDefaultSdfScene", "rootNode", "hexPrism", "boxAndSphere", "box", "sphere", "redLight", "greenLight", "setRootNode", "setNodes", "appEl", "renderApp", "E", "_", "WebGLApp", "store"]
}
