{
  "version": 3,
  "sources": ["../src/gl-matrix-ts/mathf.ts", "../src/gl-matrix-ts/vec3.ts", "../src/gl-matrix-ts/vec4.ts", "../src/gl-matrix-ts/quat.ts", "../src/sdf-scene.ts", "../src/vert.glsl", "../src/frag.glsl", "../src/shader.ts", "../src/webgl-sdf-renderer.ts", "../src/webgl-index.ts"],
  "sourcesContent": ["/**\n * Common utilities\n * @module glMatrix\n */\nexport type AngleOrder = 'xyz' | 'xzy' | 'yxz' | 'yzx' | 'zxy' | 'zyx';\n\nexport default class mathf {\n    // Configuration Constants\n    static readonly EPSILON = 0.000001;\n    static readonly ANGLE_ORDER: AngleOrder = \"zyx\";\n    static readonly DegToRad = Math.PI / 180;\n    static readonly RadToDeg = 180 / Math.PI;\n\n    /**\n     * Convert Degree To Radian\n     *\n     * @param {number} a Angle in Degrees\n     */\n    static toRadian(a: number) {\n        return a * this.DegToRad;\n    }\n\n    /**\n     * Tests whether or not the arguments have approximately the same value, within an absolute\n     * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n     * than or equal to 1.0, and a relative tolerance is used for larger values)\n     *\n     * @param {number} a The first number to test.\n     * @param {number} b The second number to test.\n     * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n     */\n    equals(a: number, b: number) {\n        return Math.abs(a - b) <= mathf.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n    }\n\n    /**\n     * \u9650\u5B9A\u5728\u6700\u5C0F\u503C\u548C\u6700\u5927\u503C\u4E4B\u95F4\n     * @param value\n     * @param min\n     * @param max\n     * @returns\n     */\n    public static clamp(value: number, min: number, max: number) {\n        return Math.max(Math.min(value, max), min);\n    }\n\n    /**\n     * \u63D2\u503C\n     * @param a\n     * @param b\n     * @param t\n     * @returns\n     */\n    public static lerp(a: number, b: number, t: number) {\n        return a + (b - a) * t;\n    }\n\n    /**\n     * \u5F53\u524D\u503C\u5411target\u6BCF\u6B21\u6700\u591A\u79FB\u52A8maxDelta\u8DDD\u79BB\n     * @param current\n     * @param target\n     * @param maxDelta\n     * @returns\n     */\n    public static moveTowards(current: number, target: number, maxDelta: number) {\n        const difference = target - current;\n        if (Math.abs(difference) <= maxDelta) {\n            return target;\n        } else {\n            return current + Math.sign(difference) * maxDelta;\n        }\n    }\n\n    /**\n     * \u53CD\u63D2\u503C\n     * @param a\n     * @param b\n     * @param t\n     * @returns\n     */\n    inverseLerp(a: number, b: number, t: number) {\n        if (a === b) {\n            return 0;\n        } else {\n            return (t - a) / (b - a);\n        }\n    }\n}", "import { rmat3 } from \"./mat3\";\nimport { rmat4 } from \"./mat4\";\nimport { rquat } from \"./quat\";\n\nexport interface vec3\n{\n    x: number;\n    y: number;\n    z: number;\n}\n\nexport type rvec3 = Readonly<vec3>;\n\n/**\n * Clones this vector\n *\n * @param v the vector to clone\n * @returns a new vector\n */\nexport function vec3Clone(v: rvec3): vec3\n{\n    return {x: v.x, y: v.y, z: v.z};\n}\n\n/**\n * Copy the values from one vec3 to another\n * @param v the target vector\n * @param a the copy vector\n * @returns the target vector\n */\nexport function vec3Copy(v: vec3, a: rvec3)\n{\n    v.x = a.x;\n    v.y = a.y;\n    v.z = a.z;\n    return v;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param v the target vector\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @returns the target vector\n */\nexport function vec3Set(v: vec3, x: number, y: number, z: number)\n{\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Calculates the length vector v\n *\n * @params the source vector\n * @returns length of v\n */\nexport function vec3Length(v: rvec3)\n{\n    return Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2);\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @returns squared length of v\n */\nexport function vec3SquaredLength(v: rvec3)\n{\n    return v.x ** 2 + v.y ** 2 + v.z ** 2;\n}\n\n/**\n * Adds vector other into vec\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3AddTo(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x + right.x;\n    v.y = left.y + right.y;\n    v.z = left.z + right.z;\n    return v;\n}\n\n/**\n * Adds two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Add(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n    }\n}\n\n/**\n * Subtracts vector other from vector vec\n\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3SubFrom(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x - right.x;\n    v.y = left.y - right.y;\n    v.z = left.z - right.z;\n    return v;\n}\n\n/**\n * Subtracts vector other from vector vec into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Sub(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n    }\n}\n\n/**\n * Multiplies the left vector by the right vector\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3MulTo(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x * right.x;\n    v.y = left.y * right.y;\n    v.z = left.z * right.z;\n    return v;\n}\n\n/**\n * Multiplies the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Mul(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x * right.x,\n        y: left.y * right.y,\n        z: left.z * right.z,\n    }\n}\n\n/**\n * Divides the left vector by the right vector\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3DivBy(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x / right.x;\n    v.y = left.y / right.y;\n    v.z = left.z / right.z;\n    return v;\n}\n\n/**\n * Divides the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Div(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x / right.x,\n        y: left.y / right.y,\n        z: left.z / right.z,\n    }\n}\n\n/**\n * Scales the target vector by a scalar number\n * @param v the target vector\n * @param left the left vector\n * @param right amount to scale the vector by\n * @returns the target vector\n */\nexport function vec3ScaleBy(v: vec3, left: vec3 | rvec3, right: number)\n{\n    v.x = left.x * right;\n    v.y = left.y * right;\n    v.z = left.z * right;\n    return v;\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec3Scale(v: rvec3, scale: number): vec3\n{\n    return {\n        x: v.x * scale,\n        y: v.y * scale,\n        z: v.z * scale\n    };\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec3ScaleAndAddBy(target: vec3, left: rvec3, right: rvec3, scale: number): vec3\n{\n    target.x = left.x + (right.x * scale);\n    target.y = left.y + (right.y * scale);\n    target.z = left.z + (right.z * scale);\n    return target;\n}\n\n/**\n * Calculates the Euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns the distance between left and right\n */\nexport function vec3Distance(left: rvec3, right: rvec3)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    return Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);\n}\n\n/**\n * Calculates the squared euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns the square distance between left and right\n */\nexport function vec3SquaredDistance(left: rvec3, right: rvec3)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    return dx ** 2 + dy ** 2 + dz ** 2;\n}\n\n/**\n * Negates the components of vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec3Negate(v: vec3)\n{\n    v.x = -v.x;\n    v.y = -v.y;\n    v.z = -v.z;\n    return v;\n}\n\n/**\n * Negates the components of vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Negated(v: rvec3): vec3\n{\n    return {\n        x: -v.x,\n        y: -v.y,\n        z: -v.z\n    }\n}\n\n/**\n * Inverse of the components of a vector\n *\n * @param v the target vector\n * @param source the source vector\n * @returns the target vector\n */\nexport function vec3Inverse(v: vec3, source: vec3 | rvec3)\n{\n    v.x = 1.0 / source.x;\n    v.y = 1.0 / source.y;\n    v.z = 1.0 / source.z;\n    return v;\n}\n\n/**\n * Returns the inverse of the components of a vector into a new vector\n *\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Inversed(v: rvec3): vec3\n{\n    return {\n        x: 1.0 / v.x,\n        y: 1.0 / v.y,\n        z: 1.0 / v.z\n    };\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec3Normalize(v: vec3, source: vec3 | rvec3)\n{\n    let sqrtLen = vec3SquaredLength(source);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x = source.x * sqrtLen;\n    v.y = source.y * sqrtLen;\n    v.z = source.z * sqrtLen;\n    return v;\n}\n\nexport function vec3NormalizeValues(v: vec3, x: number, y: number, z: number)\n{\n    let sqrtLen = x ** 2 + y ** 2 + z ** 2;\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x = x * sqrtLen;\n    v.y = y * sqrtLen;\n    v.z = z * sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Normalized(v: rvec3): vec3\n{\n    let sqrtLen = vec3SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen\n    }\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3NormalizedValues(x: number, y: number, z: number): vec3\n{\n    let sqrtLen = x ** 2 + y ** 2 + z ** 2;\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: x * sqrtLen,\n        y: y * sqrtLen,\n        z: z * sqrtLen\n    }\n}\n\n/**\n * Calculates the dot product of two vec3's\n * @param left the left vector\n * @param right the right vector\n * @returns dot product of left and right\n */\nexport function vec3Dot(left: rvec3, right: rvec3)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z;\n}\n\n/**\n * Computes the cross product of two vectors into the target vector\n *\n * @param v the  target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3CrossBy(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    const x = left.y * right.z - left.z * right.y;\n    const y = left.z * right.x - left.x * right.z;\n    const z = left.x * right.y - left.y * right.x;\n\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Computes the cross product of two vectors into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Cross(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.y * right.z - left.z * right.y,\n        y: left.z * right.x - left.x * right.z,\n        z: left.x * right.y - left.y * right.x\n    };\n}\n\n/**\n * Performs a linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs (not clamped)\n * @returns a new vector\n */\nexport function vec3Lerp(left: rvec3, right: rvec3, t: number): vec3\n{\n    return {\n        x: left.x + t * (right.x - left.x),\n        y: left.y + t * (right.y - left.y),\n        z: left.z + t * (right.z - left.z)\n    };\n}\n\n/**\n * Performs a spherical linear interpolation between two vectors\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3SlerpBy(v: vec3, left: vec3 | rvec3, right: rvec3, t: number)\n{\n    const angle = Math.acos(Math.min(Math.max(vec3Dot(left, right), -1), 1));\n    const sinTotal = 1.0 / Math.sin(angle);\n\n    const ratioA = Math.sin((1 - t) * angle) * sinTotal;\n    const ratioB = Math.sin(t * angle) * sinTotal;\n\n    const x = ratioA * left.x + ratioB * right.x;\n    const y = ratioA * left.y + ratioB * right.y;\n    const z = ratioA * left.z + ratioB * right.z;\n\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Performs a spherical linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns a new vector\n */\nexport function vec3Slerp(left: rvec3, right: rvec3, t: number): vec3\n{\n    const angle = Math.acos(Math.min(Math.max(vec3Dot(left, right), -1), 1));\n    const sinTotal = 1.0 / Math.sin(angle);\n\n    const ratioA = Math.sin((1 - t) * angle) * sinTotal;\n    const ratioB = Math.sin(t * angle) * sinTotal;\n\n    return {\n        x: ratioA * left.x + ratioB * right.x,\n        y: ratioA * left.y + ratioB * right.y,\n        z: ratioA * left.z + ratioB * right.z\n    };\n}\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param v the target vector\n * @param v1 the first operand\n * @param v2 the second operand\n * @param v3 the third operand\n * @param v4 the fourth operand\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3Hermite(v: vec3, v1: rvec3, v2: rvec3, v3: rvec3, v4: rvec3, t: number)\n{\n    const factorTimes2 = t * t;\n    const factor1 = factorTimes2 * (2 * t - 3) + 1;\n    const factor2 = factorTimes2 * (t - 2) + t;\n    const factor3 = factorTimes2 * (t - 1);\n    const factor4 = factorTimes2 * (3 - 2 * t);\n\n    v.x = v1.x * factor1 + v2.x * factor2 + v3.x * factor3 + v4.x * factor4;\n    v.y = v1.y * factor1 + v2.y * factor2 + v3.y * factor3 + v4.y * factor4;\n    v.z = v1.z * factor1 + v2.z * factor2 + v3.z * factor3 + v4.z * factor4;\n    return v;\n}\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param v the target vector\n * @param v1 the first operand\n * @param v2 the second operand\n * @param v3 the third operand\n * @param v4 the fourth operand\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3Bezier(v: vec3, v1: rvec3, v2: rvec3, v3: rvec3, v4: rvec3, t: number)\n{\n    const inverseFactor = 1 - t;\n    const inverseFactorTimesTwo = inverseFactor * inverseFactor;\n    const factorTimes2 = t * t;\n    const factor1 = inverseFactorTimesTwo * inverseFactor;\n    const factor2 = 3 * t * inverseFactorTimesTwo;\n    const factor3 = 3 * factorTimes2 * inverseFactor;\n    const factor4 = factorTimes2 * t;\n\n    v.x = v1.x * factor1 + v2.x * factor2 + v3.x * factor3 + v4.x * factor4;\n    v.y = v1.y * factor1 + v2.y * factor2 + v3.y * factor3 + v4.y * factor4;\n    v.z = v1.z * factor1 + v2.z * factor2 + v3.z * factor3 + v4.z * factor4;\n    return v;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param out the target vector\n * @param m the matrix to transform with\n * @returns the target matrix\n */\nexport function vec3TransformMat4(out: vec3, v: vec3 | rvec3, m: rmat4)\n{\n    const vx = v.x,\n        vy = v.y,\n        vz = v.z;\n\n    let w = m.m03 * vx + m.m13 * vy + m.m23 * vz + m.m33;\n    if (w != 0)\n    {\n        w = 1.0 / w;\n    }\n    else\n    {\n        w = 1.0;\n    }\n\n    out.x = (m.m00 * vx + m.m10 * vy + m.m20 * vz + m.m30) / w;\n    out.y = (m.m01 * vx + m.m11 * vy + m.m21 * vz + m.m31) / w;\n    out.z = (m.m02 * vx + m.m12 * vy + m.m22 * vz + m.m32) / w;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param v the target vector\n * @param m the 3x3 matrix to transform with\n * @returns the target vector\n */\nexport function vec3TransformMat3(out: vec3, v: vec3 | rvec3, m: rmat3)\n{\n    const vx = v.x,\n        vy = v.y,\n        vz = v.z;\n\n    out.x = vx * m.m00 + vy * m.m10 + vz * m.m20,\n    out.y = vx * m.m01 + vy * m.m11 + vz * m.m21,\n    out.z = vx * m.m02 + vy * m.m12 + vz * m.m22\n    return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param out the target vector\n * @param v the vector transform\n * @param q quaternion to transform with\n * @returns the target vector\n */\nexport function vec3TransformQuat(out: vec3, v: vec3 | rvec3, q: rquat)\n{\n    if (q.x === 0 && q.y === 0 && q.z === 0 && q.w === 1)\n    {\n        out.x = v.x;\n        out.y = v.y;\n        out.z = v.z;\n        return out;\n    }\n\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n    const x = v.x,\n        y = v.y,\n        z = v.z;\n\n    const w2 = q.w * 2;\n    let uvx = q.y * z - q.z * y,\n        uvy = q.z * x - q.x * z,\n        uvz = q.x * y - q.y * x;\n\n    const uuvx = (q.y * uvz - q.z * uvy) * 2,\n        uuvy = (q.z * uvx - q.x * uvz) * 2,\n        uuvz = (q.x * uvy - q.y * uvx) * 2;\n\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n\n    // return vec3.add(out, a, vec3.add(out, uv, uuv));\n    out.x = x + uvx + uuvx;\n    out.y = y + uvy + uuvy;\n    out.z = z + uvz + uuvz;\n    return out;\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} origin The origin of the rotation\n * @param {number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n/*\nexport function vec3RotateX(out: vec3, v: vec3 | rvec3, origin: rvec3, rad: number)\n{\n    //Translate point to the origin\n    const px = v.x - origin.x,\n        py = v.y - origin.y,\n        pz = v.z - origin.z;\n\n    const srad = Math.sin(rad),\n        crad = Math.cos(rad);\n\n    //perform rotation\n    //rx = px;\n    const ry = py * crad - pz * srad,\n        rz = py * srad + pz * crad;\n\n    //translate to correct position\n    out.x = px + origin.x;\n    out.y = ry + origin.y;\n    out.z = rz + origin.z;\n    return out;\n}\n    */\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     * @param {vec3} origin The origin of the rotation\n     * @param {number} rad The angle of rotation in radians\n     * @returns {vec3} out\n     */\n    /*\n    rotateY(origin: vec3, rad: number) {\n        const data = this.data;\n        const b = origin.data;\n        let p = ,\n            r = [];\n        //Translate point to the origin\n        p[0] = data[0] - b[0];\n        p[1] = data[1] - b[1];\n        p[2] = data[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n\n        //translate to correct position\n\n        return this.set(r[0] + b[0], r[1] + b[1], r[2] + b[2]);\n    }\n        */\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     * @param {vec3} origin The origin of the rotation\n     * @param {number} rad The angle of rotation in radians\n     * @returns {vec3} out\n     */\n    /*\n    rotateZ(origin: vec3, rad: number) {\n        const data = this.data;\n        const b = origin.data;\n        let p = [],\n            r = [];\n        //Translate point to the origin\n        p[0] = data[0] - b[0];\n        p[1] = data[1] - b[1];\n        p[2] = data[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n        r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n        r[2] = p[2];\n\n        //translate to correct position\n\n        return this.set(r[0] + b[0], r[1] + b[1], r[2] + b[2]);\n    }\n        */\n\n    /**\n     * Get the angle between two 3D vectors\n     * @param {vec3} vector The second operand\n     * @returns {number} The angle in radians\n     */\n    /*\n    angle(vector: vec3) {\n        const data = this.data;\n        const b = vector.data;\n        let ax = data[0],\n            ay = data[1],\n            az = data[2],\n            bx = b[0],\n            by = b[1],\n            bz = b[2],\n            mag = Math.sqrt(\n                (ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)\n            ),\n            cosine = mag && this.dot(vector) / mag;\n        return Math.acos(Math.min(Math.max(cosine, -1), 1));\n    }\n        */\n\n/**\n * Creates a zero vector\n */\nexport function vec3Zero(): vec3\n{\n    return {x: 0, y: 0, z: 0}\n}\n\n/**\n * Creates a zero vector\n */\nexport function vec3One(): vec3\n{\n    return {x: 1, y: 1, z: 1}\n}\n\nexport function vec3Abs(v: rvec3): vec3\n{\n    return {\n        x: Math.abs(v.x),\n        y: Math.abs(v.y),\n        z: Math.abs(v.z),\n    }\n}\n\nexport function vec3Max(v: rvec3, s: number): vec3\n{\n    return {\n        x: Math.max(v.x, s),\n        y: Math.max(v.y, s),\n        z: Math.max(v.z, s),\n    }\n}\n\nexport function vec3Min(v: rvec3, s: number): vec3\n{\n    return {\n        x: Math.min(v.x, s),\n        y: Math.min(v.y, s),\n        z: Math.min(v.z, s),\n    }\n}", "export interface vec4\n{\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\nexport type rvec4 = Readonly<vec4>;\n\n/**\n * Clones this vector\n *\n * @param v the vector to clone\n * @returns a new vector\n */\nexport function vec4Clone(v: rvec4): vec4\n{\n    return {x: v.x, y: v.y, z: v.z, w: v.w};\n}\n\n/**\n * Copy the values from one vec4 to another\n * @param v the target vector\n * @param a the copy vector\n * @returns the target vector\n */\nexport function vec4Copy(v: vec4, a: rvec4)\n{\n    v.x = a.x;\n    v.y = a.y;\n    v.z = a.z;\n    v.w = a.w;\n    return v;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param v the target vector\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @param w W component\n * @returns the target vector\n */\nexport function vec4Set(v: vec4, x: number, y: number, z: number, w: number)\n{\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    v.w = w;\n    return v;\n}\n\n/**\n * Calculates the length vector v\n *\n * @params the source vector\n * @returns length of v\n */\nexport function vec4Length(v: rvec4)\n{\n    return Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2 + v.w ** 2);\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @params the source vector\n * @returns squared length of v\n */\nexport function vec4SquaredLength(v: rvec4)\n{\n    return v.x ** 2 + v.y ** 2 + v.z ** 2 + v.w ** 2;\n}\n\n/**\n * Adds vector other into vec\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec4AddTo(left: vec4, right: rvec4)\n{\n    left.x += right.x;\n    left.y += right.y;\n    left.z += right.z;\n    left.w += right.w;\n    return left;\n}\n\n/**\n * Adds two vectors into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Add(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n        w: left.w + right.w\n    }\n}\n\n/**\n * Subtracts vector other from vector vec\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function vec4SubFrom(left: vec4, right: rvec4)\n{\n    left.x -= right.x;\n    left.y -= right.y;\n    left.z -= right.z;\n    left.w -= right.w;\n    return left;\n}\n\n/**\n * Subtracts vector other from vector vec into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Sub(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n        w: left.w - right.w,\n    }\n}\n\n/**\n * Multiplies the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function vec4MulTo(left: vec4, right: rvec4)\n{\n    left.x *= right.x;\n    left.y *= right.y;\n    left.z *= right.z;\n    left.w *= right.w;\n    return left;\n}\n\n/**\n * Multiplies the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Mul(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x * right.x,\n        y: left.y * right.y,\n        z: left.z * right.z,\n        w: left.w * right.w,\n    }\n}\n\n/**\n * Divides the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4DivBy(vec: vec4, other: rvec4)\n{\n    vec.x /= other.x;\n    vec.y /= other.y;\n    vec.z /= other.z;\n    vec.w /= other.w;\n    return vec;\n}\n\n/**\n * Divides the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Div(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x / right.x,\n        y: left.y / right.y,\n        z: left.z / right.z,\n        w: left.w / right.w,\n    }\n}\n\n/**\n * Scales the target vector by a scalar number\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns the target vector\n */\nexport function vec4ScaleBy(v: vec4, scale: number)\n{\n    v.x *= scale;\n    v.y *= scale;\n    v.z *= scale;\n    v.w *= scale;\n    return v;\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec4Scale(v: rvec4, scale: number): vec4\n{\n    return {\n        x: v.x * scale,\n        y: v.y * scale,\n        z: v.z * scale,\n        w: v.w * scale\n    };\n}\n\n/**\n * Calculates the Euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns distance between left and right\n */\nexport function vec4Distance(left: rvec4, right: rvec4)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    const dw = left.w - right.w;\n    return Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2 + dw ** 2);\n}\n\n/**\n * Calculates the squared euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns squery distance between left and right\n */\nexport function vec4SquaredDistance(left: rvec4, right: rvec4)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    const dw = left.w - right.w;\n    return dx ** 2 + dy ** 2 + dz ** 2 + dw ** 2;\n}\n\n/**\n * Negates the components of vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec4Negate(v: vec4)\n{\n    v.x = -v.x;\n    v.y = -v.y;\n    v.z = -v.z;\n    v.w = -v.w;\n    return v;\n}\n\n/**\n * Negates the components of vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec4Negated(v: rvec4): vec4\n{\n    return {\n        x: -v.x,\n        y: -v.y,\n        z: -v.z,\n        w: -v.w\n    }\n}\n\n/**\n * Inverse of the components of a vector\n *\n * @params v the target vector\n * @returns the target vector\n */\nexport function vec4Inverse(v: vec4)\n{\n    v.x = 1.0 / v.x;\n    v.y = 1.0 / v.y;\n    v.z = 1.0 / v.z;\n    v.w = 1.0 / v.w;\n    return v;\n}\n\n/**\n * Returns the inverse of the components of a vector into a new vector\n *\n * @params v the target vector\n * @returns a new vector\n */\nexport function vec4Inversed(v: rvec4): vec4\n{\n    return {\n        x: 1.0 / v.x,\n        y: 1.0 / v.y,\n        z: 1.0 / v.z,\n        w: 1.0 / v.w\n    };\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec4Normalize(v: vec4)\n{\n    let sqrtLen = vec4SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x *= sqrtLen;\n    v.y *= sqrtLen;\n    v.z *= sqrtLen;\n    v.w *= sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec4Normalized(v: rvec4): vec4\n{\n    let sqrtLen = vec4SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen,\n        w: v.w * sqrtLen\n    }\n}\n\n/**\n * Calculates the dot product of two vec4's\n * @param left the left vector\n * @param right the right vector\n * @returns dot product of left and right\n */\nexport function vec4Dot(left: rvec4, right: rvec4)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n}\n\n\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param v1 the first vector\n * @param v2 the second vector\n * @param v3 the third vector\n * @returns a new vector\n */\nexport function vec4Cross(v1: rvec4, v2: rvec4, v3: rvec4): vec4\n{\n    const A = v2.x * v3.y - v2.y * v3.x,\n      B = v2.x * v3.z - v2.z * v3.x,\n      C = v2.x * v3.w - v2.w * v3.x,\n      D = v2.y * v3.z - v2.z * v3.y,\n      E = v2.y * v3.w - v2.w * v3.y,\n      F = v2.z * v3.w - v2.w * v3.z;\n    const G = v1.x;\n    const H = v1.y;\n    const I = v1.z;\n    const J = v1.w;\n\n    return {\n      x: H * F - I * E + J * D,\n      y: -(G * F) + I * C - J * B,\n      z: G * E - H * C + J * A,\n      w: -(G * D) + H * B - I * A\n    };\n}\n\n/**\n * Performs a linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs (not clamped)\n * @returns a new vector\n */\nexport function vec4Lerp(left: rvec4, right: rvec4, t: number): vec4\n{\n    return {\n        x: left.x + t * (right.x - left.x),\n        y: left.y + t * (right.y - left.y),\n        z: left.z + t * (right.z - left.z),\n        w: left.w + t * (right.w - left.w)\n    };\n}\n\n\n  /**\n   * Transforms the vec4 with a mat4.\n   * @param {mat4} matrix matrix to transform with\n   * @returns {vec4} out\n   */\n  /*\n  transformMat4(matrix: mat4) {\n    const { data: out, data: a } = this;\n    const m = matrix.data;\n    let x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return this;\n  }\n    */\n\n  /**\n   * Transforms the vec4 with a quat\n   * @param {ReadonlyQuat} rotation quaternion to transform with\n   * @returns {vec4} out\n   */\n  /*\n  transformQuat(rotation: quat) {\n    const { data: out, data: a } = this;\n    const q = rotation.data;\n    let x = a[0],\n      y = a[1],\n      z = a[2];\n    let qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n\n    // calculate quat * vec\n    let ix = qw * x + qy * z - qz * y;\n    let iy = qw * y + qz * x - qx * z;\n    let iz = qw * z + qx * y - qy * x;\n    let iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    out[3] = a[3];\n    return this;\n  }*/\n\n/**\n * Creates a zero vector\n */\nexport function vec4Zero(): vec4\n{\n    return {x: 0, y: 0, z: 0, w: 0}\n}\n\nexport function vec4One(): vec4\n{\n    return {x: 1, y: 1, z: 1, w: 1}\n}", "import mathf, { AngleOrder } from \"./mathf\";\nimport { rvec3, vec3, vec3Cross, vec3CrossBy, vec3Dot, vec3Normalize, vec3SquaredLength } from \"./vec3\";\n\nexport interface quat\n{\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\nexport type rquat = Readonly<quat>;\n\nexport function quatIdentity(): quat\n{\n    return {x: 0, y: 0, z: 0, w: 1}\n}\n\n/**\n * Clones this quat\n *\n * @param v the quat to clone\n * @returns a new quat\n */\nexport function quatClone(v: rquat): quat\n{\n    return {x: v.x, y: v.y, z: v.z, w: v.w};\n}\n\n/**\n * Calculates the length quat q\n *\n * @params the source quat\n * @returns length of q\n */\nexport function quatLength(q: rquat)\n{\n    return Math.sqrt(q.x ** 2 + q.y ** 2 + q.z ** 2 + q.w ** 2);\n}\n\n/**\n * Calculates the squared length of a quat\n *\n * @params the source quat\n * @returns squared length of q\n */\nexport function quatSquaredLength(q: rquat)\n{\n    return q.x ** 2 + q.y ** 2 + q.z ** 2 + q.w ** 2;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis, then returns it.\n * @param q the target quat\n * @param axis the axis around which to rotate\n * @param rad the angle in radians\n * @returns the target quat\n */\nexport function quatSetAxisAngle(q: quat, axis: rvec3, rad: number)\n{\n    rad = rad * 0.5;\n    const s = Math.sin(rad);\n\n    q.x = s * axis.x;\n    q.y = s * axis.y;\n    q.z = s * axis.z;\n    q.w = Math.cos(rad);\n    return q\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as provided in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param out Vector receiving the axis of rotation\n * @param q Quaternion to be decomposed\n * @return Angle, in radians, of the rotation\n */\nexport function quatGetAxisAngle(out: vec3, q: rquat)\n{\n    const rad = Math.acos(q.w) * 2.0;\n    const s = Math.sin(rad / 2.0);\n\n    if (s > mathf.EPSILON)\n    {\n      out.x = q.x / s;\n      out.y = q.y / s;\n      out.z = q.z / s;\n    }\n    else\n    {\n      // If s is zero, return any axis (no rotation - axis does not matter)\n      out.x = 1;\n      out.y = 0;\n      out.z = 0;\n    }\n    return rad;\n}\n\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param left the left quat\n * @param right the right quat\n * @return Angle, in radians, between the two quaternions\n */\nexport function quatGetAngle(left: rquat, right: rquat)\n{\n    const dot = quatDot(left, right);\n    return Math.acos(2 * dot * dot - 1);\n}\n\n/**\n * Calculates the dot product of two quat's\n * @param left the left quat\n * @param right the right quat\n * @returns dot product of left and right\n */\nexport function quatDot(left: rquat, right: rquat)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n}\n\n  /**\n * Set the components of a quat to the given values\n *\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @param w W component\n * @returns the target quat\n */\nexport function quatSet(q: quat, x: number, y: number, z: number, w: number)\n{\n    q.x = x;\n    q.y = y;\n    q.z = z;\n    q.w = w;\n    return q;\n}\n\n/**\n * Multiplies the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function quatMulTo(left: quat, right: rquat)\n{\n    const ax = left.x,\n      ay = left.y,\n      az = left.z,\n      aw = left.w;\n    const bx = right.x,\n      by = right.y,\n      bz = right.z,\n      bw = right.w;\n\n    left.x = ax * bw + aw * bx + ay * bz - az * by;\n    left.y = ay * bw + aw * by + az * bx - ax * bz;\n    left.z = az * bw + aw * bz + ax * by - ay * bx;\n    left.w = aw * bw - ax * bx - ay * by - az * bz;\n\n    return left;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function quatRotateX(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const bx = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw + aw * bx;\n    q.y = ay * bw + az * bx;\n    q.z = az * bw - ay * bx;\n    q.w = aw * bw - ax * bx;\n    return q;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function quatRotateY(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const by = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw - az * by;\n    q.y = ay * bw + aw * by;\n    q.z = az * bw + ax * by;\n    q.w = aw * bw - ay * by;\n    return q;\n}\n\n  /**\n   * Rotates a quaternion by the given angle about the Z axis\n   *\n   * @param {quat} out quat receiving operation result\n   * @param {quat} a quat to rotate\n   * @param {number} rad angle (in radians) to rotate\n   * @returns {quat} out\n   */\nexport function quatRotateZ(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const bz = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw + ay * bz;\n    q.y = ay * bw - ax * bz;\n    q.z = az * bw + aw * bz;\n    q.w = aw * bw - az * bz;\n    return q;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @returns a new quat\n */\nexport function quatCalculateW(q: rquat): quat\n{\n    return {\n      x: q.x,\n      y: q.y,\n      z: q.z,\n      w: Math.sqrt(Math.abs(1.0 - q.x * q.x - q.y * q.y - q.z * q.z))\n    };\n}\n\n/**\n * Adds vector other into vec\n * @param left the left quat\n * @param right the right quat\n * @returns the target quat\n */\nexport function quatAddTo(left: quat, right: rquat)\n{\n    left.x += right.x;\n    left.y += right.y;\n    left.z += right.z;\n    left.w += right.w;\n    return left;\n}\n\n/**\n * Adds two vectors into a new quat\n * @param left the left quat\n * @param right the right quat\n * @returns a new quat\n */\nexport function quatAdd(left: rquat, right: rquat): quat\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n        w: left.w + right.w\n    }\n}\n\n/**\n * Subtracts quat other from quat vec\n * @param left the left quat\n * @param right the right quat\n * @returns the left quat\n */\nexport function quatSubFrom(left: quat, right: rquat)\n{\n    left.x -= right.x;\n    left.y -= right.y;\n    left.z -= right.z;\n    left.w -= right.w;\n    return left;\n}\n\n/**\n * Subtracts quat other from quat vec into a new quat\n * @param left the left quat\n * @param right the right quat\n * @returns a new quat\n */\nexport function quatSub(left: rquat, right: rquat): quat\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n        w: left.w - right.w,\n    }\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n * @param {quat} q the second operand\n * @param {number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function quatSlerp(left: rquat, right: rquat, t: number): quat\n{\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n    const ax = left.x,\n      ay = left.y,\n      az = left.z,\n      aw = left.w;\n    let bx = right.x,\n      by = right.y,\n      bz = right.z,\n      bw = right.w;\n\n    let omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    }\n\n    // calculate coefficients\n    if (1.0 - cosom > mathf.EPSILON)\n    {\n      // standard case (slerp)\n      omega = Math.acos(cosom);\n      sinom = Math.sin(omega);\n      scale0 = Math.sin((1.0 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    }\n    else\n    {\n      // \"from\" and \"to\" quaternions are very close\n      //  ... so we can do a linear interpolation\n      scale0 = 1.0 - t;\n      scale1 = t;\n    }\n    // calculate final values\n    return {\n      x: scale0 * ax + scale1 * bx,\n      y: scale0 * ay + scale1 * by,\n      z: scale0 * az + scale1 * bz,\n      w: scale0 * aw + scale1 * bw\n    };\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @returns {quat} out\n */\nexport function quatInvert(q: quat)\n{\n    const a0 = q.x,\n      a1 = q.y,\n      a2 = q.z,\n      a3 = q.w;\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1.0 / dot : 0;\n\n    q.x = -a0 * invDot;\n    q.y = -a1 * invDot;\n    q.z = -a2 * invDot;\n    q.w = a3 * invDot;\n    return q;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @returns {quat} out\n */\nexport function quatInverted(q: rquat): quat\n{\n    const a0 = q.x,\n      a1 = q.y,\n      a2 = q.z,\n      a3 = q.w;\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1.0 / dot : 0;\n\n    return {\n      x: -a0 * invDot,\n      y: -a1 * invDot,\n      z: -a2 * invDot,\n      w: a3 * invDot\n    };\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n * @returns {quat} out\n */\nexport function quatConjugate(q: quat)\n{\n    q.x = -q.x;\n    q.y = -q.y;\n    q.z = -q.z;\n    q.w = q.w;\n    return q;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n * @returns {quat} out\n */\nexport function quatConjugated(q: rquat): quat\n{\n    return {\n        x: -q.x,\n        y: -q.y,\n        z: -q.z,\n        w: -q.w\n    }\n}\n\n  /**\n   * Creates a quaternion from the given 3x3 rotation matrix.\n   *\n   * NOTE: The resultant quaternion is not normalized, so you should be sure\n   * to renormalize the quaternion yourself where necessary.\n   * @param {mat3} matrix rotation matrix\n   * @returns {quat} out\n   * @function\n   */\n  /*\n  fromMat3(matrix: mat3) {\n    const data=this.data\n    const m=matrix.data;\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    let fTrace = m[0] + m[4] + m[8];\n    let fRoot;\n\n    if (fTrace > 0.0) {\n      // |w| > 1/2, may as well choose w > 1/2\n      fRoot = Math.sqrt(fTrace + 1.0); // 2w\n      data[3] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot; // 1/(4w)\n      data[0] = (m[5] - m[7]) * fRoot;\n      data[1] = (m[6] - m[2]) * fRoot;\n      data[2] = (m[1] - m[3]) * fRoot;\n    } else {\n      // |w| <= 1/2\n      let i = 0;\n      if (m[4] > m[0]) i = 1;\n      if (m[8] > m[i * 3 + i]) i = 2;\n      let j = (i + 1) % 3;\n      let k = (i + 2) % 3;\n\n      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n      data[i] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot;\n      data[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n      data[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n      data[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n    return this;\n  }\n    */\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @params q the target quat\n * @param x Angle to rotate around X axis in degrees.\n * @param y Angle to rotate around Y axis in degrees.\n * @param z Angle to rotate around Z axis in degrees.\n * @param order Intrinsic order for conversion, default is zyx.\n * @returns the target quat\n */\nexport function quatFromEuler(q: quat, x: number, y: number, z: number, order: AngleOrder = mathf.ANGLE_ORDER)\n{\n    const halfToRad = Math.PI / 360;\n    x *= halfToRad;\n    z *= halfToRad;\n    y *= halfToRad;\n\n    const sx = Math.sin(x);\n    const cx = Math.cos(x);\n    const sy = Math.sin(y);\n    const cy = Math.cos(y);\n    const sz = Math.sin(z);\n    const cz = Math.cos(z);\n\n    switch (order) {\n      case \"xyz\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"xzy\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      case \"yxz\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      case \"yzx\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"zxy\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"zyx\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      default:\n        throw new Error('Unknown angle order ' + order);\n    }\n\n    return this;\n}\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nexport function quatRotationTo(q: quat, a: rvec3, right: rvec3)\n{\n    const dot = vec3Dot(a, right);\n    if (dot < -0.999999)\n    {\n        const xUnit = {x: 1, y: 0, z: 0};\n        let tmpVec3 = vec3CrossBy(xUnit, xUnit, a);\n        if (vec3SquaredLength(tmpVec3) < mathf.EPSILON)\n        {\n            const yUnit = {x: 0, y: 1, z : 0};\n            tmpVec3 = vec3CrossBy(yUnit, yUnit, a);\n        }\n\n        vec3Normalize(tmpVec3, tmpVec3);\n\n        quatSetAxisAngle(q, tmpVec3, Math.PI);\n        return q;\n    }\n    else if (dot > 0.999999)\n    {\n        q.x = 0;\n        q.y = 0;\n        q.z = 0;\n        q.w = 1;\n        return this;\n    }\n    else\n    {\n        const tmpVec3 = vec3Cross(a, right);\n        q.x = tmpVec3.x;\n        q.y = tmpVec3.y;\n        q.z = tmpVec3.z;\n        q.w = 1 + dot;\n        return quatNormalize(q);\n    }\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function quatNormalize(v: quat)\n{\n    let sqrtLen = quatSquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x *= sqrtLen;\n    v.y *= sqrtLen;\n    v.z *= sqrtLen;\n    v.w *= sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function quatNormalized(v: rquat): quat\n{\n    let sqrtLen = quatSquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen,\n        w: v.w * sqrtLen\n    }\n}\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} b the second operand\n * @param {quat} c the third operand\n * @param {quat} d the fourth operand\n * @param {number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function quatSQlerp(a: rquat, b: rquat, c: rquat, d: rquat, t: number)\n{\n    const temp1 = quatSlerp(a, d, t);\n    const temp2 = quatSlerp(b, c, t);\n    return quatSlerp(temp1, temp2, 2 * t * (1 - t));\n};\n\n  /**\n   * Sets the specified quaternion with values corresponding to the given\n   * axes. Each axis is a vec3 and is expected to be unit length and\n   * perpendicular to all other specified axes.\n   *\n   * @param {vec3} view  the vector representing the viewing direction\n   * @param {vec3} right the vector representing the local \"right\" direction\n   * @param {vec3} up    the vector representing the local \"up\" direction\n   * @returns {quat} out\n   */\n//   export function quatSetAxes(view: vec3, right: vec3, up: vec3) {\n//     let _matrix = new mat3();\n//     const { data: matr } = _matrix;\n//     const { data: r } = right;\n//     const { data: v } = view;\n//     const { data: u } = up;\n//     matr[0] = r[0];\n//     matr[3] = r[1];\n//     matr[6] = r[2];\n\n//     matr[1] = u[0];\n//     matr[4] = u[1];\n//     matr[7] = u[2];\n\n//     matr[2] = -v[0];\n//     matr[5] = -v[1];\n//     matr[8] = -v[2];\n//     return this.fromMat3(_matrix).normalize();\n//   }", "import { Opaque } from \"./common\";\nimport { quat, quatIdentity, vec3, vec3Zero, vec4, vec4One } from \"./gl-matrix-ts\";\n\ninterface Light\n{\n    position: vec3;\n    radius: number;\n    colour: vec4;\n}\nexport const lightDataSize = 3 + 1 + 4;\n\nexport interface Camera\n{\n    position: vec3;\n    rotation: quat;\n    fieldOfView: number;\n}\n\nexport type SdfOpCode = 'none' | 'union' | 'intersection' | 'subtraction' | 'xor';\nexport type SdfOpCodeInt = Opaque<number, \"sdfOpCode\">;\nexport const SdfOpCodeNone = -5e2 as SdfOpCodeInt;\nexport const SdfOpCodeUnion = -6e2 as SdfOpCodeInt;\nexport const SdfOpCodeIntersection = -7e2 as SdfOpCodeInt;\nexport const SdfOpCodeSubtraction = -8e2 as SdfOpCodeInt;\nexport const SdfOpCodeXor = -9e2 as SdfOpCodeInt;\n\nexport type ShapeType = 'none' | 'box' | 'sphere' | 'hexPrism';\nexport type ShapeTypeInt = Opaque<number, \"shapeType\">;\nexport const ShapeTypeNone = -5e3 as ShapeTypeInt;\nexport const ShapeTypeBox = -6e3 as ShapeTypeInt;\nexport const ShapeTypeSphere = -7e3 as ShapeTypeInt;\nexport const ShapeTypeHexPrism = -8e3 as ShapeTypeInt;\ninterface Shape\n{\n    position: vec3;\n    rotation: quat;\n    maxSize: number;\n    type: ShapeType;\n    shapeParams: vec3;\n    diffuseColour: vec4;\n    specularColour: vec4;\n}\n\nconst SdfOpCodeMap: { readonly [key: string]: SdfOpCodeInt } =\n{\n    'none': SdfOpCodeNone,\n    'union': SdfOpCodeUnion,\n    'intersection': SdfOpCodeIntersection,\n    'subtraction': SdfOpCodeSubtraction,\n    'xor': SdfOpCodeXor,\n}\nconst ShapeTypeMap: { readonly [key: string]: ShapeTypeInt } =\n{\n    'none': ShapeTypeNone,\n    'box': ShapeTypeBox,\n    'sphere': ShapeTypeSphere,\n    'hexPrism': ShapeTypeHexPrism,\n}\n\nfunction toShapeTypeInt(type: ShapeType): ShapeTypeInt\n{\n    return ShapeTypeMap[type] || ShapeTypeNone;\n}\nfunction toOpCodeInt(type: SdfOpCode): SdfOpCodeInt\n{\n    return SdfOpCodeMap[type] || SdfOpCodeNone;\n}\n\nexport const shapeDataSize = 4 + 4 + 4 + 4;\n\nexport type ShapeOperation = number | SdfOpCode;\n\nexport class SdfScene\n{\n    private lights: Light[] = [];\n    private lightDataArray: number[] = [];\n\n    private shapes: Shape[] = [];\n    private shapeDataArray: number[] = [];\n\n    private operations: ShapeOperation[] = [];\n    private numberOperations: number[] = [];\n\n    public getLightDataArray()\n    {\n        return this.lightDataArray;\n    }\n\n    public getLights()\n    {\n        return this.lights;\n    }\n\n    public getNumLights()\n    {\n        return this.lights.length;\n    }\n\n    public getShapeDataArray()\n    {\n        return this.shapeDataArray;\n    }\n\n    public getShapes()\n    {\n        return this.shapes;\n    }\n\n    public getNumTotalShapes()\n    {\n        return this.shapes.length;\n    }\n\n    public setOperations(operations: ShapeOperation[])\n    {\n        this.operations = operations;\n        this.updateOperationNumbers();\n    }\n\n    public getOperations()\n    {\n        return this.operations;\n    }\n\n    public getOperationNumbers()\n    {\n        return this.numberOperations;\n    }\n\n    public setLight(index: number, light: Partial<Light>)\n    {\n        if (index < 0)\n        {\n            throw new Error(`Out of bounds light index ${index}`);\n        }\n\n        if (index >= this.lights.length)\n        {\n            this.lights[index] = { ...this.createNewLight(), ...light };\n        }\n        else\n        {\n            this.lights[index] = { ...this.lights[index], ...light };\n        }\n\n        this.updateLight(index);\n    }\n\n    public setShape(index: number, shape: Partial<Shape>)\n    {\n        if (index < 0)\n        {\n            throw new Error(`Out of bounds shape index ${index}`);\n        }\n\n        if (index >= this.shapes.length)\n        {\n            this.shapes[index] = { ...this.createNewShape(), ...shape };\n        }\n        else\n        {\n            this.shapes[index] = { ...this.shapes[index], ...shape };\n        }\n\n        this.updateShape(index);\n    }\n\n    private updateLight(index: number)\n    {\n        const dataIndex = index * lightDataSize;\n        const light = this.lights[index];\n\n        this.lightDataArray[dataIndex    ] = light.position.x;\n        this.lightDataArray[dataIndex + 1] = light.position.y;\n        this.lightDataArray[dataIndex + 2] = light.position.z;\n        this.lightDataArray[dataIndex + 3] = light.radius;\n        this.lightDataArray[dataIndex + 4] = light.colour.x;\n        this.lightDataArray[dataIndex + 5] = light.colour.y;\n        this.lightDataArray[dataIndex + 6] = light.colour.z;\n        this.lightDataArray[dataIndex + 7] = light.colour.w;\n    }\n\n    private updateShape(index: number)\n    {\n        const dataIndex = index * shapeDataSize;\n        const shape = this.shapes[index];\n\n        this.shapeDataArray[dataIndex     ] = shape.position.x;\n        this.shapeDataArray[dataIndex +  1] = shape.position.y;\n        this.shapeDataArray[dataIndex +  2] = shape.position.z;\n        this.shapeDataArray[dataIndex +  3] = shape.maxSize;\n\n        this.shapeDataArray[dataIndex +  4] = shape.rotation.x;\n        this.shapeDataArray[dataIndex +  5] = shape.rotation.y;\n        this.shapeDataArray[dataIndex +  6] = shape.rotation.z;\n        this.shapeDataArray[dataIndex +  7] = shape.rotation.w;\n\n        this.shapeDataArray[dataIndex +  8] = toShapeTypeInt(shape.type);\n        this.shapeDataArray[dataIndex +  9] = shape.shapeParams.x;\n        this.shapeDataArray[dataIndex + 10] = shape.shapeParams.y;\n        this.shapeDataArray[dataIndex + 11] = shape.shapeParams.z;\n\n        this.shapeDataArray[dataIndex + 12] = shape.diffuseColour.x;\n        this.shapeDataArray[dataIndex + 13] = shape.diffuseColour.y;\n        this.shapeDataArray[dataIndex + 14] = shape.diffuseColour.z;\n        this.shapeDataArray[dataIndex + 15] = shape.diffuseColour.w;\n\n        // this.shapeDataArray[dataIndex + 16] = shape.specularColour.x;\n        // this.shapeDataArray[dataIndex + 17] = shape.specularColour.y;\n        // this.shapeDataArray[dataIndex + 18] = shape.specularColour.z;\n        // this.shapeDataArray[dataIndex + 19] = shape.specularColour.w;\n    }\n\n    private updateOperationNumbers()\n    {\n        this.numberOperations = this.operations.map(i =>\n        {\n            if (typeof(i) === 'string')\n            {\n                return toOpCodeInt(i);\n            }\n            return i;\n        });\n    }\n\n    private createNewLight(): Light\n    {\n        return {\n            position: vec3Zero(),\n            radius: 10,\n            colour: vec4One()\n        }\n    }\n\n    private createNewShape(): Shape\n    {\n        return {\n            position: vec3Zero(),\n            rotation: quatIdentity(),\n            maxSize: 0,\n            type: \"none\",\n            shapeParams: vec3Zero(),\n            diffuseColour: {x: 0.7, y: 0.3, z: 0.2, w: 1.0},\n            specularColour: {x: 1.0, y: 0.8, z: 0.9, w: 1.0}\n        }\n    }\n}", "#version 300 es\n\nin vec2 aPosition;\nout vec2 oPosition;\n\nuniform float uAspectRatio;\n\nvoid main()\n{\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n    oPosition = aPosition * vec2(uAspectRatio, 1.0);\n}", "#version 300 es\n\nprecision lowp float;\n\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\n\nconst int ShapeTypeNone = -5000;\nconst int ShapeTypeBox = -6000;\nconst int ShapeTypeSphere = -7000;\nconst int ShapeTypeHexPrism = -8000;\n\nconst int SdfOpCodeNone = -500;\nconst int SdfOpCodeUnion = -600;\nconst int SdfOpCodeIntersection = -700;\nconst int SdfOpCodeSubtraction = -800;\n\nlayout(location = 0) out vec4 color;\n\nin vec2 oPosition;\n\nuniform mat2x4 uLights[8];\nuniform int uNumLights;\nuniform mat3 uCameraMatrix;\nuniform vec3 uCameraPosition;\n\nuniform mat4 uShapes[128];\nuniform int uOperations[128];\nuniform int uNumOperations;\nuniform int uMaxMarchingSteps;\nuniform float uEpsilon;\n\nuniform bvec4 uFlags;\n\nfloat sdfSphere(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat sdfHexPrism(vec3 point, vec2 params)\n{\n    vec3 absPoint = abs(point);\n    float d1 = absPoint.z - params.y;\n    float d2 = max((absPoint.x * 0.866025 + absPoint.y * 0.5), absPoint.y) - params.x;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat sdfBox(vec3 point, vec3 size)\n{\n    vec3 d = abs(point) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0)   // inside distance\n        + length(max(d, 0.0));              // outside distance\n}\n\nfloat opUnion(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\nfloat applyOpCode(int opCode, float dist1, float dist2)\n{\n    switch (opCode)\n    {\n        case SdfOpCodeUnion: return opUnion(dist1, dist2);\n        case SdfOpCodeIntersection: return opIntersection(dist1, dist2);\n        case SdfOpCodeSubtraction: return opSubtraction(dist1, dist2);\n    }\n\n    return 100.0;\n}\n\nfloat getDistToType(int type, vec3 point, vec3 params)\n{\n    switch (type)\n    {\n        case ShapeTypeBox: return sdfBox(point, params);\n        case ShapeTypeSphere: return sdfSphere(point, params.x);\n        case ShapeTypeHexPrism: return sdfHexPrism(point, params.xy);\n    }\n\n    return 100.0;\n}\n\nfloat getDistanceToShape(int index, vec3 samplePoint)\n{\n    mat4 shape = uShapes[index];\n\n    vec3 point = shape[0].xyz;\n    vec3 testPoint = point - samplePoint;\n    // return sphereSDF(samplePoint);\n\n    // quat rotation = shape[1];\n\n    int type = int(round(shape[2].x));\n    vec3 params = shape[2].yzw;\n\n    return getDistToType(type, testPoint, params);\n}\n\nfloat sceneSDF(vec3 point)\n{\n    int depthStackIndex = -1;\n    float depthStack[32];\n\n    for (int operationsIndex = 0; operationsIndex < uNumOperations; operationsIndex++)\n    {\n        int operation = uOperations[operationsIndex];\n\n        if (operation <= SdfOpCodeNone)\n        {\n            float lastD2 = depthStack[depthStackIndex--];\n            float lastD1 = depthStack[depthStackIndex--];\n            float dist = applyOpCode(operation, lastD2, lastD1);\n            depthStack[++depthStackIndex] = dist;\n        }\n        else\n        {\n            float dist = getDistanceToShape(operation, point);\n            depthStack[++depthStackIndex] = dist;\n        }\n    }\n\n    return depthStack[0];\n}\n\nvec3 createRayDirection(float fieldOfView, vec2 fragCoord)\n{\n    vec2 xy = fragCoord / 2.0;\n    float z = 2.0 / tan(radians(fieldOfView));\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 point, float currentDepth)\n{\n    vec2 eps_zero = vec2(currentDepth * 0.0015, 0.0);\n    return normalize(vec3(\n        sceneSDF(point + eps_zero.xyy) - sceneSDF(point - eps_zero.xyy),\n        sceneSDF(point + eps_zero.yxy) - sceneSDF(point - eps_zero.yxy),\n        sceneSDF(point + eps_zero.yyx) - sceneSDF(point - eps_zero.yyx)\n    ));\n}\n\n// https://github.com/electricsquare/raymarching-workshop?tab=readme-ov-file#diffuse-term\nvec3 estimateNormalLambert(vec3 point, vec3 currentDepth)\n{\n    // Use offset samples to compute gradient / normal\n    // float d = sceneSDF(point);\n    float d = currentDepth.y;\n    vec2 eps_zero = vec2(currentDepth.x * 0.0015, 0.0);\n    return normalize(vec3(\n        sceneSDF(point + eps_zero.xyy) - d,\n        sceneSDF(point + eps_zero.yxy) - d,\n        sceneSDF(point + eps_zero.yyx) - d));\n}\n\nconst float shadowSharpness = 32.0;\nvec2 softShadow(vec3 rayOrigin, vec3 rayDirection, float near, float far)\n{\n    float depth = near;\n    float result = 1.0;\n    int i = 0;\n\n    for (; i < uMaxMarchingSteps; i++)\n    {\n        float dist = sceneSDF(rayOrigin + depth * rayDirection);\n        if (dist < uEpsilon)\n        {\n            return vec2(0.0, float(i));\n        }\n\n        result = min(result, shadowSharpness * dist / depth);\n        depth += dist;\n        if (depth >= far)\n        {\n            return vec2(result, float(i));\n        }\n    }\n\n    return vec2(result, float(i));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n *\n * The vec3 returned is the RGB color of the light's contribution.\n *\n * diffuse: Diffuse color\n * specular: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 currentDepth, vec3 diffuse, vec3 specular, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormalLambert(p, currentDepth);\n\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (diffuse * dotLN);\n    }\n    return lightIntensity * (diffuse * dotLN + specular * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n *\n * The vec3 returned is the RGB color of that point after lighting is applied.\n * diffuse: Diffuse color\n * specular: Specular color\n * alpha: Shininess coefficient\n * worldPoint: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nconst vec3 ambientLight = 0.5 * 0.2 * vec3(1.0, 1.0, 1.0);\nvec4 phongIllumination(vec3 currentDepth, vec3 diffuse, vec3 specular, float shininess, vec3 worldPoint, vec3 cameraPoint)\n{\n    vec3 colour = ambientLight;\n    float light0Rays;\n\n    for (int i = 0; i < uNumLights; i++)\n    {\n        mat2x4 light = uLights[i];\n        vec3 lightPos = light[0].xyz;\n\n        vec2 shadow = vec2(1.0, 0.0);\n        if (uFlags.x)\n        {\n            vec3 toLight = normalize(lightPos - worldPoint);\n            shadow = softShadow(worldPoint, toLight, 0.1, 100.0);\n\n            if (i == 1)\n            {\n                light0Rays = shadow.y;\n            }\n        }\n\n        vec3 lightContrib = phongContribForLight(currentDepth, diffuse, specular, shininess, worldPoint, cameraPoint, lightPos, light[1].xyz);\n        colour += lightContrib * shadow.x;\n    }\n\n    // colour = pow(colour, vec3(1.0 / 2.2)); // Gamma correction\n    return vec4(colour, light0Rays);\n}\n\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDirection, float near, float far)\n{\n    float depth = near;\n    for (int i = 0; i < uMaxMarchingSteps; i++)\n    {\n        float dist = sceneSDF(rayOrigin + depth * rayDirection);\n        if (dist < uEpsilon)\n        {\n            return vec3(depth, dist, float(i));\n        }\n\n        depth += dist;\n        if (depth >= far)\n        {\n            return vec3(far, dist, float(i));\n        }\n    }\n\n    return vec3(far, far, float(uMaxMarchingSteps));\n}\n\nvoid main()\n{\n    vec3 rayDir = uCameraMatrix * createRayDirection(45.0, oPosition);\n    vec3 rayOrigin = uCameraPosition;\n\n    vec3 dist = rayMarch(rayOrigin, rayDir, MIN_DIST, MAX_DIST);\n    vec4 litColour;\n\n    if (dist.x > MAX_DIST - uEpsilon)\n    {\n        if (uFlags.y)\n        {\n            float r = dist.z / float(uMaxMarchingSteps);\n            color = vec4(r, 0, 0, 1);\n            return;\n        }\n\n        color = vec4(0, 0, 0, 0);\n    }\n    else\n    {\n        // The closest point on the surface to the eyepoint along the view ray\n        vec3 worldPoint = rayOrigin + dist.x * rayDir;\n\n        vec3 diffuse = vec3(0.7, 0.2, 0.2);\n        vec3 specular = vec3(1.0, 1.0, 1.0);\n        float shininess = 10.0;\n\n        litColour = phongIllumination(dist, diffuse, specular, shininess, worldPoint, rayOrigin);\n\n        color = vec4(litColour.xyz, 1.0);\n    }\n\n    if (uFlags.y)\n    {\n        float r = dist.z / float(uMaxMarchingSteps);\n        float g = litColour.w / float(uMaxMarchingSteps);\n        color = vec4(r, g, 0, 1);\n    }\n}", "export default class Shader\n{\n    public readonly program: WebGLProgram;\n\n    constructor(program: WebGLProgram)\n    {\n        this.program = program;\n    }\n\n    public static create(gl: WebGL2RenderingContext, vertText: string, fragText: string): Shader\n    {\n        function cleanup()\n        {\n            if (program != null)\n            {\n                gl.detachShader(program, vert);\n                gl.detachShader(program, frag);\n            }\n\n            if (vert != null)\n            {\n                gl.deleteShader(vert);\n            }\n\n            if (frag != null)\n            {\n                gl.deleteShader(frag);\n            }\n        }\n\n        const vert = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vert, vertText);\n        gl.compileShader(vert);\n\n        if (!gl.getShaderParameter(vert, gl.COMPILE_STATUS))\n        {\n            const error = gl.getShaderInfoLog(vert);\n            console.error('Vertex shader compile error', error);\n\n            cleanup();\n            throw new Error(`Vertex shader compile error ${error}`);\n        }\n\n        const frag = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(frag, fragText);\n        gl.compileShader(frag);\n        if (!gl.getShaderParameter(frag, gl.COMPILE_STATUS))\n        {\n            const error = gl.getShaderInfoLog(frag);\n            console.error('Fragment shader compile error', error);\n\n            cleanup();\n            throw new Error(`Fragment shader compile error ${error}`);\n        }\n\n        const program = gl.createProgram();\n        gl.attachShader(program, vert);\n        gl.attachShader(program, frag);\n        gl.linkProgram(program);\n\n        cleanup();\n\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n        {\n            gl.useProgram(null);\n            gl.deleteProgram(program);\n\n            const error = gl.getProgramInfoLog(program);\n            console.error('Shader link error', error);\n\n            throw new Error(`Shader link error ${error}`);\n        }\n\n        return new Shader(program);\n    }\n}", "// @ts-ignore These are handled by esbuild\nimport vertText from \"./vert.glsl\";\n// @ts-ignore\nimport fragText from \"./frag.glsl\";\nimport Shader from \"./shader\";\nimport { SdfScene } from \"./sdf-scene\";\nimport { quatFromEuler, quatIdentity, rquat, vec3, vec3ScaleAndAddBy, vec3TransformQuat, vec3Zero } from \"./gl-matrix-ts\";\n\nconst positions = [\n    -1, -1,\n    1, -1,\n    1, 1,\n\n    -1, -1,\n    1, 1,\n    -1, 1\n];\n\nconst tempAxisQuat = quatIdentity();\nfunction mat3ArraySetFromQuat(m: Float32Array, q: rquat)\n{\n    const x2 = q.x + q.x;\n    const y2 = q.y + q.y;\n    const z2 = q.z + q.z;\n\n    const xx = q.x * x2;\n    const yx = q.y * x2;\n    const yy = q.y * y2;\n    const zx = q.z * x2;\n    const zy = q.z * y2;\n    const zz = q.z * z2;\n    const wx = q.w * x2;\n    const wy = q.w * y2;\n    const wz = q.w * z2;\n\n    m[0] = 1 - yy - zz;\n    m[1] = yx - wz;\n    m[2] = zx + wy;\n\n    m[3] = yx + wz;\n    m[4] = 1 - xx - zz;\n    m[5] = zy - wx;\n\n    m[6] = zx - wy;\n    m[7] = zy + wx;\n    m[8] = 1 - xx - yy;\n\n    return m;\n}\n\n\nexport default class WebGLSdfRenderer\n{\n    public readonly gl: WebGL2RenderingContext;\n    public readonly shader:Shader;\n    public readonly positionBuffer: WebGLBuffer;\n\n    public readonly uShapes: WebGLUniformLocation;\n    public readonly uOperations: WebGLUniformLocation;\n    public readonly uNumOperations: WebGLUniformLocation;\n\n    public readonly uLights: WebGLUniformLocation;\n    public readonly uNumLights: WebGLUniformLocation;\n\n    public readonly uCameraPosition: WebGLUniformLocation;\n    public readonly uCameraMatrix: WebGLUniformLocation;\n\n    public readonly uAspectRatio: WebGLUniformLocation;\n\n    public readonly uMaxMarchingSteps: WebGLUniformLocation;\n    public readonly uEpsilon: WebGLUniformLocation;\n    public readonly uFlags: WebGLUniformLocation;\n\n    public cameraPosition: vec3 = vec3Zero();\n    public cameraTarget: vec3 = vec3Zero();\n    public cameraRotationX = 0;\n    public cameraRotationY = 0;\n    public cameraDistance = 10;\n\n    public maxMarchingSteps = 255;\n    public epsilon = 0.001;\n\n    public enableShadows = true;\n    public enableShowMarches = false;\n\n    public canvasScale = 1;\n\n    private readonly cameraMatrixArray = new Float32Array(9);\n\n    constructor(gl: WebGL2RenderingContext,\n        shader: Shader,\n        positionBuffer: WebGLBuffer,\n        uShapes: WebGLUniformLocation,\n        uOperations: WebGLUniformLocation,\n        uNumOperations: WebGLUniformLocation,\n        uLights: WebGLUniformLocation,\n        uNumLights: WebGLUniformLocation,\n        uCameraPosition: WebGLUniformLocation,\n        uCameraMatrix: WebGLUniformLocation,\n        uAspectRatio: WebGLUniformLocation,\n        uMaxMarchingSteps: WebGLUniformLocation,\n        uEpsilon: WebGLUniformLocation,\n        uFlags: WebGLUniformLocation,\n    )\n    {\n        this.gl = gl;\n        this.shader = shader;\n        this.positionBuffer = positionBuffer;\n\n        this.uShapes = uShapes;\n\n        this.uOperations = uOperations;\n        this.uNumOperations = uNumOperations;\n\n        this.uLights = uLights;\n        this.uNumLights = uNumLights;\n\n        this.uCameraPosition = uCameraPosition;\n        this.uCameraMatrix = uCameraMatrix;\n        this.uAspectRatio = uAspectRatio;\n\n        this.uMaxMarchingSteps = uMaxMarchingSteps;\n        this.uEpsilon = uEpsilon;\n        this.uFlags = uFlags;\n    }\n\n    public setupCanvas()\n    {\n        this.resizeCanvas(window.innerWidth, window.innerHeight);\n\n        // Firefox doesn't like having the canvas rendered to until something has happened, like a fillRect\n        this.gl.clearColor(0, 0, 0, 0);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    }\n\n    public handleResize()\n    {\n        this.resizeCanvas(window.innerWidth, window.innerHeight);\n    }\n\n    public orbitCamera(horizontal: number, vertical: number)\n    {\n        this.cameraRotationX += horizontal;\n        this.cameraRotationY += vertical;\n\n        this.updateCamera();\n    }\n\n    public updateCamera()\n    {\n        quatFromEuler(tempAxisQuat, this.cameraRotationX, this.cameraRotationY, 0);\n        const forward = vec3TransformQuat(vec3Zero(), {x: 0, y: 0, z: 1}, tempAxisQuat);\n\n        vec3ScaleAndAddBy(this.cameraPosition, this.cameraTarget, forward, this.cameraDistance);\n        mat3ArraySetFromQuat(this.cameraMatrixArray, tempAxisQuat);\n    }\n\n    public resizeCanvas = (width: number, height: number) =>\n    {\n        const scaledWidth = width * this.canvasScale;\n        const scaledHeight = height * this.canvasScale;\n        this.gl.canvas.width = scaledWidth;\n        this.gl.canvas.height = scaledHeight;\n\n        this.gl.viewport(0, 0, scaledWidth, scaledHeight);\n\n        const aspectRatio = scaledWidth / scaledHeight;\n        this.gl.uniform1f(this.uAspectRatio, aspectRatio);\n    }\n\n    public render(scene: SdfScene)\n    {\n        this.gl.uniformMatrix2x4fv(this.uLights, false, scene.getLightDataArray());\n        this.gl.uniform1i(this.uNumLights, scene.getNumLights());\n\n        const ops = scene.getOperationNumbers();\n        this.gl.uniform1i(this.uNumOperations, ops.length);\n        this.gl.uniform1iv(this.uOperations, ops);\n\n        this.gl.uniformMatrix4fv(this.uShapes, false, scene.getShapeDataArray());\n        this.gl.uniformMatrix2x4fv(this.uLights, false, scene.getLightDataArray());\n        this.gl.uniform1i(this.uNumLights, scene.getNumLights());\n\n        this.gl.uniform4i(this.uFlags, this.enableShadows ? 1 : 0, this.enableShowMarches ? 1 : 0, 0, 0);\n        this.gl.uniform1f(this.uEpsilon, this.epsilon);\n        this.gl.uniform1i(this.uMaxMarchingSteps, this.maxMarchingSteps);\n\n        this.gl.uniform3f(\n            this.uCameraPosition,\n            this.cameraPosition.x,\n            this.cameraPosition.y,\n            this.cameraPosition.z\n        );\n        this.gl.uniformMatrix3fv(this.uCameraMatrix, true, this.cameraMatrixArray);\n\n        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    }\n\n    public static create(canvas: HTMLCanvasElement): WebGLSdfRenderer\n    {\n        const gl = canvas.getContext('webgl2');\n        if (gl == null)\n        {\n            throw new Error('Unable to get webgl2 context');\n        }\n\n        const positionBuffer = gl.createBuffer();\n        if (positionBuffer == null)\n        {\n            throw new Error('Unable to create position buffer');\n        }\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n        const shader = Shader.create(gl, vertText, fragText);\n        gl.useProgram(shader.program);\n\n        const positionAttributeLoc = this.getAttribute(gl, shader, 'aPosition');\n        gl.enableVertexAttribArray(positionAttributeLoc);\n        gl.vertexAttribPointer(positionAttributeLoc, 2, gl.FLOAT, false, 0, 0);\n\n        const uCameraMatrix = this.getUniform(gl, shader, 'uCameraMatrix');\n        const uCameraPosition = this.getUniform(gl, shader, 'uCameraPosition');\n        const uAspectRatio = this.getUniform(gl, shader, 'uAspectRatio');\n\n        const uShapes = this.getUniform(gl, shader, 'uShapes');\n        const uOperations = this.getUniform(gl, shader, 'uOperations');\n        const uNumOperations = this.getUniform(gl, shader, 'uNumOperations');\n\n        const uLights = this.getUniform(gl, shader, 'uLights');\n        const uNumLights = this.getUniform(gl, shader, 'uNumLights');\n\n        const uMaxMarchingSteps = this.getUniform(gl, shader, 'uMaxMarchingSteps');\n        const uEpsilon = this.getUniform(gl, shader, 'uEpsilon');\n        const uFlags = this.getUniform(gl, shader, 'uFlags');\n\n        return new WebGLSdfRenderer(gl, shader, positionBuffer,\n            uShapes, uOperations, uNumOperations,\n            uLights, uNumLights,\n            uCameraPosition, uCameraMatrix, uAspectRatio,\n            uMaxMarchingSteps, uEpsilon, uFlags);\n    }\n\n    private static getAttribute(gl: WebGL2RenderingContext, shader: Shader, name: string)\n    {\n        const attribute = gl.getAttribLocation(shader.program, name);\n        if (attribute < 0)\n        {\n            throw new Error(`Unable to find attribute ${name}`);\n        }\n        return attribute;\n    }\n\n    private static getUniform(gl: WebGL2RenderingContext, shader: Shader, name: string)\n    {\n        const location = gl.getUniformLocation(shader.program, name);\n        if (location == null)\n        {\n            throw new Error(`Unable to find uniform ${name}`);\n        }\n        return location;\n    }\n}", "import { SdfOpCodeIntersection, SdfScene } from \"./sdf-scene\";\n\nimport WebGLSdfRenderer from \"./webgl-sdf-renderer\";\n\nconst sdfScene = new SdfScene();\nlet sdfRenderer: WebGLSdfRenderer;\n\nlet renderEnabled = true;\n\nlet time = 0;\nlet deltaTime = 0;\n\nlet timeSinceStart = 0;\n\nlet elMaxMarchingStep = document.getElementById('max-marching-steps') as HTMLInputElement;\nlet elMaxMarchingStepValue = document.getElementById('max-marching-steps_value') as HTMLInputElement;\nlet elEnableShadows = document.getElementById('enable-shadows') as HTMLInputElement;\nlet elEnableShowMarching = document.getElementById('enable-show-marching') as HTMLInputElement;\n\nfunction startup()\n{\n    const toggleRenderButton = document.getElementById('toggle-render');\n    toggleRenderButton.addEventListener('click', () =>\n    {\n        if (renderEnabled)\n        {\n            toggleRenderButton.innerText = 'Start';\n            renderEnabled = false;\n        }\n        else\n        {\n            toggleRenderButton.innerText = 'Stop';\n            renderEnabled = true;\n\n            time = Date.now();\n            requestAnimationFrame(render);\n        }\n    });\n\n    document.getElementById('select-render-scale').addEventListener('change', (e: Event) =>\n    {\n        const selectedValue = (e.target as HTMLSelectElement).value;\n        const value = Number.parseFloat(selectedValue);\n        if (isFinite(value))\n        {\n            // canvasScale = value;\n            sdfRenderer.canvasScale = value;\n            sdfRenderer.handleResize();\n        }\n        else\n        {\n            console.warn('Unable to parse canvas scale', selectedValue);\n        }\n    })\n\n    window.addEventListener('resize', (e) =>\n    {\n        sdfRenderer.handleResize();\n        if (!renderEnabled)\n        {\n            render();\n        }\n    });\n\n    const canvas = document.getElementById(\"main-canvas\") as HTMLCanvasElement;\n    if (!canvas)\n    {\n        console.error(\"Couldn't find main-canvas\");\n    }\n    else\n    {\n        sdfRenderer = WebGLSdfRenderer.create(canvas);\n        sdfRenderer.setupCanvas();\n\n        sdfScene.setShape(0, {\n            type: 'sphere',\n            shapeParams: {x: 1, y: 2, z: 1},\n            maxSize: 2.0,\n            diffuseColour: {x: 0.1, y: 0.9, z: 0.2, w: 1.0}\n        });\n        sdfScene.setShape(1, {\n            type: 'hexPrism',\n            shapeParams: {x: 1.0, y: 2, z: 0},\n            maxSize: 1.5\n        });\n        sdfScene.setShape(2, {\n            type: 'box',\n            shapeParams: {x: 6, y: 1, z: 6},\n            position: {x: 0, y: -1.5, z: 0},\n            diffuseColour: {x: 0.2, y: 0.25, z: 0.3, w: 1.0}\n        });\n        sdfScene.setOperations([0, 2, 'union', 1, 'subtraction']);\n\n        sdfScene.setLight(0, {\n            position: {x: 4, y: 2, z: 3},\n            colour: {x: 1.0, y: 0.8, z: 0.6, w: 1}\n        });\n        sdfScene.setLight(1, {\n            position: {x: -4, y: 2, z: 3},\n            colour: {x: 0.2, y: 1.0, z: 0.6, w: 1}\n        });\n\n        sdfRenderer.cameraDistance = 10.0;\n        sdfRenderer.updateCamera();\n        window.addEventListener('pointerdown', onPointerDown);\n        window.addEventListener('pointermove', onPointerMove);\n        window.addEventListener('pointerup', onPointerUp);\n        window.addEventListener('wheel', onMouseWheel);\n\n        elMaxMarchingStep.addEventListener('input', (e: InputEvent) =>\n        {\n            sdfRenderer.maxMarchingSteps = Math.round(parseFloat(elMaxMarchingStep.value));\n            elMaxMarchingStepValue.innerText = sdfRenderer.maxMarchingSteps.toString(10);\n            manualRenderTrigger();\n        });\n        elEnableShadows.addEventListener('change', (e: InputEvent) =>\n        {\n            sdfRenderer.enableShadows = elEnableShadows.checked;\n            manualRenderTrigger();\n        });\n        elEnableShowMarching.addEventListener('change', (e: InputEvent) =>\n        {\n            sdfRenderer.enableShowMarches = elEnableShowMarching.checked;\n            manualRenderTrigger();\n        });\n\n        time = Date.now();\n        requestAnimationFrame(render);\n    }\n}\n\nlet mousePosX = 0;\nlet mousePosY = 0;\nlet mouseDown = false;\nfunction onPointerDown(e: PointerEvent)\n{\n    if (e.target !== document.body)\n    {\n        return;\n    }\n\n    mousePosX = e.clientX;\n    mousePosY = e.clientY;\n    mouseDown = true;\n}\n\nfunction onPointerMove(e: PointerEvent)\n{\n    if (!mouseDown)\n    {\n        return;\n    }\n\n    const dx = e.clientX - mousePosX;\n    const dy = e.clientY - mousePosY;\n\n    mousePosX = e.clientX;\n    mousePosY = e.clientY;\n\n    sdfRenderer.orbitCamera(dy, dx);\n\n    manualRenderTrigger();\n}\n\nfunction onPointerUp(e: PointerEvent)\n{\n    mouseDown = false;\n}\n\nlet zoom = 20;\nconst zoomMin = 1;\nconst zoomMax = 80;\nfunction onMouseWheel(e: WheelEvent)\n{\n    const delta = e.deltaY > 0 ? 1 : -1;\n    const newZoom = zoom + delta;\n    zoom = Math.max(Math.min(100, newZoom), 0);\n    sdfRenderer.cameraDistance = (zoom * 0.01) * (zoomMax - zoomMin) + zoomMin;\n    sdfRenderer.updateCamera();\n\n    manualRenderTrigger();\n}\n\nfunction manualRenderTrigger()\n{\n    // If the renderer is not enabled, then we'll manually call a render\n    if (!renderEnabled)\n    {\n        sdfRenderer.render(sdfScene);\n    }\n}\n\nfunction render()\n{\n    let now = Date.now();\n    deltaTime = time - now;\n    time = now;\n\n    timeSinceStart += deltaTime;\n\n    const tx = Math.cos(timeSinceStart / 1000);\n    const ty = Math.sin(timeSinceStart / 1000);\n    const x = tx * 7;\n    const z = ty * 7;\n    sdfScene.setLight(0, { position: { x, z, y: 1.5 } });\n\n    sdfScene.setShape(1, {\n        position: { x: x / 5, y: z / 7, z: 0 },\n    });\n\n    sdfRenderer.render(sdfScene);\n\n    if (renderEnabled)\n    {\n        requestAnimationFrame(render);\n    }\n}\n\nstartup();"],
  "mappings": "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",
  "names": ["mathf", "_mathf", "a", "b", "value", "min", "max", "t", "current", "target", "maxDelta", "difference", "vec3ScaleAndAddBy", "target", "left", "right", "scale", "vec3TransformQuat", "out", "v", "q", "x", "y", "z", "w2", "uvx", "uvy", "uvz", "uuvx", "uuvy", "uuvz", "vec3Zero", "vec4One", "quatIdentity", "quatFromEuler", "q", "x", "y", "z", "order", "mathf", "halfToRad", "sx", "cx", "sy", "cy", "sz", "cz", "lightDataSize", "SdfOpCodeNone", "SdfOpCodeUnion", "SdfOpCodeIntersection", "SdfOpCodeSubtraction", "SdfOpCodeXor", "ShapeTypeNone", "ShapeTypeBox", "ShapeTypeSphere", "ShapeTypeHexPrism", "SdfOpCodeMap", "ShapeTypeMap", "toShapeTypeInt", "type", "toOpCodeInt", "shapeDataSize", "SdfScene", "operations", "index", "light", "shape", "dataIndex", "i", "vec3Zero", "vec4One", "quatIdentity", "vert_default", "frag_default", "Shader", "_Shader", "program", "gl", "vertText", "fragText", "cleanup", "vert", "frag", "error", "positions", "tempAxisQuat", "quatIdentity", "mat3ArraySetFromQuat", "m", "q", "x2", "y2", "z2", "xx", "yx", "yy", "zx", "zy", "zz", "wx", "wy", "wz", "WebGLSdfRenderer", "_WebGLSdfRenderer", "vec3Zero", "gl", "shader", "positionBuffer", "uShapes", "uOperations", "uNumOperations", "uLights", "uNumLights", "uCameraPosition", "uCameraMatrix", "uAspectRatio", "uMaxMarchingSteps", "uEpsilon", "uFlags", "horizontal", "vertical", "quatFromEuler", "forward", "vec3TransformQuat", "vec3ScaleAndAddBy", "width", "height", "scaledWidth", "scaledHeight", "aspectRatio", "scene", "ops", "canvas", "Shader", "vert_default", "frag_default", "positionAttributeLoc", "name", "attribute", "location", "sdfScene", "SdfScene", "sdfRenderer", "renderEnabled", "time", "deltaTime", "timeSinceStart", "elMaxMarchingStep", "elMaxMarchingStepValue", "elEnableShadows", "elEnableShowMarching", "startup", "toggleRenderButton", "render", "selectedValue", "value", "canvas", "WebGLSdfRenderer", "onPointerDown", "onPointerMove", "onPointerUp", "onMouseWheel", "manualRenderTrigger", "mousePosX", "mousePosY", "mouseDown", "e", "dx", "dy", "zoom", "zoomMin", "zoomMax", "delta", "newZoom", "now", "tx", "ty", "x", "z"]
}
