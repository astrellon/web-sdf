{
  "version": 3,
  "sources": ["../node_modules/simple-data-store/src/index.ts", "../node_modules/fast-deep-equal/index.js", "../node_modules/preact/src/constants.js", "../node_modules/preact/src/util.js", "../node_modules/preact/src/options.js", "../node_modules/preact/src/create-element.js", "../node_modules/preact/src/component.js", "../node_modules/preact/src/diff/props.js", "../node_modules/preact/src/create-context.js", "../node_modules/preact/src/diff/children.js", "../node_modules/preact/src/diff/index.js", "../node_modules/preact/src/render.js", "../node_modules/preact/src/clone-element.js", "../node_modules/preact/src/diff/catch-error.js", "../src/shaders/vert.glsl", "../src/shaders/frag.glsl", "../src/shaders/sdf-functions.glsl", "../src/shaders/shader.ts", "../src/gl-matrix-ts/mathf.ts", "../src/gl-matrix-ts/vec3.ts", "../src/gl-matrix-ts/vec4.ts", "../src/gl-matrix-ts/quat.ts", "../src/webgl/webgl-sdf-renderer.ts", "../src/store/store.ts", "../src/ray-marching/scene-entities.ts", "../src/ray-marching/scene-tree.ts", "../src/store/store-state.ts", "../src/components/webgl-viewport-options.tsx", "../src/components/webgl-viewport.tsx", "../src/components/vector-view.tsx", "../src/components/shape-view.tsx", "../src/components/light-view.tsx", "../src/components/scene-node-view.tsx", "../src/common.ts", "../src/components/scene-node-tree-item.tsx", "../src/components/scene-node-tree.tsx", "../src/components/scene-tree-view.tsx", "../node_modules/preact/hooks/src/index.js", "../node_modules/preact/compat/src/util.js", "../node_modules/preact/compat/src/hooks.js", "../node_modules/preact/compat/src/PureComponent.js", "../node_modules/preact/compat/src/memo.js", "../node_modules/preact/compat/src/forwardRef.js", "../node_modules/preact/compat/src/Children.js", "../node_modules/preact/compat/src/suspense.js", "../node_modules/preact/compat/src/suspense-list.js", "../node_modules/preact/src/constants.js", "../node_modules/preact/compat/src/portals.js", "../node_modules/preact/compat/src/render.js", "../node_modules/preact/compat/src/index.js", "../src/components/modal.tsx", "../src/components/scene-node-tree-modal.tsx", "../src/components/reparent-modal.tsx", "../src/components/raw-scene-modal.tsx", "../src/components/webgl-app.tsx", "../src/ray-marching/scene-converter.ts", "../src/webgl/webgl-index.tsx"],
  "sourcesContent": ["// A function to create a patch for the state.\n// Meaning this should return a partial state to be merged with the current state.\nexport type Modifier<TState> = (state: TState) => Partial<TState> | null;\n\n// A function that takes part of the state and returns a sub set of that state.\n// Used to look for specific parts of the state that have changed.\nexport type Selector<TState, TValue> = (state: TState) => TValue;\n\n// A function used to compare if two parts of the state have actually changed.\n// By default a strict equals is used when comparing however sometimes something more complex is needed.\n// The TValue refers to the value returned by the Selector.\nexport type SelectorComparer<TValue> = (prevValue: TValue, newValue: TValue) => boolean;\n\n// A callback function to be triggered when a selector has returned a new value.\n// The callback is given the new state and result of the selector that triggered the callback.\n// The TValue refers to the value returned by the Selector.\nexport type Subscription<TState, TValue> = (state: TState, newValue: TValue, triggeringModifier: Modifier<TState>, isNewState: boolean) => void;\n\n// A function used to remove a subscription. This can be called multiple times.\nexport type RemoveSubscription = () => void;\n\n// An empty modifier, recommended to use when you want to return a modifier that does nothing.\nexport const EmptyModifier: Modifier<any> = () => null;\n\n// Pairing of the selector function and subscription callback.\ninterface SubscriptionSelectorPair<TState, TValue>\n{\n    readonly selector: SelectorContext<TState, TValue>;\n    readonly subscription: Subscription<TState, TValue>;\n}\n\n/**\n * The main data store class. Keeps track of the current state, any subscriptions and optionally a history of the state.\n *\n * By default history is disabled.\n */\nexport default class DataStore<TState>\n{\n    private currentState: TState;\n    private subscriptions: Array<SubscriptionSelectorPair<TState, any>> = [];\n\n    /**\n     * Creates a new DataStore.\n     *\n     * @param initialState The starting values for the data store.\n     */\n    public constructor (initialState: TState)\n    {\n        this.currentState = initialState;\n    }\n\n    /**\n     * Returns the current state.\n     *\n     * @returns The current state.\n     */\n    public state = (): Readonly<TState> => this.currentState;\n\n    /**\n     * Executes a modifier on the state.\n     * The modifier is recommended to return a partial state that is merged.\n     *\n     * If the modifier returns the same state (as compared with strict equals) or null then\n     * the state is not updated nor is any subscription triggered.\n     *\n     * @param modifier Modifier function to update the state with.\n     * @param isNewState Marks if this state is a new one. Can be used for history subscriptions to know if to record this state update or not.\n     */\n    public execute(modifier: Modifier<TState>, isNewState: boolean = true)\n    {\n        const newState = modifier(this.currentState);\n        if (newState === null || newState === undefined || newState === this.currentState)\n        {\n            return;\n        }\n\n        this.currentState = Object.assign({}, this.currentState, newState);\n        this.triggerSubscriptions(modifier, isNewState);\n    }\n\n    /**\n     * Subscribe to when a part of the state has changed. This will be called on all dispatches.\n     *\n     * @param selector A function for picking the values out of the store you want to check has changed.\n     * @param subscription A callback that will be triggered when the values returned in the selector have changed.\n     * @param comparer An optional comparer for old and new values, these values will the old and new results from the selector, *NOT* the state as a whole.\n     * @param selectorName An optional name to link with the selector to help with debugging.\n     * @returns A function to remove the subscription from the store.\n     */\n    public subscribe<TValue>(selector: Selector<TState, TValue>, subscription: Subscription<TState, TValue>, comparer?: SelectorComparer<TValue>, selectorName?: string): RemoveSubscription\n    {\n        const startValue = selector(this.currentState);\n        const obj = { selector: new SelectorContext(selector, startValue, comparer, selectorName), subscription };\n        this.subscriptions.push(obj);\n\n        return () =>\n        {\n            const index = this.subscriptions.indexOf(obj);\n            if (index >= 0)\n            {\n                this.subscriptions.splice(index, 1);\n            }\n        };\n    }\n\n    /**\n     * Adds a callback for anytime the store has changed.\n     *\n     * @param callback A callback for when the store has changed.\n     * @param selectorName An optional name to link with the selector to help with debugging.\n     * @returns A function to remove the subscription from the store.\n     */\n    public subscribeAny (callback: Subscription<TState, TState>, selectorName?: string): RemoveSubscription\n    {\n        return this.subscribe((state) => state, callback, undefined, selectorName);\n    }\n\n    /**\n     * Removes all subscriptions.\n     */\n    public unsubscribeAll ()\n    {\n        this.subscriptions = [];\n    }\n\n    /**\n     * Trigger all the subscriptions that an update has executed.\n     *\n     * @param isNewState Marks if this update is for a new state or not. Used by history subscriptions to know if to record the state change or not.\n     */\n    private triggerSubscriptions(modifier: Modifier<TState>, isNewState: boolean)\n    {\n        for (const subscription of this.subscriptions)\n        {\n            const newValue = subscription.selector.getValue(this.currentState);\n            if (subscription.selector.checkIfChanged(newValue))\n            {\n                subscription.subscription(this.currentState, newValue, modifier, isNewState);\n            }\n        }\n    }\n}\n\n/**\n * A selector context is a pairing of a selector function, a comparer and a previous value.\n * This is used to actual keep track of when something has changed and the way to compare the change.\n *\n * NOTE: Not indented to be a public class.\n */\nclass SelectorContext<TState, TValue>\n{\n    public readonly selector: Selector<TState, TValue>;\n    public readonly comparer?: SelectorComparer<TValue>;\n    public readonly name?: string;\n    private prevValue: any;\n\n    constructor (selector: Selector<TState, TValue>, startValue: any = undefined, comparer?: SelectorComparer<TValue>, name?: string)\n    {\n        this.selector = selector;\n        this.prevValue = startValue;\n        this.comparer = comparer;\n        this.name = name;\n    }\n\n    /**\n     * Select the value from the state using the selector function provided.\n     *\n     * @param state The state to get the value from.\n     * @returns Whatever the selector returns.\n     */\n    public getValue = (state: TState): any => this.selector(state);\n\n    /**\n     * Check if the new value is different from the old one using the comparer.\n     *\n     * @param newValue The new value from the selector.\n     */\n    public checkIfChanged (newValue: any): boolean\n    {\n        let result = false;\n        if (this.comparer !== undefined)\n        {\n            result = !this.comparer(this.prevValue, newValue);\n        }\n        else\n        {\n            result = newValue !== this.prevValue;\n        }\n\n        this.prevValue = newValue;\n        return result;\n    }\n}", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {import('./index').ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tif (node && node.parentNode) node.parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\nimport { NULL, UNDEFINED } from './constants';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != NULL) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === UNDEFINED) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, NULL);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {import('./internal').VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: NULL,\n\t\t_parent: NULL,\n\t\t_depth: 0,\n\t\t_dom: NULL,\n\t\t_component: NULL,\n\t\tconstructor: UNDEFINED,\n\t\t_original: original == NULL ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == NULL && options.vnode != NULL) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: NULL };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != NULL && vnode.constructor == UNDEFINED;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE, NULL } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != NULL && this._nextState != this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == NULL) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](https://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == NULL) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: NULL;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != NULL && sibling._dom != NULL) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : NULL;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : NULL,\n\t\t\tcommitQueue,\n\t\t\toldDom == NULL ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != NULL && vnode._component != NULL) {\n\t\tvnode._dom = vnode._component.base = NULL;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != NULL && child._dom != NULL) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce != options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {import('./internal').Component} a\n * @param {import('./internal').Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c,\n\t\tl = 1;\n\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile (rerenderQueue.length) {\n\t\t// Keep the rerender queue sorted by (depth, insertion order). The queue\n\t\t// will initially be sorted on the first iteration only if it has more than 1 item.\n\t\t//\n\t\t// New items can be added to the queue e.g. when rerendering a provider, so we want to\n\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t// single pass\n\t\tif (rerenderQueue.length > l) {\n\t\t\trerenderQueue.sort(depthSort);\n\t\t}\n\n\t\tc = rerenderQueue.shift();\n\t\tl = rerenderQueue.length;\n\n\t\tif (c._dirty) {\n\t\t\trenderComponent(c);\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL, NULL, SVG_NAMESPACE } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] == '-') {\n\t\tstyle.setProperty(key, value == NULL ? '' : value);\n\t} else if (value == NULL) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\nconst CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name == 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] != oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] == 'o' && name[1] == 'n') {\n\t\tuseCapture = name != (name = name.replace(CAPTURE_REGEX, '$1'));\n\t\tconst lowerCaseName = name.toLowerCase();\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (lowerCaseName in dom || name == 'onFocusOut' || name == 'onFocusIn')\n\t\t\tname = lowerCaseName.slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == SVG_NAMESPACE) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == NULL ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != NULL && (value !== false || name[4] == '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {import('../internal').PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == NULL) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\nimport { NULL } from './constants';\n\nexport let i = 0;\n\nexport function createContext(defaultValue) {\n\tfunction Context(props) {\n\t\tif (!this.getChildContext) {\n\t\t\t/** @type {Set<import('./internal').Component> | null} */\n\t\t\tlet subs = new Set();\n\t\t\tlet ctx = {};\n\t\t\tctx[Context._id] = this;\n\n\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tsubs = NULL;\n\t\t\t};\n\n\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t// @ts-expect-error even\n\t\t\t\tif (this.props.value != _props.value) {\n\t\t\t\t\tsubs.forEach(c => {\n\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.sub = c => {\n\t\t\t\tsubs.add(c);\n\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\tif (subs) {\n\t\t\t\t\t\tsubs.delete(c);\n\t\t\t\t\t}\n\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\treturn props.children;\n\t}\n\n\tContext._id = '__cC' + i++;\n\tContext._defaultValue = defaultValue;\n\n\t/** @type {import('./internal').FunctionComponent} */\n\tContext.Consumer = (props, contextValue) => {\n\t\treturn props.children(contextValue);\n\t};\n\n\t// we could also get rid of _contextRef entirely\n\tContext.Provider =\n\t\tContext._contextRef =\n\t\tContext.Consumer.contextType =\n\t\t\tContext;\n\n\treturn Context;\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport {\n\tEMPTY_OBJ,\n\tEMPTY_ARR,\n\tINSERT_VNODE,\n\tMATCHED,\n\tUNDEFINED,\n\tNULL\n} from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\toldDom = constructNewChildrenArray(\n\t\tnewParentVNode,\n\t\trenderResult,\n\t\toldChildren,\n\t\toldDom,\n\t\tnewChildrenLength\n\t);\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (childVNode == NULL) continue;\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index == -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tlet result = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, NULL, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == NULL && newDom != NULL) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (typeof childVNode.type == 'function' && result !== UNDEFINED) {\n\t\t\toldDom = result;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(\n\tnewParentVNode,\n\trenderResult,\n\toldChildren,\n\toldDom,\n\tnewChildrenLength\n) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = new Array(newChildrenLength);\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == NULL ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tnewParentVNode._children[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tNULL,\n\t\t\t\tchildVNode,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (childVNode.constructor == UNDEFINED && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : NULL,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tconst matchingIndex = (childVNode._index = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t));\n\n\t\toldVNode = NULL;\n\t\tif (matchingIndex != -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original == null\n\t\tconst isMounting = oldVNode == NULL || oldVNode._original == NULL;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\t// When the array of children is growing we need to decrease the skew\n\t\t\t\t// as we are adding a new element to the array.\n\t\t\t\t// Example:\n\t\t\t\t// [1, 2, 3] --> [0, 1, 2, 3]\n\t\t\t\t// oldChildren   newChildren\n\t\t\t\t//\n\t\t\t\t// The new element is at index 0, so our skew is 0,\n\t\t\t\t// we need to decrease the skew as we are adding a new element.\n\t\t\t\t// The decrease will cause us to compare the element at position 1\n\t\t\t\t// with value 1 with the element at position 0 with value 0.\n\t\t\t\t//\n\t\t\t\t// A linear concept is applied when the array is shrinking,\n\t\t\t\t// if the length is unchanged we can assume that no skew\n\t\t\t\t// changes are needed.\n\t\t\t\tif (newChildrenLength > oldChildrenLength) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else if (newChildrenLength < oldChildrenLength) {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex != skewedIndex) {\n\t\t\t// When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n\t\t\t// --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n\t\t\t//     we set the skew to 1 as we found an offset.\n\t\t\t// --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n\t\t\t//     this makes us increase the skew again.\n\t\t\t// --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n\t\t\t//\n\t\t\t// this becomes an optimization question where currently we see a 1 element offset as an insertion\n\t\t\t// or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n\t\t\t// while a more than 1 offset we see as a swap.\n\t\t\t// We could probably build heuristics for having an optimized course of action here as well, but\n\t\t\t// might go at the cost of some bytes.\n\t\t\t//\n\t\t\t// If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n\t\t\t// only the first item be a re-scouting and all the others fall in their skewed counter-part.\n\t\t\t// We could also further optimize for swaps\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else {\n\t\t\t\tif (matchingIndex > skewedIndex) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\n\t\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t\t// match the new skew index (i + new skew)\n\t\t\t\t// In the former two branches we know that it matches after skewing\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != NULL && (oldVNode._flags & MATCHED) == 0) {\n\t\t\t\tif (oldVNode._dom == oldDom) {\n\t\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (oldDom && parentVNode.type && !parentDom.contains(oldDom)) {\n\t\t\toldDom = getDomSibling(parentVNode);\n\t\t}\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || NULL);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != NULL && oldDom.nodeType == 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == NULL || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\t//\n\t// If there is an unkeyed functional VNode, that isn't a built-in like our Fragment,\n\t// we should not search as we risk re-using state of an unrelated VNode. (reverted for now)\n\tlet shouldSearch =\n\t\t// (typeof type != 'function' || type === Fragment || key) &&\n\t\tremainingOldChildren >\n\t\t(oldVNode != NULL && (oldVNode._flags & MATCHED) == 0 ? 1 : 0);\n\n\tif (\n\t\t(oldVNode === NULL && childVNode.key == null) ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype == oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) == 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\tlet x = skewedIndex - 1;\n\t\tlet y = skewedIndex + 1;\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype == oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype == oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMATH_NAMESPACE,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tNULL,\n\tRESET_MODE,\n\tSVG_NAMESPACE,\n\tUNDEFINED,\n\tXHTML_NAMESPACE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * @template {any} T\n * @typedef {import('../internal').Ref<T>} Ref<T>\n */\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor != UNDEFINED) return NULL;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == NULL) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != NULL) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tc.componentWillMount != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != NULL &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original == oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original != oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.some(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != NULL) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != NULL) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != NULL) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != NULL && tmp.type === Fragment && tmp.key == NULL;\n\t\t\tlet renderResult = tmp;\n\n\t\t\tif (isTopLevelFragment) {\n\t\t\t\trenderResult = cloneNode(tmp.props.children);\n\t\t\t}\n\n\t\t\toldDom = diffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = NULL;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = NULL;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != NULL) {\n\t\t\t\tif (e.then) {\n\t\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t\t: MODE_SUSPENDED;\n\n\t\t\t\t\twhile (oldDom && oldDom.nodeType == 8 && oldDom.nextSibling) {\n\t\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = NULL;\n\t\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = excessDomChildren.length; i--; ) {\n\t\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == NULL &&\n\t\tnewVNode._original == oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\toldDom = newVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n\n\treturn newVNode._flags & MODE_SUSPENDED ? undefined : oldDom;\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\nfunction cloneNode(node) {\n\tif (\n\t\ttypeof node != 'object' ||\n\t\tnode == NULL ||\n\t\t(node._depth && node._depth > 0)\n\t) {\n\t\treturn node;\n\t}\n\n\tif (isArray(node)) {\n\t\treturn node.map(cloneNode);\n\t}\n\n\treturn assign({}, node);\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType == 'svg') namespace = SVG_NAMESPACE;\n\telse if (nodeType == 'math') namespace = MATH_NAMESPACE;\n\telse if (!namespace) namespace = XHTML_NAMESPACE;\n\n\tif (excessDomChildren != NULL) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value == !!nodeType &&\n\t\t\t\t(nodeType ? value.localName == nodeType : value.nodeType == 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == NULL) {\n\t\tif (nodeType == NULL) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tif (isHydrating) {\n\t\t\tif (options._hydrationMismatch)\n\t\t\t\toptions._hydrationMismatch(newVNode, excessDomChildren);\n\t\t\tisHydrating = false;\n\t\t}\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = NULL;\n\t}\n\n\tif (nodeType == NULL) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data != newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != NULL) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (!(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, NULL, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html != oldHtml.__html && newHtml.__html != dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\t// @ts-expect-error\n\t\t\t\tnewVNode.type == 'template' ? dom.content : dom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType == 'foreignObject' ? XHTML_NAMESPACE : namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != NULL) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (nodeType == 'progress' && inputValue == NULL) {\n\t\t\t\tdom.removeAttribute('value');\n\t\t\t} else if (\n\t\t\t\tinputValue != UNDEFINED &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType == 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType == 'option' && inputValue != oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked != UNDEFINED && checked != dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != NULL) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current == vnode._dom) {\n\t\t\tapplyRef(r, NULL, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != NULL) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = NULL;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\tvnode._component = vnode._parent = vnode._dom = UNDEFINED;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ, NULL } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\t// https://github.com/preactjs/preact/issues/3794\n\tif (parentDom == document) {\n\t\tparentDom = document.documentElement;\n\t}\n\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? NULL\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, NULL, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? NULL\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: NULL,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\nimport { NULL, UNDEFINED } from './constants';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === UNDEFINED && defaultProps != UNDEFINED) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tNULL\n\t);\n}\n", "import { NULL } from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {import('../internal').VNode} [oldVNode]\n * @param {import('../internal').ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {import('../internal').Component} */\n\tlet component,\n\t\t/** @type {import('../internal').ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != NULL) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != NULL) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "#version 300 es\n\nin vec2 aPosition;\nout vec2 oPosition;\n\nuniform float uAspectRatio;\n\nvoid main()\n{\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n    oPosition = aPosition * vec2(uAspectRatio, 1.0);\n}", "#version 300 es\n\nprecision lowp float;\n\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\n\nconst int UNLIT = 0;\nconst int LAMBERT = 1;\nconst int PHONG = 2;\nconst vec3 HIGHLIGHT_COLOUR = vec3(0.9, 0.8, 0.3);\n\nlayout(location = 0) out vec4 fragColour;\n\nin vec2 oPosition;\n\nuniform mat2x4 uLights[8];\nuniform int uNumLights;\nuniform mat3 uCameraMatrix;\nuniform vec3 uCameraPosition;\n\nuniform mat2x4 uMaterials[32];\n\nuniform mat4 uShapes[128];\nuniform int uOperations[128];\nuniform ivec2 uHighlight;\nuniform int uNumOperations;\nuniform int uMaxMarchingSteps;\nuniform float uEpsilon;\n\nuniform bvec4 uFlags;\n\n#include <sdf-functions>\n\nvec3 quatMul( vec4 q, vec3 v )\n{\n    return v + 2.0 * cross(cross(v, q.xyz ) + q.w * v, q.xyz);\n}\n\nvec2 getDistanceToShape(int index, vec3 samplePoint)\n{\n    mat4 shape = uShapes[index];\n\n    vec3 point = shape[0].xyz;\n    float maxSize = shape[0].w;\n\n    vec3 testPoint = point - samplePoint;\n    // if (maxSize > 0.0)\n    // {\n    //     float testDist = length(testPoint);\n    //     if (testDist > maxSize + 3.0)\n    //     {\n    //         return vec2(testDist - 3.0, -1.0);\n    //     }\n    // }\n\n    vec4 rotation = shape[1];\n\n    vec3 transPoint = quatMul(rotation, testPoint);\n\n    int type = int(round(shape[2].x));\n    vec3 params = shape[2].yzw;\n\n    float dist = getDistToType(type, transPoint, params);\n    float material = shape[3].x;\n\n    return vec2(dist, material);\n}\n\nvec2 sceneSDF(vec3 point, int stackStart, int stackEnd)\n{\n    int depthStackIndex = -1;\n    vec2 depthStack[32];\n\n    for (int operationsIndex = stackStart; operationsIndex < stackEnd; operationsIndex++)\n    {\n        int operationOrIndex = uOperations[operationsIndex];\n\n        if (operationOrIndex <= SdfOpCodeNone)\n        {\n            vec2 lastD2 = depthStack[depthStackIndex--];\n            vec2 lastD1 = depthStack[depthStackIndex--];\n            vec2 dist = applyOpCode(operationOrIndex, lastD2, lastD1);\n            depthStack[++depthStackIndex] = dist;\n        }\n        else\n        {\n            vec2 dist = getDistanceToShape(operationOrIndex, point);\n            depthStack[++depthStackIndex] = dist;\n        }\n    }\n\n    return depthStack[0];\n}\n\nvec2 sceneSDF(vec3 point)\n{\n    return sceneSDF(point, 0, uNumOperations);\n}\n\nvec3 createRayDirection(float fieldOfView, vec2 fragCoord)\n{\n    vec2 xy = fragCoord / 2.0;\n    float z = 2.0 / tan(radians(fieldOfView));\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormalPhong(vec3 point, vec3 currentDepth)\n{\n    vec2 eps_zero = vec2(currentDepth.x * 0.0015, 0.0);\n    return normalize(vec3(\n        sceneSDF(point + eps_zero.xyy).x - sceneSDF(point - eps_zero.xyy).x,\n        sceneSDF(point + eps_zero.yxy).x - sceneSDF(point - eps_zero.yxy).x,\n        sceneSDF(point + eps_zero.yyx).x - sceneSDF(point - eps_zero.yyx).x\n    ));\n}\n\n// https://github.com/electricsquare/raymarching-workshop?tab=readme-ov-file#diffuse-term\nvec3 estimateNormalLambert(vec3 point, vec3 currentDepth)\n{\n    // Use offset samples to compute gradient / normal\n    float d = currentDepth.y;\n    vec2 eps_zero = vec2(currentDepth.x * 0.0015, 0.0);\n    return normalize(vec3(\n        sceneSDF(point + eps_zero.xyy).x - d,\n        sceneSDF(point + eps_zero.yxy).x - d,\n        sceneSDF(point + eps_zero.yyx).x - d));\n}\n\nvec3 estimateNormalTetrahedron(vec3 point, vec3 currentDepth)\n{\n    float h = 0.0015 * currentDepth.x;\n    const vec2 k = vec2(1, -1);\n\n    return normalize(\n        k.xyy * sceneSDF(point + k.xyy * h).x +\n        k.yyx * sceneSDF(point + k.yyx * h).x +\n        k.yxy * sceneSDF(point + k.yxy * h).x +\n        k.xxx * sceneSDF(point + k.xxx * h).x );\n\n}\n\nconst float shadowSharpness = 128.0;\nvec2 softShadow(vec3 rayOrigin, vec3 rayDirection, float near, float far)\n{\n    float depth = near;\n    float result = 1.0;\n    int i = 0;\n\n    for (; i < uMaxMarchingSteps; i++)\n    {\n        float dist = sceneSDF(rayOrigin + depth * rayDirection).x;\n        if (dist < uEpsilon)\n        {\n            return vec2(0.0, float(i));\n        }\n\n        result = min(result, shadowSharpness * dist / depth);\n        depth += dist;\n        if (depth >= far)\n        {\n            return vec2(result, float(i));\n        }\n    }\n\n    return vec2(result, float(i));\n}\n\nconst vec3 ambientLight = 0.5 * 0.2 * vec3(1.0, 1.0, 1.0);\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n *\n * The vec3 returned is the RGB color of the light's contribution.\n *\n * diffuse: Diffuse color\n * specular: Specular color\n * shininess: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 currentDepth, vec3 diffuse, vec3 specular, float shininess, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormalPhong(p, currentDepth);\n\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (diffuse * dotLN);\n    }\n    return lightIntensity * (diffuse * dotLN + specular * pow(dotRV, shininess));\n}\n\n\n/**\n * Lighting via Phong illumination.\n *\n * The vec3 returned is the RGB color of that point after lighting is applied.\n * diffuse: Diffuse color\n * specular: Specular color\n * alpha: Shininess coefficient\n * worldPoint: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec4 phongIllumination(vec3 currentDepth, vec3 diffuse, vec3 specular, float shininess, vec3 worldPoint, vec3 cameraPoint)\n{\n    vec3 colour = ambientLight;\n    float light0Rays;\n\n    for (int i = 0; i < uNumLights; i++)\n    {\n        mat2x4 light = uLights[i];\n        vec3 lightPos = light[0].xyz;\n\n        vec2 shadow = vec2(1.0, 0.0);\n        if (uFlags.x)\n        {\n            vec3 toLight = normalize(lightPos - worldPoint);\n            shadow = softShadow(worldPoint, toLight, 0.005 * currentDepth.x, 100.0);\n\n            if (i == 1)\n            {\n                light0Rays = shadow.y;\n            }\n        }\n\n        vec3 lightContrib = phongContribForLight(currentDepth, diffuse, specular, shininess, worldPoint, cameraPoint, lightPos, light[1].xyz);\n        colour += lightContrib * shadow.x;\n    }\n\n    // colour = pow(colour, vec3(1.0 / 2.2)); // Gamma correction\n    return vec4(colour, light0Rays);\n}\n\n/**\n * Lighting contribution of a single point light source via Lambert illumination.\n *\n * The vec3 returned is the RGB color of the light's contribution.\n *\n * diffuse: Diffuse color\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n */\nvec3 lambertContribForLight(vec3 currentDepth, vec3 diffuse, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormalTetrahedron(p, currentDepth);\n\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n\n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    return lightIntensity * (diffuse * dotLN);\n}\n\n/**\n * Lighting via Phong illumination.\n *\n * The vec3 returned is the RGB color of that point after lighting is applied.\n * diffuse: Diffuse color\n * specular: Specular color\n * alpha: Shininess coefficient\n * worldPoint: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec4 lambertIllumination(vec3 currentDepth, vec3 diffuse, vec3 worldPoint, vec3 cameraPoint)\n{\n    vec3 colour = ambientLight;\n    float light0Rays;\n\n    for (int i = 0; i < uNumLights; i++)\n    {\n        mat2x4 light = uLights[i];\n        vec3 lightPos = light[0].xyz;\n\n        vec2 shadow = vec2(1.0, 0.0);\n        if (uFlags.x)\n        {\n            vec3 toLight = normalize(lightPos - worldPoint);\n            shadow = softShadow(worldPoint, toLight, 0.005 * currentDepth.x, 100.0);\n\n            if (i == 1)\n            {\n                light0Rays = shadow.y;\n            }\n        }\n\n        vec3 lightContrib = lambertContribForLight(currentDepth, diffuse, worldPoint, cameraPoint, lightPos, light[1].xyz);\n        colour += lightContrib * shadow.x;\n    }\n\n    // colour = pow(colour, vec3(1.0 / 2.2)); // Gamma correction\n    return vec4(colour, light0Rays);\n}\n\nvec4 rayMarch(vec3 rayOrigin, vec3 rayDirection, float near, float far, int stackStart, int stackEnd)\n{\n    float depth = near;\n    for (int i = 0; i < uMaxMarchingSteps; i++)\n    {\n        vec2 dist = sceneSDF(rayOrigin + depth * rayDirection, stackStart, stackEnd);\n        if (dist.x < uEpsilon)\n        {\n            return vec4(depth, dist.x, float(i), dist.y);\n        }\n\n        depth += dist.x;\n        if (depth >= far)\n        {\n            return vec4(far, dist.x, float(i), dist.y);\n        }\n    }\n\n    return vec4(far, far, float(uMaxMarchingSteps), -1);\n}\n\nvec4 rayMarch(vec3 rayOrigin, vec3 rayDirection, float near, float far)\n{\n    return rayMarch(rayOrigin, rayDirection, near, far, 0, uNumOperations);\n}\n\n\nfloat getHighlightDist(vec3 rayOrigin, vec3 rayDirection, float near, float far)\n{\n    if (uHighlight.x < 0)\n    {\n        return 0.0;\n    }\n\n    vec4 dist = rayMarch(rayOrigin, rayDirection, near, far, uHighlight.x, uHighlight.y);\n    float r = dist.z / float(uMaxMarchingSteps);\n    return smoothstep(0.75, 0.85, r);\n}\n\nvoid main()\n{\n    vec3 rayDir = uCameraMatrix * createRayDirection(45.0, oPosition);\n    vec3 rayOrigin = uCameraPosition;\n\n    vec4 dist = rayMarch(rayOrigin, rayDir, MIN_DIST, MAX_DIST);\n    vec4 litColour;\n\n    if (dist.x > MAX_DIST - uEpsilon)\n    {\n        if (uFlags.y)\n        {\n            float r = dist.z / float(uMaxMarchingSteps);\n            fragColour = vec4(r, 0, getHighlightDist(rayOrigin, rayDir, MIN_DIST, MAX_DIST), 1);\n            return;\n        }\n\n        float highlightDist = getHighlightDist(rayOrigin, rayDir, MIN_DIST, MAX_DIST);\n        fragColour = vec4(0, 0, highlightDist, highlightDist);\n    }\n    else\n    {\n        // The closest point on the surface to the eyepoint along the view ray\n        vec3 worldPoint = rayOrigin + dist.x * rayDir;\n\n        int lightingModel = 0;\n        vec3 diffuse = vec3(0.7, 0.2, 0.2);\n        vec3 specular = vec3(1.0, 1.0, 1.0);\n        float shininess = 10.0;\n        if (dist.w >= 0.0)\n        {\n            mat2x4 material = uMaterials[int(dist.w)];\n            diffuse = material[0].xyz;\n            lightingModel = int(round(material[0].w));\n\n            specular = material[1].xyz;\n            shininess = material[1].w;\n        }\n\n        switch (lightingModel)\n        {\n            default:\n            case UNLIT:\n                litColour = vec4(diffuse, 1.0);\n                break;\n            case LAMBERT:\n                litColour = lambertIllumination(dist.xyz, diffuse, worldPoint, rayOrigin);\n                break;\n            case PHONG:\n                litColour = phongIllumination(dist.xyz, diffuse, specular, shininess, worldPoint, rayOrigin);\n                break;\n        }\n\n        float highlightDist = getHighlightDist(rayOrigin, rayDir, MIN_DIST, MAX_DIST);\n        if (highlightDist > 0.0)\n        {\n            fragColour = vec4(mix(litColour.xyz, HIGHLIGHT_COLOUR, highlightDist), 1.0);\n        }\n\n        fragColour = vec4(litColour.xyz, 1.0);\n    }\n\n    if (uFlags.y)\n    {\n        float r = dist.z / float(uMaxMarchingSteps);\n        float g = litColour.w / float(uMaxMarchingSteps);\n\n        float highlightDist = getHighlightDist(rayOrigin, rayDir, MIN_DIST, MAX_DIST);\n        fragColour = vec4(r, g, highlightDist, 1);\n    }\n}", "const int ShapeTypeNone = -5000;\nconst int ShapeTypeBox = -6000;\nconst int ShapeTypeSphere = -7000;\nconst int ShapeTypeHexPrism = -8000;\n\nconst int SdfOpCodeNone = -500;\nconst int SdfOpCodeUnion = -600;\nconst int SdfOpCodeIntersection = -700;\nconst int SdfOpCodeSubtraction = -800;\n\nfloat sdfSphere(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat sdfHexPrism(vec3 point, vec2 params)\n{\n    vec3 absPoint = abs(point);\n    float d1 = absPoint.z - params.y;\n    float d2 = max((absPoint.x * 0.866025 + absPoint.y * 0.5), absPoint.y) - params.x;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat sdfBox(vec3 point, vec3 size)\n{\n    vec3 d = abs(point) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0)   // inside distance\n        + length(max(d, 0.0));              // outside distance\n}\n\nvec2 opUnion(vec2 d1, vec2 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n    // return min(d1, d2);\n}\n\nvec2 opSubtraction(vec2 d1, vec2 d2)\n{\n    return -d1.x > d2.x ? vec2(-d1.x, d1.y) : d2;\n    // return max(-d1, d2);\n}\n\nvec2 opIntersection(vec2 d1, vec2 d2)\n{\n    return d1.x > d2.x ? d1 : d2;\n    // return max(d1, d2);\n}\n\nvec2 applyOpCode(int opCode, vec2 dist1, vec2 dist2)\n{\n    switch (opCode)\n    {\n        case SdfOpCodeUnion: return opUnion(dist1, dist2);\n        case SdfOpCodeIntersection: return opIntersection(dist1, dist2);\n        case SdfOpCodeSubtraction: return opSubtraction(dist1, dist2);\n    }\n\n    return vec2(100.0, -1);\n}\n\nfloat getDistToType(int type, vec3 point, vec3 params)\n{\n    switch (type)\n    {\n        case ShapeTypeBox: return sdfBox(point, params);\n        case ShapeTypeSphere: return sdfSphere(point, params.x);\n        case ShapeTypeHexPrism: return sdfHexPrism(point, params.xy);\n    }\n\n    return 100.0;\n}", "interface ShaderLookup\n{\n    readonly [name: string]: string\n}\n\nconst includePragma = /^#include\\s+\\<([^\\>]+)\\>/gmi;\n\nexport default class Shader\n{\n    public readonly program: WebGLProgram;\n\n    constructor(program: WebGLProgram)\n    {\n        this.program = program;\n    }\n\n    public static assembleShader(includes: ShaderLookup, text: string)\n    {\n        const matches = text.matchAll(includePragma);\n        for (const match of matches)\n        {\n            let toInclude = includes[match[1]];\n            if (toInclude === undefined)\n            {\n                console.error(`Unknown shader include ${match[1]}`);\n                toInclude = '';\n            }\n\n            text = text.replace(match[0], toInclude);\n        }\n\n        return text;\n    }\n\n    public static create(gl: WebGL2RenderingContext, includes: ShaderLookup, vertText: string, fragText: string): Shader\n    {\n        function cleanup()\n        {\n            if (program != null)\n            {\n                gl.detachShader(program, vert);\n                gl.detachShader(program, frag);\n            }\n\n            if (vert != null)\n            {\n                gl.deleteShader(vert);\n            }\n\n            if (frag != null)\n            {\n                gl.deleteShader(frag);\n            }\n        }\n\n        const vert = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vert, this.assembleShader(includes, vertText));\n        gl.compileShader(vert);\n\n        if (!gl.getShaderParameter(vert, gl.COMPILE_STATUS))\n        {\n            const error = gl.getShaderInfoLog(vert);\n            console.error('Vertex shader compile error', error);\n\n            cleanup();\n            throw new Error(`Vertex shader compile error ${error}`);\n        }\n\n        const frag = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(frag, this.assembleShader(includes, fragText));\n        gl.compileShader(frag);\n        if (!gl.getShaderParameter(frag, gl.COMPILE_STATUS))\n        {\n            const error = gl.getShaderInfoLog(frag);\n            console.error('Fragment shader compile error', error);\n\n            cleanup();\n            throw new Error(`Fragment shader compile error ${error}`);\n        }\n\n        const program = gl.createProgram();\n        gl.attachShader(program, vert);\n        gl.attachShader(program, frag);\n        gl.linkProgram(program);\n\n        cleanup();\n\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n        {\n            gl.useProgram(null);\n            gl.deleteProgram(program);\n\n            const error = gl.getProgramInfoLog(program);\n            console.error('Shader link error', error);\n\n            throw new Error(`Shader link error ${error}`);\n        }\n\n        return new Shader(program);\n    }\n}", "/**\n * Common utilities\n * @module glMatrix\n */\nexport type AngleOrder = 'xyz' | 'xzy' | 'yxz' | 'yzx' | 'zxy' | 'zyx';\n\nexport default class mathf {\n    // Configuration Constants\n    static readonly EPSILON = 0.000001;\n    static readonly ANGLE_ORDER: AngleOrder = \"zyx\";\n    static readonly DegToRad = Math.PI / 180;\n    static readonly RadToDeg = 180 / Math.PI;\n\n    /**\n     * Convert Degree To Radian\n     *\n     * @param {number} a Angle in Degrees\n     */\n    static toRadian(a: number) {\n        return a * this.DegToRad;\n    }\n\n    /**\n     * Tests whether or not the arguments have approximately the same value, within an absolute\n     * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n     * than or equal to 1.0, and a relative tolerance is used for larger values)\n     *\n     * @param {number} a The first number to test.\n     * @param {number} b The second number to test.\n     * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n     */\n    equals(a: number, b: number) {\n        return Math.abs(a - b) <= mathf.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n    }\n\n    /**\n     * \u9650\u5B9A\u5728\u6700\u5C0F\u503C\u548C\u6700\u5927\u503C\u4E4B\u95F4\n     * @param value\n     * @param min\n     * @param max\n     * @returns\n     */\n    public static clamp(value: number, min: number, max: number) {\n        return Math.max(Math.min(value, max), min);\n    }\n\n    /**\n     * \u63D2\u503C\n     * @param a\n     * @param b\n     * @param t\n     * @returns\n     */\n    public static lerp(a: number, b: number, t: number) {\n        return a + (b - a) * t;\n    }\n\n    /**\n     * \u5F53\u524D\u503C\u5411target\u6BCF\u6B21\u6700\u591A\u79FB\u52A8maxDelta\u8DDD\u79BB\n     * @param current\n     * @param target\n     * @param maxDelta\n     * @returns\n     */\n    public static moveTowards(current: number, target: number, maxDelta: number) {\n        const difference = target - current;\n        if (Math.abs(difference) <= maxDelta) {\n            return target;\n        } else {\n            return current + Math.sign(difference) * maxDelta;\n        }\n    }\n\n    /**\n     * \u53CD\u63D2\u503C\n     * @param a\n     * @param b\n     * @param t\n     * @returns\n     */\n    inverseLerp(a: number, b: number, t: number) {\n        if (a === b) {\n            return 0;\n        } else {\n            return (t - a) / (b - a);\n        }\n    }\n}", "import { rmat3 } from \"./mat3\";\nimport { rmat4 } from \"./mat4\";\nimport { rquat } from \"./quat\";\n\nexport interface vec3\n{\n    x: number;\n    y: number;\n    z: number;\n}\n\nexport type rvec3 = Readonly<vec3>;\n\n/**\n * Clones this vector\n *\n * @param v the vector to clone\n * @returns a new vector\n */\nexport function vec3Clone(v: rvec3): vec3\n{\n    return {x: v.x, y: v.y, z: v.z};\n}\n\n/**\n * Copy the values from one vec3 to another\n * @param v the target vector\n * @param a the copy vector\n * @returns the target vector\n */\nexport function vec3Copy(v: vec3, a: rvec3)\n{\n    v.x = a.x;\n    v.y = a.y;\n    v.z = a.z;\n    return v;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param v the target vector\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @returns the target vector\n */\nexport function vec3Set(v: vec3, x: number, y: number, z: number)\n{\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Calculates the length vector v\n *\n * @params the source vector\n * @returns length of v\n */\nexport function vec3Length(v: rvec3)\n{\n    return Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2);\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @returns squared length of v\n */\nexport function vec3SquaredLength(v: rvec3)\n{\n    return v.x ** 2 + v.y ** 2 + v.z ** 2;\n}\n\n/**\n * Adds vector other into vec\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3AddTo(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x + right.x;\n    v.y = left.y + right.y;\n    v.z = left.z + right.z;\n    return v;\n}\n\n/**\n * Adds two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Add(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n    }\n}\n\n/**\n * Subtracts vector other from vector vec\n\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3SubFrom(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x - right.x;\n    v.y = left.y - right.y;\n    v.z = left.z - right.z;\n    return v;\n}\n\n/**\n * Subtracts vector other from vector vec into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Sub(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n    }\n}\n\n/**\n * Multiplies the left vector by the right vector\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3MulTo(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x * right.x;\n    v.y = left.y * right.y;\n    v.z = left.z * right.z;\n    return v;\n}\n\n/**\n * Multiplies the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Mul(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x * right.x,\n        y: left.y * right.y,\n        z: left.z * right.z,\n    }\n}\n\n/**\n * Divides the left vector by the right vector\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3DivBy(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x / right.x;\n    v.y = left.y / right.y;\n    v.z = left.z / right.z;\n    return v;\n}\n\n/**\n * Divides the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Div(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x / right.x,\n        y: left.y / right.y,\n        z: left.z / right.z,\n    }\n}\n\n/**\n * Scales the target vector by a scalar number\n * @param v the target vector\n * @param left the left vector\n * @param right amount to scale the vector by\n * @returns the target vector\n */\nexport function vec3ScaleBy(v: vec3, left: vec3 | rvec3, right: number)\n{\n    v.x = left.x * right;\n    v.y = left.y * right;\n    v.z = left.z * right;\n    return v;\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec3Scale(v: rvec3, scale: number): vec3\n{\n    return {\n        x: v.x * scale,\n        y: v.y * scale,\n        z: v.z * scale\n    };\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec3ScaleAndAddBy(target: vec3, left: rvec3, right: rvec3, scale: number): vec3\n{\n    target.x = left.x + (right.x * scale);\n    target.y = left.y + (right.y * scale);\n    target.z = left.z + (right.z * scale);\n    return target;\n}\n\n/**\n * Calculates the Euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns the distance between left and right\n */\nexport function vec3Distance(left: rvec3, right: rvec3)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    return Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);\n}\n\n/**\n * Calculates the squared euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns the square distance between left and right\n */\nexport function vec3SquaredDistance(left: rvec3, right: rvec3)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    return dx ** 2 + dy ** 2 + dz ** 2;\n}\n\n/**\n * Negates the components of vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec3Negate(v: vec3)\n{\n    v.x = -v.x;\n    v.y = -v.y;\n    v.z = -v.z;\n    return v;\n}\n\n/**\n * Negates the components of vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Negated(v: rvec3): vec3\n{\n    return {\n        x: -v.x,\n        y: -v.y,\n        z: -v.z\n    }\n}\n\n/**\n * Inverse of the components of a vector\n *\n * @param v the target vector\n * @param source the source vector\n * @returns the target vector\n */\nexport function vec3Inverse(v: vec3, source: vec3 | rvec3)\n{\n    v.x = 1.0 / source.x;\n    v.y = 1.0 / source.y;\n    v.z = 1.0 / source.z;\n    return v;\n}\n\n/**\n * Returns the inverse of the components of a vector into a new vector\n *\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Inversed(v: rvec3): vec3\n{\n    return {\n        x: 1.0 / v.x,\n        y: 1.0 / v.y,\n        z: 1.0 / v.z\n    };\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec3Normalize(v: vec3, source: vec3 | rvec3)\n{\n    let sqrtLen = vec3SquaredLength(source);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x = source.x * sqrtLen;\n    v.y = source.y * sqrtLen;\n    v.z = source.z * sqrtLen;\n    return v;\n}\n\nexport function vec3NormalizeValues(v: vec3, x: number, y: number, z: number)\n{\n    let sqrtLen = x ** 2 + y ** 2 + z ** 2;\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x = x * sqrtLen;\n    v.y = y * sqrtLen;\n    v.z = z * sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Normalized(v: rvec3): vec3\n{\n    let sqrtLen = vec3SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen\n    }\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3NormalizedValues(x: number, y: number, z: number): vec3\n{\n    let sqrtLen = x ** 2 + y ** 2 + z ** 2;\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: x * sqrtLen,\n        y: y * sqrtLen,\n        z: z * sqrtLen\n    }\n}\n\n/**\n * Calculates the dot product of two vec3's\n * @param left the left vector\n * @param right the right vector\n * @returns dot product of left and right\n */\nexport function vec3Dot(left: rvec3, right: rvec3)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z;\n}\n\n/**\n * Computes the cross product of two vectors into the target vector\n *\n * @param v the  target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3CrossBy(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    const x = left.y * right.z - left.z * right.y;\n    const y = left.z * right.x - left.x * right.z;\n    const z = left.x * right.y - left.y * right.x;\n\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Computes the cross product of two vectors into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Cross(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.y * right.z - left.z * right.y,\n        y: left.z * right.x - left.x * right.z,\n        z: left.x * right.y - left.y * right.x\n    };\n}\n\n/**\n * Performs a linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs (not clamped)\n * @returns a new vector\n */\nexport function vec3Lerp(left: rvec3, right: rvec3, t: number): vec3\n{\n    return {\n        x: left.x + t * (right.x - left.x),\n        y: left.y + t * (right.y - left.y),\n        z: left.z + t * (right.z - left.z)\n    };\n}\n\n/**\n * Performs a spherical linear interpolation between two vectors\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3SlerpBy(v: vec3, left: vec3 | rvec3, right: rvec3, t: number)\n{\n    const angle = Math.acos(Math.min(Math.max(vec3Dot(left, right), -1), 1));\n    const sinTotal = 1.0 / Math.sin(angle);\n\n    const ratioA = Math.sin((1 - t) * angle) * sinTotal;\n    const ratioB = Math.sin(t * angle) * sinTotal;\n\n    const x = ratioA * left.x + ratioB * right.x;\n    const y = ratioA * left.y + ratioB * right.y;\n    const z = ratioA * left.z + ratioB * right.z;\n\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Performs a spherical linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns a new vector\n */\nexport function vec3Slerp(left: rvec3, right: rvec3, t: number): vec3\n{\n    const angle = Math.acos(Math.min(Math.max(vec3Dot(left, right), -1), 1));\n    const sinTotal = 1.0 / Math.sin(angle);\n\n    const ratioA = Math.sin((1 - t) * angle) * sinTotal;\n    const ratioB = Math.sin(t * angle) * sinTotal;\n\n    return {\n        x: ratioA * left.x + ratioB * right.x,\n        y: ratioA * left.y + ratioB * right.y,\n        z: ratioA * left.z + ratioB * right.z\n    };\n}\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param v the target vector\n * @param v1 the first operand\n * @param v2 the second operand\n * @param v3 the third operand\n * @param v4 the fourth operand\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3Hermite(v: vec3, v1: rvec3, v2: rvec3, v3: rvec3, v4: rvec3, t: number)\n{\n    const factorTimes2 = t * t;\n    const factor1 = factorTimes2 * (2 * t - 3) + 1;\n    const factor2 = factorTimes2 * (t - 2) + t;\n    const factor3 = factorTimes2 * (t - 1);\n    const factor4 = factorTimes2 * (3 - 2 * t);\n\n    v.x = v1.x * factor1 + v2.x * factor2 + v3.x * factor3 + v4.x * factor4;\n    v.y = v1.y * factor1 + v2.y * factor2 + v3.y * factor3 + v4.y * factor4;\n    v.z = v1.z * factor1 + v2.z * factor2 + v3.z * factor3 + v4.z * factor4;\n    return v;\n}\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param v the target vector\n * @param v1 the first operand\n * @param v2 the second operand\n * @param v3 the third operand\n * @param v4 the fourth operand\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3Bezier(v: vec3, v1: rvec3, v2: rvec3, v3: rvec3, v4: rvec3, t: number)\n{\n    const inverseFactor = 1 - t;\n    const inverseFactorTimesTwo = inverseFactor * inverseFactor;\n    const factorTimes2 = t * t;\n    const factor1 = inverseFactorTimesTwo * inverseFactor;\n    const factor2 = 3 * t * inverseFactorTimesTwo;\n    const factor3 = 3 * factorTimes2 * inverseFactor;\n    const factor4 = factorTimes2 * t;\n\n    v.x = v1.x * factor1 + v2.x * factor2 + v3.x * factor3 + v4.x * factor4;\n    v.y = v1.y * factor1 + v2.y * factor2 + v3.y * factor3 + v4.y * factor4;\n    v.z = v1.z * factor1 + v2.z * factor2 + v3.z * factor3 + v4.z * factor4;\n    return v;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param out the target vector\n * @param m the matrix to transform with\n * @returns the target matrix\n */\nexport function vec3TransformMat4(out: vec3, v: vec3 | rvec3, m: rmat4)\n{\n    const vx = v.x,\n        vy = v.y,\n        vz = v.z;\n\n    let w = m.m03 * vx + m.m13 * vy + m.m23 * vz + m.m33;\n    if (w != 0)\n    {\n        w = 1.0 / w;\n    }\n    else\n    {\n        w = 1.0;\n    }\n\n    out.x = (m.m00 * vx + m.m10 * vy + m.m20 * vz + m.m30) / w;\n    out.y = (m.m01 * vx + m.m11 * vy + m.m21 * vz + m.m31) / w;\n    out.z = (m.m02 * vx + m.m12 * vy + m.m22 * vz + m.m32) / w;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param v the target vector\n * @param m the 3x3 matrix to transform with\n * @returns the target vector\n */\nexport function vec3TransformMat3(out: vec3, v: vec3 | rvec3, m: rmat3)\n{\n    const vx = v.x,\n        vy = v.y,\n        vz = v.z;\n\n    out.x = vx * m.m00 + vy * m.m10 + vz * m.m20,\n    out.y = vx * m.m01 + vy * m.m11 + vz * m.m21,\n    out.z = vx * m.m02 + vy * m.m12 + vz * m.m22\n    return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param out the target vector\n * @param v the vector transform\n * @param q quaternion to transform with\n * @returns the target vector\n */\nexport function vec3TransformQuat(out: vec3, v: vec3 | rvec3, q: rquat)\n{\n    if (q.x === 0 && q.y === 0 && q.z === 0 && q.w === 1)\n    {\n        out.x = v.x;\n        out.y = v.y;\n        out.z = v.z;\n        return out;\n    }\n\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n    const x = v.x,\n        y = v.y,\n        z = v.z;\n\n    const w2 = q.w * 2;\n    let uvx = q.y * z - q.z * y,\n        uvy = q.z * x - q.x * z,\n        uvz = q.x * y - q.y * x;\n\n    const uuvx = (q.y * uvz - q.z * uvy) * 2,\n        uuvy = (q.z * uvx - q.x * uvz) * 2,\n        uuvz = (q.x * uvy - q.y * uvx) * 2;\n\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n\n    // return vec3.add(out, a, vec3.add(out, uv, uuv));\n    out.x = x + uvx + uuvx;\n    out.y = y + uvy + uuvy;\n    out.z = z + uvz + uuvz;\n    return out;\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} origin The origin of the rotation\n * @param {number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n/*\nexport function vec3RotateX(out: vec3, v: vec3 | rvec3, origin: rvec3, rad: number)\n{\n    //Translate point to the origin\n    const px = v.x - origin.x,\n        py = v.y - origin.y,\n        pz = v.z - origin.z;\n\n    const srad = Math.sin(rad),\n        crad = Math.cos(rad);\n\n    //perform rotation\n    //rx = px;\n    const ry = py * crad - pz * srad,\n        rz = py * srad + pz * crad;\n\n    //translate to correct position\n    out.x = px + origin.x;\n    out.y = ry + origin.y;\n    out.z = rz + origin.z;\n    return out;\n}\n    */\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     * @param {vec3} origin The origin of the rotation\n     * @param {number} rad The angle of rotation in radians\n     * @returns {vec3} out\n     */\n    /*\n    rotateY(origin: vec3, rad: number) {\n        const data = this.data;\n        const b = origin.data;\n        let p = ,\n            r = [];\n        //Translate point to the origin\n        p[0] = data[0] - b[0];\n        p[1] = data[1] - b[1];\n        p[2] = data[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n\n        //translate to correct position\n\n        return this.set(r[0] + b[0], r[1] + b[1], r[2] + b[2]);\n    }\n        */\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     * @param {vec3} origin The origin of the rotation\n     * @param {number} rad The angle of rotation in radians\n     * @returns {vec3} out\n     */\n    /*\n    rotateZ(origin: vec3, rad: number) {\n        const data = this.data;\n        const b = origin.data;\n        let p = [],\n            r = [];\n        //Translate point to the origin\n        p[0] = data[0] - b[0];\n        p[1] = data[1] - b[1];\n        p[2] = data[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n        r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n        r[2] = p[2];\n\n        //translate to correct position\n\n        return this.set(r[0] + b[0], r[1] + b[1], r[2] + b[2]);\n    }\n        */\n\n    /**\n     * Get the angle between two 3D vectors\n     * @param {vec3} vector The second operand\n     * @returns {number} The angle in radians\n     */\n    /*\n    angle(vector: vec3) {\n        const data = this.data;\n        const b = vector.data;\n        let ax = data[0],\n            ay = data[1],\n            az = data[2],\n            bx = b[0],\n            by = b[1],\n            bz = b[2],\n            mag = Math.sqrt(\n                (ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)\n            ),\n            cosine = mag && this.dot(vector) / mag;\n        return Math.acos(Math.min(Math.max(cosine, -1), 1));\n    }\n        */\n\n/**\n * Creates a zero vector\n */\nexport function vec3Zero(): vec3\n{\n    return {x: 0, y: 0, z: 0}\n}\n\n/**\n * Creates a zero vector\n */\nexport function vec3One(): vec3\n{\n    return {x: 1, y: 1, z: 1}\n}\n\nexport function vec3Abs(v: rvec3): vec3\n{\n    return {\n        x: Math.abs(v.x),\n        y: Math.abs(v.y),\n        z: Math.abs(v.z),\n    }\n}\n\nexport function vec3Max(v: rvec3, s: number): vec3\n{\n    return {\n        x: Math.max(v.x, s),\n        y: Math.max(v.y, s),\n        z: Math.max(v.z, s),\n    }\n}\n\nexport function vec3Min(v: rvec3, s: number): vec3\n{\n    return {\n        x: Math.min(v.x, s),\n        y: Math.min(v.y, s),\n        z: Math.min(v.z, s),\n    }\n}\n\nexport function vec3ApproxEquals(left: rvec3, right: rvec3, delta: number = 0.0001)\n{\n    // Checked if doing a Math.abs check on the diff of each element was faster or not\n    // https://jsperf.app/nukupa\n    // Looked like using the distance was faster in general.\n    return vec3Distance(left, right) < delta;\n}", "export interface vec4\n{\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\nexport type rvec4 = Readonly<vec4>;\n\n/**\n * Clones this vector\n *\n * @param v the vector to clone\n * @returns a new vector\n */\nexport function vec4Clone(v: rvec4): vec4\n{\n    return {x: v.x, y: v.y, z: v.z, w: v.w};\n}\n\n/**\n * Copy the values from one vec4 to another\n * @param v the target vector\n * @param a the copy vector\n * @returns the target vector\n */\nexport function vec4Copy(v: vec4, a: rvec4)\n{\n    v.x = a.x;\n    v.y = a.y;\n    v.z = a.z;\n    v.w = a.w;\n    return v;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param v the target vector\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @param w W component\n * @returns the target vector\n */\nexport function vec4Set(v: vec4, x: number, y: number, z: number, w: number)\n{\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    v.w = w;\n    return v;\n}\n\n/**\n * Calculates the length vector v\n *\n * @params the source vector\n * @returns length of v\n */\nexport function vec4Length(v: rvec4)\n{\n    return Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2 + v.w ** 2);\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @params the source vector\n * @returns squared length of v\n */\nexport function vec4SquaredLength(v: rvec4)\n{\n    return v.x ** 2 + v.y ** 2 + v.z ** 2 + v.w ** 2;\n}\n\n/**\n * Adds vector other into vec\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec4AddTo(left: vec4, right: rvec4)\n{\n    left.x += right.x;\n    left.y += right.y;\n    left.z += right.z;\n    left.w += right.w;\n    return left;\n}\n\n/**\n * Adds two vectors into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Add(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n        w: left.w + right.w\n    }\n}\n\n/**\n * Subtracts vector other from vector vec\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function vec4SubFrom(left: vec4, right: rvec4)\n{\n    left.x -= right.x;\n    left.y -= right.y;\n    left.z -= right.z;\n    left.w -= right.w;\n    return left;\n}\n\n/**\n * Subtracts vector other from vector vec into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Sub(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n        w: left.w - right.w,\n    }\n}\n\n/**\n * Multiplies the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function vec4MulTo(left: vec4, right: rvec4)\n{\n    left.x *= right.x;\n    left.y *= right.y;\n    left.z *= right.z;\n    left.w *= right.w;\n    return left;\n}\n\n/**\n * Multiplies the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Mul(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x * right.x,\n        y: left.y * right.y,\n        z: left.z * right.z,\n        w: left.w * right.w,\n    }\n}\n\n/**\n * Divides the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4DivBy(vec: vec4, other: rvec4)\n{\n    vec.x /= other.x;\n    vec.y /= other.y;\n    vec.z /= other.z;\n    vec.w /= other.w;\n    return vec;\n}\n\n/**\n * Divides the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Div(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x / right.x,\n        y: left.y / right.y,\n        z: left.z / right.z,\n        w: left.w / right.w,\n    }\n}\n\n/**\n * Scales the target vector by a scalar number\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns the target vector\n */\nexport function vec4ScaleBy(v: vec4, scale: number)\n{\n    v.x *= scale;\n    v.y *= scale;\n    v.z *= scale;\n    v.w *= scale;\n    return v;\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec4Scale(v: rvec4, scale: number): vec4\n{\n    return {\n        x: v.x * scale,\n        y: v.y * scale,\n        z: v.z * scale,\n        w: v.w * scale\n    };\n}\n\n/**\n * Calculates the Euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns distance between left and right\n */\nexport function vec4Distance(left: rvec4, right: rvec4)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    const dw = left.w - right.w;\n    return Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2 + dw ** 2);\n}\n\n/**\n * Calculates the squared euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns squery distance between left and right\n */\nexport function vec4SquaredDistance(left: rvec4, right: rvec4)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    const dw = left.w - right.w;\n    return dx ** 2 + dy ** 2 + dz ** 2 + dw ** 2;\n}\n\n/**\n * Negates the components of vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec4Negate(v: vec4)\n{\n    v.x = -v.x;\n    v.y = -v.y;\n    v.z = -v.z;\n    v.w = -v.w;\n    return v;\n}\n\n/**\n * Negates the components of vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec4Negated(v: rvec4): vec4\n{\n    return {\n        x: -v.x,\n        y: -v.y,\n        z: -v.z,\n        w: -v.w\n    }\n}\n\n/**\n * Inverse of the components of a vector\n *\n * @params v the target vector\n * @returns the target vector\n */\nexport function vec4Inverse(v: vec4)\n{\n    v.x = 1.0 / v.x;\n    v.y = 1.0 / v.y;\n    v.z = 1.0 / v.z;\n    v.w = 1.0 / v.w;\n    return v;\n}\n\n/**\n * Returns the inverse of the components of a vector into a new vector\n *\n * @params v the target vector\n * @returns a new vector\n */\nexport function vec4Inversed(v: rvec4): vec4\n{\n    return {\n        x: 1.0 / v.x,\n        y: 1.0 / v.y,\n        z: 1.0 / v.z,\n        w: 1.0 / v.w\n    };\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec4Normalize(v: vec4)\n{\n    let sqrtLen = vec4SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x *= sqrtLen;\n    v.y *= sqrtLen;\n    v.z *= sqrtLen;\n    v.w *= sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec4Normalized(v: rvec4): vec4\n{\n    let sqrtLen = vec4SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen,\n        w: v.w * sqrtLen\n    }\n}\n\n/**\n * Calculates the dot product of two vec4's\n * @param left the left vector\n * @param right the right vector\n * @returns dot product of left and right\n */\nexport function vec4Dot(left: rvec4, right: rvec4)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n}\n\n\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param v1 the first vector\n * @param v2 the second vector\n * @param v3 the third vector\n * @returns a new vector\n */\nexport function vec4Cross(v1: rvec4, v2: rvec4, v3: rvec4): vec4\n{\n    const A = v2.x * v3.y - v2.y * v3.x,\n      B = v2.x * v3.z - v2.z * v3.x,\n      C = v2.x * v3.w - v2.w * v3.x,\n      D = v2.y * v3.z - v2.z * v3.y,\n      E = v2.y * v3.w - v2.w * v3.y,\n      F = v2.z * v3.w - v2.w * v3.z;\n    const G = v1.x;\n    const H = v1.y;\n    const I = v1.z;\n    const J = v1.w;\n\n    return {\n      x: H * F - I * E + J * D,\n      y: -(G * F) + I * C - J * B,\n      z: G * E - H * C + J * A,\n      w: -(G * D) + H * B - I * A\n    };\n}\n\n/**\n * Performs a linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs (not clamped)\n * @returns a new vector\n */\nexport function vec4Lerp(left: rvec4, right: rvec4, t: number): vec4\n{\n    return {\n        x: left.x + t * (right.x - left.x),\n        y: left.y + t * (right.y - left.y),\n        z: left.z + t * (right.z - left.z),\n        w: left.w + t * (right.w - left.w)\n    };\n}\n\n\n  /**\n   * Transforms the vec4 with a mat4.\n   * @param {mat4} matrix matrix to transform with\n   * @returns {vec4} out\n   */\n  /*\n  transformMat4(matrix: mat4) {\n    const { data: out, data: a } = this;\n    const m = matrix.data;\n    let x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return this;\n  }\n    */\n\n  /**\n   * Transforms the vec4 with a quat\n   * @param {ReadonlyQuat} rotation quaternion to transform with\n   * @returns {vec4} out\n   */\n  /*\n  transformQuat(rotation: quat) {\n    const { data: out, data: a } = this;\n    const q = rotation.data;\n    let x = a[0],\n      y = a[1],\n      z = a[2];\n    let qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n\n    // calculate quat * vec\n    let ix = qw * x + qy * z - qz * y;\n    let iy = qw * y + qz * x - qx * z;\n    let iz = qw * z + qx * y - qy * x;\n    let iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    out[3] = a[3];\n    return this;\n  }*/\n\n/**\n * Creates a zero vector\n */\nexport function vec4Zero(): vec4\n{\n    return {x: 0, y: 0, z: 0, w: 0}\n}\n\nexport function vec4One(): vec4\n{\n    return {x: 1, y: 1, z: 1, w: 1}\n}\n\nexport function vec4ApproxEquals(left: rvec4, right: rvec4, delta: number = 0.0001)\n{\n    // Checked if doing a Math.abs check on the diff of each element was faster or not\n    // https://jsperf.app/nukupa\n    // Looked like using the distance was faster in general.\n    return vec4Distance(left, right) < delta;\n}", "import mathf, { AngleOrder } from \"./mathf\";\nimport { rvec3, vec3, vec3Cross, vec3CrossBy, vec3Dot, vec3Normalize, vec3SquaredLength } from \"./vec3\";\n\nexport interface quat\n{\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\nexport type rquat = Readonly<quat>;\n\nexport function quatIdentity(): quat\n{\n    return {x: 0, y: 0, z: 0, w: 1}\n}\n\n/**\n * Clones this quat\n *\n * @param v the quat to clone\n * @returns a new quat\n */\nexport function quatClone(v: rquat): quat\n{\n    return {x: v.x, y: v.y, z: v.z, w: v.w};\n}\n\n/**\n * Calculates the length quat q\n *\n * @params the source quat\n * @returns length of q\n */\nexport function quatLength(q: rquat)\n{\n    return Math.sqrt(q.x ** 2 + q.y ** 2 + q.z ** 2 + q.w ** 2);\n}\n\n/**\n * Calculates the squared length of a quat\n *\n * @params the source quat\n * @returns squared length of q\n */\nexport function quatSquaredLength(q: rquat)\n{\n    return q.x ** 2 + q.y ** 2 + q.z ** 2 + q.w ** 2;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis, then returns it.\n * @param q the target quat\n * @param axis the axis around which to rotate\n * @param rad the angle in radians\n * @returns the target quat\n */\nexport function quatSetAxisAngle(q: quat, axis: rvec3, rad: number)\n{\n    rad = rad * 0.5;\n    const s = Math.sin(rad);\n\n    q.x = s * axis.x;\n    q.y = s * axis.y;\n    q.z = s * axis.z;\n    q.w = Math.cos(rad);\n    return q\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as provided in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param out Vector receiving the axis of rotation\n * @param q Quaternion to be decomposed\n * @return Angle, in radians, of the rotation\n */\nexport function quatGetAxisAngle(out: vec3, q: rquat)\n{\n    const rad = Math.acos(q.w) * 2.0;\n    const s = Math.sin(rad / 2.0);\n\n    if (s > mathf.EPSILON)\n    {\n      out.x = q.x / s;\n      out.y = q.y / s;\n      out.z = q.z / s;\n    }\n    else\n    {\n      // If s is zero, return any axis (no rotation - axis does not matter)\n      out.x = 1;\n      out.y = 0;\n      out.z = 0;\n    }\n    return rad;\n}\n\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param left the left quat\n * @param right the right quat\n * @return Angle, in radians, between the two quaternions\n */\nexport function quatGetAngle(left: rquat, right: rquat)\n{\n    const dot = quatDot(left, right);\n    return Math.acos(2 * dot * dot - 1);\n}\n\n/**\n * Calculates the dot product of two quat's\n * @param left the left quat\n * @param right the right quat\n * @returns dot product of left and right\n */\nexport function quatDot(left: rquat, right: rquat)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n}\n\n  /**\n * Set the components of a quat to the given values\n *\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @param w W component\n * @returns the target quat\n */\nexport function quatSet(q: quat, x: number, y: number, z: number, w: number)\n{\n    q.x = x;\n    q.y = y;\n    q.z = z;\n    q.w = w;\n    return q;\n}\n\n/**\n * Multiplies the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function quatMulTo(left: quat, right: rquat)\n{\n    const ax = left.x,\n      ay = left.y,\n      az = left.z,\n      aw = left.w;\n    const bx = right.x,\n      by = right.y,\n      bz = right.z,\n      bw = right.w;\n\n    left.x = ax * bw + aw * bx + ay * bz - az * by;\n    left.y = ay * bw + aw * by + az * bx - ax * bz;\n    left.z = az * bw + aw * bz + ax * by - ay * bx;\n    left.w = aw * bw - ax * bx - ay * by - az * bz;\n\n    return left;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function quatRotateX(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const bx = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw + aw * bx;\n    q.y = ay * bw + az * bx;\n    q.z = az * bw - ay * bx;\n    q.w = aw * bw - ax * bx;\n    return q;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function quatRotateY(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const by = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw - az * by;\n    q.y = ay * bw + aw * by;\n    q.z = az * bw + ax * by;\n    q.w = aw * bw - ay * by;\n    return q;\n}\n\n  /**\n   * Rotates a quaternion by the given angle about the Z axis\n   *\n   * @param {quat} out quat receiving operation result\n   * @param {quat} a quat to rotate\n   * @param {number} rad angle (in radians) to rotate\n   * @returns {quat} out\n   */\nexport function quatRotateZ(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const bz = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw + ay * bz;\n    q.y = ay * bw - ax * bz;\n    q.z = az * bw + aw * bz;\n    q.w = aw * bw - az * bz;\n    return q;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @returns a new quat\n */\nexport function quatCalculateW(q: rquat): quat\n{\n    return {\n      x: q.x,\n      y: q.y,\n      z: q.z,\n      w: Math.sqrt(Math.abs(1.0 - q.x * q.x - q.y * q.y - q.z * q.z))\n    };\n}\n\n/**\n * Adds vector other into vec\n * @param left the left quat\n * @param right the right quat\n * @returns the target quat\n */\nexport function quatAddTo(left: quat, right: rquat)\n{\n    left.x += right.x;\n    left.y += right.y;\n    left.z += right.z;\n    left.w += right.w;\n    return left;\n}\n\n/**\n * Adds two vectors into a new quat\n * @param left the left quat\n * @param right the right quat\n * @returns a new quat\n */\nexport function quatAdd(left: rquat, right: rquat): quat\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n        w: left.w + right.w\n    }\n}\n\n/**\n * Subtracts quat other from quat vec\n * @param left the left quat\n * @param right the right quat\n * @returns the left quat\n */\nexport function quatSubFrom(left: quat, right: rquat)\n{\n    left.x -= right.x;\n    left.y -= right.y;\n    left.z -= right.z;\n    left.w -= right.w;\n    return left;\n}\n\n/**\n * Subtracts quat other from quat vec into a new quat\n * @param left the left quat\n * @param right the right quat\n * @returns a new quat\n */\nexport function quatSub(left: rquat, right: rquat): quat\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n        w: left.w - right.w,\n    }\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n * @param {quat} q the second operand\n * @param {number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function quatSlerp(left: rquat, right: rquat, t: number): quat\n{\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n    const ax = left.x,\n      ay = left.y,\n      az = left.z,\n      aw = left.w;\n    let bx = right.x,\n      by = right.y,\n      bz = right.z,\n      bw = right.w;\n\n    let omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    }\n\n    // calculate coefficients\n    if (1.0 - cosom > mathf.EPSILON)\n    {\n      // standard case (slerp)\n      omega = Math.acos(cosom);\n      sinom = Math.sin(omega);\n      scale0 = Math.sin((1.0 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    }\n    else\n    {\n      // \"from\" and \"to\" quaternions are very close\n      //  ... so we can do a linear interpolation\n      scale0 = 1.0 - t;\n      scale1 = t;\n    }\n    // calculate final values\n    return {\n      x: scale0 * ax + scale1 * bx,\n      y: scale0 * ay + scale1 * by,\n      z: scale0 * az + scale1 * bz,\n      w: scale0 * aw + scale1 * bw\n    };\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @returns {quat} out\n */\nexport function quatInvert(q: quat)\n{\n    const a0 = q.x,\n      a1 = q.y,\n      a2 = q.z,\n      a3 = q.w;\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1.0 / dot : 0;\n\n    q.x = -a0 * invDot;\n    q.y = -a1 * invDot;\n    q.z = -a2 * invDot;\n    q.w = a3 * invDot;\n    return q;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @returns {quat} out\n */\nexport function quatInverted(q: rquat): quat\n{\n    const a0 = q.x,\n      a1 = q.y,\n      a2 = q.z,\n      a3 = q.w;\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1.0 / dot : 0;\n\n    return {\n      x: -a0 * invDot,\n      y: -a1 * invDot,\n      z: -a2 * invDot,\n      w: a3 * invDot\n    };\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n * @returns {quat} out\n */\nexport function quatConjugate(q: quat)\n{\n    q.x = -q.x;\n    q.y = -q.y;\n    q.z = -q.z;\n    q.w = q.w;\n    return q;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n * @returns {quat} out\n */\nexport function quatConjugated(q: rquat): quat\n{\n    return {\n        x: -q.x,\n        y: -q.y,\n        z: -q.z,\n        w: -q.w\n    }\n}\n\n  /**\n   * Creates a quaternion from the given 3x3 rotation matrix.\n   *\n   * NOTE: The resultant quaternion is not normalized, so you should be sure\n   * to renormalize the quaternion yourself where necessary.\n   * @param {mat3} matrix rotation matrix\n   * @returns {quat} out\n   * @function\n   */\n  /*\n  fromMat3(matrix: mat3) {\n    const data=this.data\n    const m=matrix.data;\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    let fTrace = m[0] + m[4] + m[8];\n    let fRoot;\n\n    if (fTrace > 0.0) {\n      // |w| > 1/2, may as well choose w > 1/2\n      fRoot = Math.sqrt(fTrace + 1.0); // 2w\n      data[3] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot; // 1/(4w)\n      data[0] = (m[5] - m[7]) * fRoot;\n      data[1] = (m[6] - m[2]) * fRoot;\n      data[2] = (m[1] - m[3]) * fRoot;\n    } else {\n      // |w| <= 1/2\n      let i = 0;\n      if (m[4] > m[0]) i = 1;\n      if (m[8] > m[i * 3 + i]) i = 2;\n      let j = (i + 1) % 3;\n      let k = (i + 2) % 3;\n\n      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n      data[i] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot;\n      data[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n      data[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n      data[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n    return this;\n  }\n    */\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @params q the target quat\n * @param x Angle to rotate around X axis in degrees.\n * @param y Angle to rotate around Y axis in degrees.\n * @param z Angle to rotate around Z axis in degrees.\n * @param order Intrinsic order for conversion, default is zyx.\n * @returns the target quat\n */\nexport function quatFromEuler(q: quat, x: number, y: number, z: number, order: AngleOrder = mathf.ANGLE_ORDER)\n{\n    const halfToRad = Math.PI / 360;\n    x *= halfToRad;\n    z *= halfToRad;\n    y *= halfToRad;\n\n    const sx = Math.sin(x);\n    const cx = Math.cos(x);\n    const sy = Math.sin(y);\n    const cy = Math.cos(y);\n    const sz = Math.sin(z);\n    const cz = Math.cos(z);\n\n    switch (order) {\n      case \"xyz\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"xzy\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      case \"yxz\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      case \"yzx\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"zxy\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"zyx\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      default:\n        throw new Error('Unknown angle order ' + order);\n    }\n\n    return this;\n}\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nexport function quatRotationTo(q: quat, a: rvec3, right: rvec3)\n{\n    const dot = vec3Dot(a, right);\n    if (dot < -0.999999)\n    {\n        const xUnit = {x: 1, y: 0, z: 0};\n        let tmpVec3 = vec3CrossBy(xUnit, xUnit, a);\n        if (vec3SquaredLength(tmpVec3) < mathf.EPSILON)\n        {\n            const yUnit = {x: 0, y: 1, z : 0};\n            tmpVec3 = vec3CrossBy(yUnit, yUnit, a);\n        }\n\n        vec3Normalize(tmpVec3, tmpVec3);\n\n        quatSetAxisAngle(q, tmpVec3, Math.PI);\n        return q;\n    }\n    else if (dot > 0.999999)\n    {\n        q.x = 0;\n        q.y = 0;\n        q.z = 0;\n        q.w = 1;\n        return this;\n    }\n    else\n    {\n        const tmpVec3 = vec3Cross(a, right);\n        q.x = tmpVec3.x;\n        q.y = tmpVec3.y;\n        q.z = tmpVec3.z;\n        q.w = 1 + dot;\n        return quatNormalize(q);\n    }\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function quatNormalize(v: quat)\n{\n    let sqrtLen = quatSquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x *= sqrtLen;\n    v.y *= sqrtLen;\n    v.z *= sqrtLen;\n    v.w *= sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function quatNormalized(v: rquat): quat\n{\n    let sqrtLen = quatSquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen,\n        w: v.w * sqrtLen\n    }\n}\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} b the second operand\n * @param {quat} c the third operand\n * @param {quat} d the fourth operand\n * @param {number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function quatSQlerp(a: rquat, b: rquat, c: rquat, d: rquat, t: number)\n{\n    const temp1 = quatSlerp(a, d, t);\n    const temp2 = quatSlerp(b, c, t);\n    return quatSlerp(temp1, temp2, 2 * t * (1 - t));\n};\n\n  /**\n   * Sets the specified quaternion with values corresponding to the given\n   * axes. Each axis is a vec3 and is expected to be unit length and\n   * perpendicular to all other specified axes.\n   *\n   * @param {vec3} view  the vector representing the viewing direction\n   * @param {vec3} right the vector representing the local \"right\" direction\n   * @param {vec3} up    the vector representing the local \"up\" direction\n   * @returns {quat} out\n   */\n//   export function quatSetAxes(view: vec3, right: vec3, up: vec3) {\n//     let _matrix = new mat3();\n//     const { data: matr } = _matrix;\n//     const { data: r } = right;\n//     const { data: v } = view;\n//     const { data: u } = up;\n//     matr[0] = r[0];\n//     matr[3] = r[1];\n//     matr[6] = r[2];\n\n//     matr[1] = u[0];\n//     matr[4] = u[1];\n//     matr[7] = u[2];\n\n//     matr[2] = -v[0];\n//     matr[5] = -v[1];\n//     matr[8] = -v[2];\n//     return this.fromMat3(_matrix).normalize();\n//   }", "// @ts-ignore These are handled by esbuild\nimport vertText from \"../shaders/vert.glsl\";\n// @ts-ignore\nimport fragText from \"../shaders/frag.glsl\";\n// @ts-ignore\nimport sdfFunctionsText from \"../shaders/sdf-functions.glsl\";\n\nimport Shader from \"../shaders/shader\";\nimport { SceneConverter } from \"../ray-marching/scene-converter\";\nimport { quatFromEuler, quatIdentity, rquat, vec3, vec3ScaleAndAddBy, vec3TransformQuat, vec3Zero } from \"../gl-matrix-ts\";\n\nconst positions = [\n    -1, -1,\n    1, -1,\n    1, 1,\n\n    -1, -1,\n    1, 1,\n    -1, 1\n];\n\nconst tempAxisQuat = quatIdentity();\nfunction mat3ArraySetFromQuat(m: Float32Array, q: rquat)\n{\n    const x2 = q.x + q.x;\n    const y2 = q.y + q.y;\n    const z2 = q.z + q.z;\n\n    const xx = q.x * x2;\n    const yx = q.y * x2;\n    const yy = q.y * y2;\n    const zx = q.z * x2;\n    const zy = q.z * y2;\n    const zz = q.z * z2;\n    const wx = q.w * x2;\n    const wy = q.w * y2;\n    const wz = q.w * z2;\n\n    m[0] = 1 - yy - zz;\n    m[1] = yx - wz;\n    m[2] = zx + wy;\n\n    m[3] = yx + wz;\n    m[4] = 1 - xx - zz;\n    m[5] = zy - wx;\n\n    m[6] = zx - wy;\n    m[7] = zy + wx;\n    m[8] = 1 - xx - yy;\n\n    return m;\n}\n\nexport default class WebGLSdfRenderer\n{\n    public readonly gl: WebGL2RenderingContext;\n    public readonly shader:Shader;\n    public readonly positionBuffer: WebGLBuffer;\n\n    public readonly uShapes: WebGLUniformLocation;\n    public readonly uOperations: WebGLUniformLocation;\n    public readonly uNumOperations: WebGLUniformLocation;\n    public readonly uHighlight: WebGLUniformLocation;\n\n    public readonly uMaterials: WebGLUniformLocation;\n\n    public readonly uLights: WebGLUniformLocation;\n    public readonly uNumLights: WebGLUniformLocation;\n\n    public readonly uCameraPosition: WebGLUniformLocation;\n    public readonly uCameraMatrix: WebGLUniformLocation;\n\n    public readonly uAspectRatio: WebGLUniformLocation;\n\n    public readonly uMaxMarchingSteps: WebGLUniformLocation;\n    public readonly uEpsilon: WebGLUniformLocation;\n    public readonly uFlags: WebGLUniformLocation;\n\n    public cameraPosition: vec3 = vec3Zero();\n    public cameraTarget: vec3 = vec3Zero();\n    public cameraRotationX = 0;\n    public cameraRotationY = 0;\n    public cameraDistance = 10;\n\n    public maxMarchingSteps = 255;\n    public epsilon = 0.001;\n\n    public enableShadows = true;\n    public enableShowMarches = false;\n\n    public canvasScale = 1;\n\n    private readonly cameraMatrixArray = new Float32Array(9);\n\n    private prevShapes: any;\n    private prevOperations: any;\n    private prevMaterials: any;\n    private prevLights: any;\n\n    constructor(gl: WebGL2RenderingContext,\n        shader: Shader,\n        positionBuffer: WebGLBuffer,\n        uShapes: WebGLUniformLocation,\n        uOperations: WebGLUniformLocation,\n        uNumOperations: WebGLUniformLocation,\n        uHighlight: WebGLUniformLocation,\n        uLights: WebGLUniformLocation,\n        uNumLights: WebGLUniformLocation,\n        uMaterials: WebGLUniformLocation,\n        uCameraPosition: WebGLUniformLocation,\n        uCameraMatrix: WebGLUniformLocation,\n        uAspectRatio: WebGLUniformLocation,\n        uMaxMarchingSteps: WebGLUniformLocation,\n        uEpsilon: WebGLUniformLocation,\n        uFlags: WebGLUniformLocation,\n    )\n    {\n        this.gl = gl;\n        this.shader = shader;\n        this.positionBuffer = positionBuffer;\n\n        this.uShapes = uShapes;\n\n        this.uOperations = uOperations;\n        this.uNumOperations = uNumOperations;\n        this.uHighlight = uHighlight;\n\n        this.uMaterials = uMaterials;\n\n        this.uLights = uLights;\n        this.uNumLights = uNumLights;\n\n        this.uCameraPosition = uCameraPosition;\n        this.uCameraMatrix = uCameraMatrix;\n        this.uAspectRatio = uAspectRatio;\n\n        this.uMaxMarchingSteps = uMaxMarchingSteps;\n        this.uEpsilon = uEpsilon;\n        this.uFlags = uFlags;\n    }\n\n    public setupCanvas()\n    {\n        // Firefox doesn't like having the canvas rendered to until something has happened, like a fillRect\n        this.gl.clearColor(0, 0, 0, 0);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    }\n\n    public orbitCamera(horizontal: number, vertical: number)\n    {\n        this.cameraRotationX += horizontal;\n        this.cameraRotationY += vertical;\n\n        this.updateCamera();\n    }\n\n    public updateCamera()\n    {\n        quatFromEuler(tempAxisQuat, this.cameraRotationX, this.cameraRotationY, 0);\n        const forward = vec3TransformQuat(vec3Zero(), {x: 0, y: 0, z: 1}, tempAxisQuat);\n\n        vec3ScaleAndAddBy(this.cameraPosition, this.cameraTarget, forward, this.cameraDistance);\n        mat3ArraySetFromQuat(this.cameraMatrixArray, tempAxisQuat);\n    }\n\n    public resizeCanvas = (width: number, height: number) =>\n    {\n        const scaledWidth = width * this.canvasScale;\n        const scaledHeight = height * this.canvasScale;\n        this.gl.canvas.width = scaledWidth;\n        this.gl.canvas.height = scaledHeight;\n\n        this.gl.viewport(0, 0, scaledWidth, scaledHeight);\n\n        const aspectRatio = scaledWidth / scaledHeight;\n        this.gl.uniform1f(this.uAspectRatio, aspectRatio);\n    }\n\n    public render(scene: SceneConverter)\n    {\n        if (this.prevLights !== scene.getLights())\n        {\n            console.info('Rendering new lights');\n            this.gl.uniformMatrix2x4fv(this.uLights, false, scene.getLightDataArray());\n            this.gl.uniform1i(this.uNumLights, scene.getNumLights());\n            this.prevLights = scene.getLights();\n        }\n\n        if (this.prevOperations !== scene.getOperations())\n        {\n            console.info('Rendering new operations');\n            const ops = scene.getOperationNumbers();\n            this.gl.uniform1i(this.uNumOperations, ops.length);\n            this.gl.uniform1iv(this.uOperations, ops);\n            this.gl.uniform2iv(this.uHighlight, [0, 1]);\n            this.prevOperations = scene.getOperations();\n        }\n\n        if (this.prevShapes !== scene.getShapes())\n        {\n            console.info('Rendering new shapes');\n            this.gl.uniformMatrix4fv(this.uShapes, false, scene.getShapeDataArray());\n            this.prevShapes = scene.getShapes();\n        }\n\n        if (this.prevMaterials !== scene.getMaterials())\n        {\n            this.prevMaterials = scene.getMaterials();\n            console.info('Rendering new materials', this.prevMaterials);\n            this.gl.uniformMatrix2x4fv(this.uMaterials, false, scene.getMaterialDataArray());\n        }\n\n        this.gl.uniform4i(this.uFlags, this.enableShadows ? 1 : 0, this.enableShowMarches ? 1 : 0, 0, 0);\n        this.gl.uniform1f(this.uEpsilon, this.epsilon);\n        this.gl.uniform1i(this.uMaxMarchingSteps, this.maxMarchingSteps);\n\n        this.gl.uniform3f(\n            this.uCameraPosition,\n            this.cameraPosition.x,\n            this.cameraPosition.y,\n            this.cameraPosition.z\n        );\n        this.gl.uniformMatrix3fv(this.uCameraMatrix, true, this.cameraMatrixArray);\n\n        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    }\n\n    public static create(canvas: HTMLCanvasElement): WebGLSdfRenderer\n    {\n        const gl = canvas.getContext('webgl2');\n        if (gl == null)\n        {\n            throw new Error('Unable to get webgl2 context');\n        }\n\n        const positionBuffer = gl.createBuffer();\n        if (positionBuffer == null)\n        {\n            throw new Error('Unable to create position buffer');\n        }\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n        const includeLookup = {\n            'sdf-functions': sdfFunctionsText\n        }\n\n        const shader = Shader.create(gl, includeLookup, vertText, fragText);\n        gl.useProgram(shader.program);\n\n        const positionAttributeLoc = this.getAttribute(gl, shader, 'aPosition');\n        gl.enableVertexAttribArray(positionAttributeLoc);\n        gl.vertexAttribPointer(positionAttributeLoc, 2, gl.FLOAT, false, 0, 0);\n\n        const uCameraMatrix = this.getUniform(gl, shader, 'uCameraMatrix');\n        const uCameraPosition = this.getUniform(gl, shader, 'uCameraPosition');\n        const uAspectRatio = this.getUniform(gl, shader, 'uAspectRatio');\n\n        const uShapes = this.getUniform(gl, shader, 'uShapes');\n        const uOperations = this.getUniform(gl, shader, 'uOperations');\n        const uNumOperations = this.getUniform(gl, shader, 'uNumOperations');\n        const uHighlight = this.getUniform(gl, shader, 'uHighlight');\n\n        const uMaterials = this.getUniform(gl, shader, 'uMaterials');\n\n        const uLights = this.getUniform(gl, shader, 'uLights');\n        const uNumLights = this.getUniform(gl, shader, 'uNumLights');\n\n        const uMaxMarchingSteps = this.getUniform(gl, shader, 'uMaxMarchingSteps');\n        const uEpsilon = this.getUniform(gl, shader, 'uEpsilon');\n        const uFlags = this.getUniform(gl, shader, 'uFlags');\n\n        return new WebGLSdfRenderer(gl, shader, positionBuffer,\n            uShapes, uOperations, uNumOperations, uHighlight,\n            uLights, uNumLights,\n            uMaterials,\n            uCameraPosition, uCameraMatrix, uAspectRatio,\n            uMaxMarchingSteps, uEpsilon, uFlags);\n    }\n\n    private static getAttribute(gl: WebGL2RenderingContext, shader: Shader, name: string)\n    {\n        const attribute = gl.getAttribLocation(shader.program, name);\n        if (attribute < 0)\n        {\n            throw new Error(`Unable to find attribute ${name}`);\n        }\n        return attribute;\n    }\n\n    private static getUniform(gl: WebGL2RenderingContext, shader: Shader, name: string)\n    {\n        const location = gl.getUniformLocation(shader.program, name);\n        if (location == null)\n        {\n            throw new Error(`Unable to find uniform ${name}`);\n        }\n        return location;\n    }\n}", "import DataStore from \"simple-data-store\";\nimport { AppState, ViewportOptions, ViewportState } from \"./store-state\";\n\nexport const defaultRenderOptions: ViewportOptions = {\n    renderScale: 1.0,\n    maxMarchingStep: 255,\n    enableShadows: true,\n    enableShowMarching: false,\n    epsilon: 0.001,\n    pixelated: false\n}\nexport const defaultViewport: ViewportState = {\n    options: defaultRenderOptions\n}\nexport const store = new DataStore<AppState>({\n    viewports: [defaultViewport],\n    sceneTree: {\n        nodes: {}\n    },\n    reparentModal: {\n        show: false\n    },\n    rawSceneModal: {\n        show: false,\n    }\n});", "import { Opaque } from \"../common\";\nimport { rquat, rvec3, vec3, rvec4, vec4 } from \"../gl-matrix-ts\";\n\nexport type SdfOpCode = 'none' | 'union' | 'intersection' | 'subtraction' | 'xor';\nexport type SdfOpCodeInt = Opaque<number, 'sdfOpCode'>;\nexport const SdfOpCodeNone = -5e2 as SdfOpCodeInt;\nexport const SdfOpCodeUnion = -6e2 as SdfOpCodeInt;\nexport const SdfOpCodeIntersection = -7e2 as SdfOpCodeInt;\nexport const SdfOpCodeSubtraction = -8e2 as SdfOpCodeInt;\nexport const SdfOpCodeXor = -9e2 as SdfOpCodeInt;\n\nexport type ShapeType = 'none' | 'box' | 'sphere' | 'hexPrism';\nexport type ShapeTypeInt = Opaque<number, 'shapeType'>;\nexport const ShapeTypeNone = -5e3 as ShapeTypeInt;\nexport const ShapeTypeBox = -6e3 as ShapeTypeInt;\nexport const ShapeTypeSphere = -7e3 as ShapeTypeInt;\nexport const ShapeTypeHexPrism = -8e3 as ShapeTypeInt;\n\nexport type LightingModelInt = Opaque<number, 'lightingModel'>;\nexport const LightingModelUnlit = 0 as LightingModelInt;\nexport const LightingModelLambert = 1 as LightingModelInt;\nexport const LightingModelPhong = 2 as LightingModelInt;\n\nexport type SceneNodeId = Opaque<string, 'SceneNodeId'>;\nexport interface SceneNode\n{\n    readonly id: SceneNodeId;\n    readonly name: string;\n\n    readonly position: rvec3;\n    readonly rotation: rquat;\n\n    readonly shape: Shape;\n    readonly hasShape: boolean;\n    readonly childOpCode: SdfOpCode;\n    readonly childrenIds: ReadonlyArray<SceneNodeId>;\n    readonly parentId?: SceneNodeId;\n    readonly light: Light;\n    readonly hasLight: boolean;\n}\n\nexport interface Light\n{\n    readonly radius: number;\n    readonly colour: rvec4;\n}\n\nexport type LightingModelType = 'unlit' | 'lambert' | 'phong';\nexport interface Shape\n{\n    readonly maxSize: number;\n    readonly type: ShapeType;\n    readonly shapeParams: vec3;\n    readonly diffuseColour: vec3;\n    readonly specularColour: vec3;\n    readonly shininess: number;\n    readonly lightingModel: LightingModelType;\n}\n\nexport interface SceneNodes\n{\n    readonly [shapeNodeId: string /* ShapeNodeId */]: SceneNode\n}\n\nexport function makeShapeNodeId(): SceneNodeId\n{\n    return crypto.randomUUID() as SceneNodeId;\n}\n", "import { Editable } from \"../common\";\nimport { quatIdentity, rquat, rvec3, vec3Zero, vec4One } from \"../gl-matrix-ts\";\nimport { Light, makeShapeNodeId, SceneNode, SceneNodes, SdfOpCode, Shape, SceneNodeId } from \"./scene-entities\";\n\nexport interface SceneTree\n{\n    readonly nodes: SceneNodes;\n    readonly rootNodeId?: SceneNodeId;\n}\ninterface SceneNodeAtDepth\n{\n    readonly node: SceneNode;\n    readonly depth: number;\n}\n\nexport function sceneTreeUpdateNode(tree: SceneTree, node: SceneNode): SceneTree\n{\n    const newNodes = {\n        ...tree.nodes,\n        [node.id]: node\n    };\n\n    return {\n        ...tree,\n        nodes: newNodes\n    }\n}\n\nexport function sceneTreeSetRootNodeId(tree: SceneTree, rootNodeId: SceneNodeId): SceneTree\n{\n    return { ...tree, rootNodeId }\n}\n\nexport function sceneTreeSetNodes(tree: SceneTree, nodes: SceneNodes): SceneTree\n{\n    return { ...tree, nodes }\n}\n\nexport function sceneTreeFlatten(tree: SceneTree): SceneNodeAtDepth[]\n{\n    const rootNode = tree.nodes[tree.rootNodeId];\n    if (!rootNode)\n    {\n        return [];\n    }\n\n    const result = new Array<SceneNodeAtDepth>(Object.keys(tree.nodes).length);\n    addToTree(rootNode, tree.nodes, 0, 0, result);\n    return result;\n}\n\nexport function sceneTreeCreate(): SceneTree\n{\n    return { nodes: {} }\n}\n\nfunction createNewLight(light: Partial<Light>): Light\n{\n    return {\n        colour: vec4One(),\n        radius: 10,\n\n        ...light\n    }\n}\n\nexport function createSceneNode(name: string, node: Partial<SceneNode>): SceneNode\n{\n    return {\n        name,\n        id: makeShapeNodeId(),\n\n        position: vec3Zero(),\n        rotation: quatIdentity(),\n        childrenIds: [],\n        childOpCode: 'none',\n        shape: createNewShape({}),\n        hasShape: false,\n        light: createNewLight({}),\n        hasLight: false,\n\n        ...node\n    }\n}\n\nexport function createNewLightNode(name: string, light?: Partial<Light>, position?: rvec3, rotation?: rquat): SceneNode\n{\n    return {\n        name,\n        id: makeShapeNodeId(),\n        position: position ?? vec3Zero(),\n        rotation: rotation ?? quatIdentity(),\n        childrenIds: [],\n        childOpCode: 'none',\n        shape: createNewShape({}),\n        hasShape: false,\n        light: light != undefined ? createNewLight(light) : undefined,\n        hasLight: light != undefined\n    }\n}\n\nexport function createNewShapeNode(name: string, shape?: Partial<Shape>, position?: rvec3, rotation?: rquat, childOpCode?: SdfOpCode): SceneNode\n{\n    return {\n        name,\n        id: makeShapeNodeId(),\n        position: position ?? vec3Zero(),\n        rotation: rotation ?? quatIdentity(),\n        shape: shape != undefined ? createNewShape(shape) : undefined,\n        hasShape: shape != undefined,\n        light: createNewLight({}),\n        hasLight: false,\n        childrenIds: [],\n        childOpCode: childOpCode != undefined ? childOpCode : 'none'\n    }\n}\n\nexport function createNewShape(shape: Partial<Shape>): Shape\n{\n    return {\n        maxSize: 0,\n        type: \"none\",\n        shapeParams: vec3Zero(),\n        diffuseColour: { x: 0.7, y: 0.3, z: 0.2 },\n        specularColour: { x: 1.0, y: 0.8, z: 0.9 },\n        lightingModel: 'lambert',\n        shininess: 10,\n\n        ...shape\n    };\n}\n\n// Build time functions\nexport function sceneTreeAddChildMutable(parent: Editable<SceneNode>, child: Editable<SceneNode>)\n{\n    (parent.childrenIds as SceneNodeId[]).push(child.id);\n    child.parentId = parent.id;\n}\n\nexport function sceneTreeAddChild(tree: SceneTree, parent: SceneNode, child: SceneNode)\n{\n    parent = {\n        ...parent,\n        childrenIds: [...parent.childrenIds, child.id]\n    }\n\n    child = {\n        ...child,\n        parentId: parent.id\n    }\n\n    const nodes = {\n        ...tree.nodes,\n        [parent.id]: parent,\n        [child.id]: child\n    }\n\n    return { ...tree, nodes };\n}\n\nexport function sceneTreeDeleteChild(tree: SceneTree, child: SceneNode)\n{\n    if (child.parentId === undefined)\n    {\n        return tree;\n    }\n\n    let oldParent = tree.nodes[child.parentId];\n    const oldIndex = oldParent.childrenIds.findIndex(id => id === child.id);\n    if (oldIndex >= 0)\n    {\n        const childrenIds = [...oldParent.childrenIds];\n        childrenIds.splice(oldIndex, 1);\n        oldParent = { ...oldParent, childrenIds };\n\n        const nodes = {\n            ...tree.nodes,\n            [oldParent.id]: oldParent\n        }\n\n        delete nodes[child.id];\n\n        return { ...tree, nodes };\n    }\n\n    return tree;\n}\n\nexport function sceneTreeMoveChild(tree: SceneTree, newParent: SceneNode, child: SceneNode)\n{\n    if (child.parentId == undefined)\n    {\n        return tree;\n    }\n\n    let oldParent = tree.nodes[child.parentId];\n    const oldIndex = oldParent.childrenIds.findIndex(id => id === child.id);\n    if (oldIndex >= 0)\n    {\n        const childrenIds = [...oldParent.childrenIds];\n        childrenIds.splice(oldIndex, 1);\n        oldParent = { ...oldParent, childrenIds };\n    }\n\n    if (!newParent.childrenIds.includes(child.id))\n    {\n        newParent = {\n            ...newParent,\n            childrenIds: [...newParent.childrenIds, child.id],\n        };\n    }\n\n    child = { ...child, parentId: newParent.id }\n\n    const nodes = {\n        ...tree.nodes,\n        [oldParent.id]: oldParent,\n        [newParent.id]: newParent,\n        [child.id]: child\n    }\n\n    return {...tree, nodes };\n}\n\nfunction addToTree(node: SceneNode, nodes: SceneNodes, depth: number, index: number, result: SceneNodeAtDepth[])\n{\n    result[index] = {node, depth};\n    if (node.childrenIds != null)\n    {\n        for (const childId of node.childrenIds)\n        {\n            const child = nodes[childId];\n            if (child)\n            {\n                index = addToTree(child, nodes, depth + 1, index + 1, result);\n            }\n        }\n    }\n    return index;\n}", "import { Modifier } from \"simple-data-store\";\nimport { defaultViewport } from \"./store\";\nimport { SceneTree, sceneTreeUpdateNode, } from \"../ray-marching/scene-tree\";\nimport { SceneNode, SceneNodeId } from \"../ray-marching/scene-entities\";\n\nexport interface ViewportOptions\n{\n    readonly enableShadows: boolean;\n    readonly enableShowMarching: boolean;\n    readonly renderScale: number;\n    readonly maxMarchingStep: number;\n    readonly epsilon: number;\n    readonly pixelated: boolean;\n}\n\nexport interface ViewportState\n{\n    readonly options: ViewportOptions;\n}\n\nexport interface ReparentModalState\n{\n    readonly show: boolean;\n    readonly childNodeId?: SceneNodeId;\n}\nexport interface RawSceneModalState\n{\n    readonly show: boolean;\n}\n\nexport interface AppState\n{\n    readonly viewports: ViewportState[];\n    readonly sceneTree: SceneTree;\n    readonly selectedNodeId?: SceneNodeId;\n    readonly reparentModal: ReparentModalState;\n    readonly rawSceneModal: RawSceneModalState;\n}\n\nexport function setViewportOptions(index: number, options: Partial<ViewportOptions>): Modifier<AppState>\n{\n    return (state: AppState) =>\n    {\n        const viewport = state.viewports[index] ?? defaultViewport;\n        const newViewport = {\n            ...viewport,\n            options: { ...viewport.options, ...options }\n        };\n\n        const viewports = [ ...state.viewports ];\n        viewports[index] = newViewport;\n\n        return { viewports }\n    }\n}\n\nexport function setReparentModal(options: ReparentModalState): Modifier<AppState>\n{\n    return (state: AppState) =>\n    {\n        const reparentModal = { ...state.reparentModal, ...options };\n        return { reparentModal }\n    }\n}\n\nexport function setRawSceneModal(options: RawSceneModalState): Modifier<AppState>\n{\n    return (state: AppState) =>\n    {\n        const rawSceneModal = { ...state.rawSceneModal, ...options };\n        return { rawSceneModal }\n    }\n}\n\nexport function updateNode(node: SceneNode): Modifier<AppState>\n{\n    return (state: AppState) =>\n    {\n        const sceneTree = sceneTreeUpdateNode(state.sceneTree, node);\n        return { sceneTree };\n    }\n}\n\nexport function setSceneTree(sceneTree: SceneTree): Modifier<AppState>\n{\n    return () => { return { sceneTree } }\n}\n\nexport function setSelectedNode(selectedNodeId?: SceneNodeId): Modifier<AppState>\n{\n    return (state: AppState) =>\n    {\n        let selectedParentNodeId: SceneNodeId | undefined = undefined;\n        if (selectedNodeId)\n        {\n            for (const node of Object.values(state.sceneTree.nodes))\n            {\n                if (node.childrenIds.includes(selectedNodeId))\n                {\n                    selectedParentNodeId = node.id;\n                    break;\n                }\n            }\n        }\n\n        return { selectedNodeId, selectedParentNodeId }\n    };\n}", "import { h, Component, Attributes } from 'preact';\nimport { setRawSceneModal, setViewportOptions, ViewportOptions } from '../store/store-state';\nimport { store } from '../store/store';\nimport \"./webgl-viewport-options.scss\";\n\ninterface Props\n{\n    readonly viewportIndex: number;\n    readonly options: ViewportOptions;\n}\n\ninterface LabeledRangeProps\n{\n    readonly label: string;\n    readonly inputProps: any;\n}\nconst LabeledRange = (props: LabeledRangeProps) =>\n{\n    return <label style={{'display': 'inline-block'}}>\n        {props.label}\n        <input style={{'display': 'block'}} type='range' {...props.inputProps} />\n    </label>\n}\n\nexport default class WebGLViewportOptions extends Component<Props>\n{\n    public render(props: Props)\n    {\n        const { pixelated, renderScale, enableShadows, enableShowMarching, epsilon, maxMarchingStep } = this.props.options;\n\n        return <div class=\"viewport-options\">\n            <span class='control-group'>\n                <button onClick={this.togglePixelated}>{ pixelated ? 'Smooth' : 'Pixelated' }</button>\n                <select onChange={this.changeRenderScale} value={renderScale}>\n                    <option value=\"2\">2x</option>\n                    <option value=\"1.5\">1.5x</option>\n                    <option value=\"1\">1x</option>\n                    <option value=\"0.5\">0.5x</option>\n                    <option value=\"0.25\">0.25x</option>\n                    <option value=\"0.125\">0.125x</option>\n                </select>\n                <button onClick={this.toggleShadows}>{ enableShadows ? 'Hide Shadows' : 'Show Shadows' }</button>\n                <button onClick={this.toggleMarching}>{ enableShowMarching ? 'Hide Marching' : 'Show Marching' }</button>\n                <button onClick={this.showRawScene}>JSON Scene</button>\n            </span>\n            <LabeledRange label={`Epsilon ${epsilon}`} inputProps={{value: epsilon, min: 0, max: 0.1, step: 0.000001, onInput: this.changeEpsilon}} />\n            <LabeledRange label={`Marching Steps ${maxMarchingStep}`} inputProps={{value: maxMarchingStep, min: 0, max: 1000, step: 1, onInput: this.changeMarchingSteps}} />\n        </div>;\n    }\n\n    private showRawScene = () =>\n    {\n        store.execute(setRawSceneModal({show: true}));\n    }\n\n    private changeEpsilon = (e: Event) =>\n    {\n        const value = parseFloat((e.target as HTMLInputElement).value);\n        if (!isFinite(value))\n        {\n            console.warn(`Epsilon parse failed`);\n            return;\n        }\n\n        this.updateOptions({ epsilon: value });\n    }\n\n    private changeMarchingSteps = (e: Event) =>\n    {\n        const value = parseFloat((e.target as HTMLInputElement).value);\n        if (!isFinite(value))\n        {\n            console.warn(`Marching steps parse failed`);\n            return;\n        }\n\n        this.updateOptions({ maxMarchingStep: Math.round(value) });\n    }\n\n    private togglePixelated = (e: Event) =>\n    {\n        this.updateOptions({ pixelated: !this.props.options.pixelated });\n    }\n\n    private toggleShadows = (e: Event) =>\n    {\n        this.updateOptions({ enableShadows: !this.props.options.enableShadows });\n    }\n\n    private toggleMarching = (e: Event) =>\n    {\n        this.updateOptions({ enableShowMarching: !this.props.options.enableShowMarching });\n    }\n\n    private updateOptions = (options: Partial<ViewportOptions>) =>\n    {\n        console.log('Options', options);\n        store.execute(setViewportOptions(this.props.viewportIndex, options));\n    }\n\n    private changeRenderScale = (e: Event) =>\n    {\n        const selectedValue = (e.target as HTMLSelectElement).value;\n        const value = Number.parseFloat(selectedValue);\n        if (isFinite(value))\n        {\n            store.execute(setViewportOptions(this.props.viewportIndex, { renderScale: value }));\n        }\n        else\n        {\n            console.warn('Unable to parse canvas scale', selectedValue);\n        }\n    }\n}", "import { h, Component, createRef } from \"preact\";\nimport { ViewportOptions } from \"../store/store-state\";\nimport WebGLSdfRenderer from \"../webgl/webgl-sdf-renderer\";\nimport WebGLViewportOptions from \"./webgl-viewport-options\";\nimport { SceneConverter } from \"../ray-marching/scene-converter\";\nimport \"./webgl-viewport.scss\";\n\ninterface Props\n{\n    readonly viewportIndex: number;\n    readonly options: ViewportOptions;\n    readonly sceneConverter: SceneConverter;\n}\n\nexport class WebGLViewport extends Component<Props>\n{\n    private canvasRef = createRef<HTMLCanvasElement>();\n    private renderer?: WebGLSdfRenderer;\n\n    private zoom = 20;\n    private zoomMin = 1;\n    private zoomMax = 80;\n\n    private mousePosX = 0;\n    private mousePosY = 0;\n    private mouseDown = false;\n    private renderFrameCallback: number = -1;\n\n    public componentDidMount(): void\n    {\n        const canvasEl = this.canvasRef.current;\n        this.renderer = WebGLSdfRenderer.create(canvasEl);\n        this.renderer.canvasScale = this.props.options.renderScale;\n        this.renderer.cameraDistance = 10.0;\n        this.renderer.updateCamera();\n        this.updateCanvasSize();\n\n        this.renderer.setupCanvas();\n\n        window.addEventListener('resize', this.onViewportResize);\n\n        canvasEl.parentElement.addEventListener('pointerdown', this.onPointerDown);\n        canvasEl.parentElement.addEventListener('pointermove', this.onPointerMove);\n        canvasEl.parentElement.addEventListener('pointerup', this.onPointerUp);\n        canvasEl.parentElement.addEventListener('wheel', this.onMouseWheel);\n\n        this.requestRender();\n    }\n\n    public componentWillUnmount(): void\n    {\n        window.removeEventListener('resize', this.onViewportResize);\n\n        const canvasEl = this.canvasRef.current;\n        canvasEl.parentElement.removeEventListener('pointerdown', this.onPointerDown);\n        canvasEl.parentElement.removeEventListener('pointermove', this.onPointerMove);\n        canvasEl.parentElement.removeEventListener('pointerup', this.onPointerUp);\n        canvasEl.parentElement.removeEventListener('wheel', this.onMouseWheel);\n    }\n\n    public render()\n    {\n        this.requestRender();\n\n        let canvasClassName = 'viewport__canvas';\n        if (this.props.options.pixelated)\n        {\n            canvasClassName += ' is-pixelated';\n        }\n\n        return <div class='viewport outer-panel'>\n            <canvas className={canvasClassName} ref={this.canvasRef} />\n            <WebGLViewportOptions viewportIndex={this.props.viewportIndex} options={this.props.options} />\n        </div>\n    }\n\n    private updateCanvasSize = () =>\n    {\n        const size = this.canvasRef.current.getBoundingClientRect();\n        this.renderer.resizeCanvas(size.width, size.height);\n    }\n\n    private onViewportResize = () =>\n    {\n        this.updateCanvasSize();\n        this.manualRenderTrigger();\n    }\n\n    private renderScene = () =>\n    {\n        this.renderFrameCallback = -1;\n        const options = this.props.options;\n        this.renderer.epsilon = options.epsilon;\n        this.renderer.maxMarchingSteps = options.maxMarchingStep;\n        this.renderer.enableShadows = options.enableShadows;\n        this.renderer.enableShowMarches = options.enableShowMarching;\n        if (this.renderer.canvasScale !== options.renderScale)\n        {\n            this.renderer.canvasScale = options.renderScale;\n            this.updateCanvasSize();\n        }\n        this.renderer.render(this.props.sceneConverter);\n    }\n\n    private onPointerDown = (e: PointerEvent) =>\n    {\n        if (e.target !== this.canvasRef.current)\n        {\n            return;\n        }\n        console.log(e);\n\n        this.mousePosX = e.clientX;\n        this.mousePosY = e.clientY;\n        this.mouseDown = true;\n    }\n\n    private onPointerMove = (e: PointerEvent) =>\n    {\n        if (!this.mouseDown)\n        {\n            return;\n        }\n\n        const dx = e.clientX - this.mousePosX;\n        const dy = e.clientY - this.mousePosY;\n\n        this.mousePosX = e.clientX;\n        this.mousePosY = e.clientY;\n\n        this.renderer.orbitCamera(-dy, -dx);\n\n        this.manualRenderTrigger();\n    }\n\n    private onPointerUp = (e: PointerEvent) =>\n    {\n        this.mouseDown = false;\n    }\n\n    private onMouseWheel = (e: WheelEvent) =>\n    {\n        const delta = e.deltaY > 0 ? 1 : -1;\n        const newZoom = this.zoom + delta;\n        this.zoom = Math.max(Math.min(100, newZoom), 0);\n        this.renderer.cameraDistance = (this.zoom * 0.01) * (this.zoomMax - this.zoomMin) + this.zoomMin;\n        this.renderer.updateCamera();\n\n        this.manualRenderTrigger();\n    }\n\n    private manualRenderTrigger = () =>\n    {\n        this.requestRender();\n    }\n\n    private requestRender = () =>\n    {\n        if (this.renderFrameCallback < 0)\n        {\n            this.renderFrameCallback = requestAnimationFrame(this.renderScene);\n        }\n    }\n}", "import { h, Component } from 'preact';\nimport { rvec2, rvec3, rvec4 } from '../gl-matrix-ts';\nimport \"./vector-view.scss\";\n\ntype basicVector = rvec2 | rvec3 | rvec4;\ninterface Props\n{\n    readonly disabled?: boolean;\n    readonly vector: basicVector;\n    readonly onChange: (oldVector: basicVector, newVector: basicVector) => void;\n}\n\nfunction isVec3(x: basicVector): x is rvec3\n{\n    return Object.hasOwn(x, 'z');\n}\n\nfunction isVec4(x: basicVector): x is rvec4\n{\n    return Object.hasOwn(x, 'w');\n}\n\nexport default class VectorView extends Component<Props>\n{\n    public render()\n    {\n        const v = this.props.vector;\n        const disabled = this.props.disabled;\n        const isV3 = isVec3(v);\n        const isV4 = isVec4(v);\n\n        return <div class='vector control-group'>\n            <input class='input' disabled={disabled} type='number' value={v.x} onChange={this.onChangeX} placeholder='x' step={0.1} />\n            <input class='input' disabled={disabled} type='number' value={v.y} onChange={this.onChangeY} placeholder='y' step={0.1} />\n\n            { isV3 &&\n            <input class='input' disabled={disabled} type='number' value={v.z} onChange={this.onChangeZ} placeholder='z' step={0.1} />\n            }\n            { isV4 &&\n            <input class='input' disabled={disabled} type='number' value={v.w} onChange={this.onChangeW} placeholder='w' step={0.1} />\n            }\n        </div>;\n    }\n\n    private onChangeX = (e: Event) =>\n    {\n        this.updateVector(e, 'x');\n    }\n\n    private onChangeY = (e: Event) =>\n    {\n        this.updateVector(e, 'y');\n    }\n\n    private onChangeZ = (e: Event) =>\n    {\n        this.updateVector(e, 'z');\n    }\n\n    private onChangeW = (e: Event) =>\n    {\n        this.updateVector(e, 'w');\n    }\n\n    private updateVector = (e: Event, field: string) =>\n    {\n        const v = this.props.vector;\n        const strValue = (e.target as HTMLInputElement).value;\n        const value = parseFloat(strValue);\n        if (!isFinite(value))\n        {\n            console.error('Unable to process vector field', field, strValue);\n            return;\n        }\n\n        console.log('Update vector field', field, value);\n\n        this.props.onChange(v, {...v, [field]: value});\n    }\n}", "import { h, Component } from 'preact';\nimport VectorView from './vector-view';\nimport { vec3, vec4 } from '../gl-matrix-ts';\nimport { Shape } from '../ray-marching/scene-entities';\n\ninterface Props\n{\n    readonly shape: Shape;\n    readonly onChange: (newShape: Shape) => void;\n}\nexport default class ShapeView extends Component<Props>\n{\n    public render()\n    {\n        const shape = this.props.shape;\n        const isPhong = shape.lightingModel === 'phong';\n\n        return <div>\n            <div>\n                <strong>Type</strong> <select value={shape.type ?? 'none'} onChange={this.onChangeType}>\n                    <option value='none'>None</option>\n                    <option value='box'>Box</option>\n                    <option value='sphere'>Sphere</option>\n                    <option value='hexPrism'>Hex Prism</option>\n                </select>\n            </div>\n            <div>\n                <strong>Shape Params</strong> <VectorView vector={shape.shapeParams} onChange={this.onChangeShapeParams} />\n            </div>\n            <div>\n                <strong>Lighting Model</strong> <select value={shape.lightingModel} onChange={this.onChangeLightingModel}>\n                    <option value='unlit'>Unlit</option>\n                    <option value='lambert'>Lambert</option>\n                    <option value='phong'>Phong</option>\n                </select>\n            </div>\n            <div>\n                <strong>Diffuse Colour</strong> <VectorView vector={shape.diffuseColour} onChange={this.onChangeDiffuseColour} />\n            </div>\n            <div>\n                <strong>Specular Colour</strong> <VectorView disabled={!isPhong} vector={shape.specularColour} onChange={this.onChangeSpecularColour} />\n            </div>\n            <div>\n                <strong>Shininess</strong> <input class='input' disabled={!isPhong} type='number' min={0} max={100} step={0.1} value={shape.shininess} placeholder='Shininess' onChange={this.onChangeShininess} />\n            </div>\n        </div>\n    }\n\n    private onChangeType = (e: Event) =>\n    {\n        const value = (e.target as HTMLSelectElement).value;\n        this.updateField(value, 'type');\n    }\n\n    private onChangeLightingModel = (e: Event) =>\n    {\n        const value = (e.target as HTMLSelectElement).value;\n        this.updateField(value, 'lightingModel');\n    }\n\n    private onChangeShininess = (e: Event) =>\n    {\n        const value = parseFloat((e.target as HTMLInputElement).value);\n        if (isFinite(value))\n        {\n            this.updateField(value, 'shininess');\n        }\n    }\n\n    private onChangeShapeParams = (oldVec: vec3, newVec: vec3) =>\n    {\n        this.updateField(newVec, 'shapeParams');\n    }\n\n    private onChangeDiffuseColour = (oldVec: vec4, newVec: vec4) =>\n    {\n        this.updateField(newVec, 'diffuseColour');\n    }\n\n    private onChangeSpecularColour = (oldVec: vec4, newVec: vec4) =>\n    {\n        this.updateField(newVec, 'specularColour');\n    }\n\n    private updateField = (value: any, field: keyof Required<Shape>) =>\n    {\n        console.log('Update shape', field, value);\n        const newShape = {...this.props.shape, [field]: value};\n        this.props.onChange(newShape);\n    }\n}", "import { h, Component } from 'preact';\nimport VectorView from './vector-view';\nimport { vec4 } from '../gl-matrix-ts';\nimport { Light } from '../ray-marching/scene-entities';\n\ninterface Props\n{\n    readonly light: Light;\n    readonly onChange: (newLight: Light) => void;\n}\nexport default class LightView extends Component<Props>\n{\n    public render()\n    {\n        const light = this.props.light;\n\n        if (light === undefined)\n        {\n            return <div>Empty Light</div>;\n        }\n\n        return <div>\n            <div>\n                <strong>Colour</strong> <VectorView vector={light.colour} onChange={this.onChangeColour} />\n            </div>\n        </div>\n    }\n\n    private onChangeColour = (oldVec: vec4, newVec: vec4) =>\n    {\n        this.updateField(newVec, 'colour');\n    }\n\n    private updateField = (value: any, field: keyof Required<Light>) =>\n    {\n        console.log('Update light', field, value);\n        const newShape = {...this.props.light, [field]: value};\n        this.props.onChange(newShape);\n    }\n}", "import { h, Component, Fragment } from 'preact';\nimport ShapeView from './shape-view';\nimport { Light, SceneNode, SdfOpCode, Shape } from '../ray-marching/scene-entities';\nimport VectorView from './vector-view';\nimport { quat, vec3 } from '../gl-matrix-ts';\nimport LightView from './light-view';\nimport { createSceneNode, SceneTree, sceneTreeAddChild, sceneTreeDeleteChild } from '../ray-marching/scene-tree';\nimport { setReparentModal, setSceneTree } from '../store/store-state';\nimport { store } from '../store/store';\nimport './scene-node-view.scss';\n\ninterface Props\n{\n    readonly sceneTree: SceneTree;\n    readonly node: SceneNode;\n    readonly onChange: (newShapeNode: SceneNode, oldShapeNode: SceneNode) => void;\n}\n\ninterface State\n{\n    readonly show: boolean;\n}\n\nexport default class SceneNodeView extends Component<Props, State>\n{\n    constructor()\n    {\n        super();\n        this.state = {\n            show: false\n        }\n    }\n\n    public render()\n    {\n        const { node, sceneTree } = this.props;\n        if (node == undefined)\n        {\n            return <div class=\"scene-node-view\">\n                No node selected\n            </div>\n        }\n\n        const parent = node.parentId != undefined ? sceneTree.nodes[node.parentId] : undefined;\n        const selectedOpCode = node.childOpCode ?? 'none';\n\n        return <div class=\"scene-node-view\">\n            <div>\n                <strong>Name</strong> <input class='input' type='text' placeholder='Name' value={node.name} onChange={this.onChangeName} />\n            </div>\n            <div>\n                <strong>Position</strong> <VectorView vector={node.position} onChange={this.onChangePosition} />\n            </div>\n            <div>\n                <strong>Rotation</strong> <VectorView vector={node.rotation} onChange={this.onChangeRotation} />\n            </div>\n            <div>\n                <strong>Op Code</strong> <select value={selectedOpCode} onChange={this.onChangeOpCode}>\n                    <option value='none'>None</option>\n                    <option value='union'>Union</option>\n                    <option value='intersection'>Intersection</option>\n                    <option value='subtraction'>Subtraction</option>\n                </select>\n            </div>\n            <div>\n                <strong>Shape</strong> <button onClick={this.toggleShape}>{node.hasShape ? 'Hide' : 'Show'}</button>\n                { node.hasShape && <ShapeView shape={node.shape} onChange={this.onChangeShape} /> }\n            </div>\n            <div>\n                <strong>Light</strong> <button onClick={this.toggleLight}>{node.hasLight ? 'Hide' : 'Show'}</button>\n                { node.hasLight && <LightView light={node.light} onChange={this.onChangeLight} /> }\n            </div>\n\n            <div><strong>Children</strong></div>\n            <div class='control-group'>\n                <button onClick={this.addChild}>Add</button>\n                { parent != null &&\n                <Fragment>\n                    <button onClick={this.deleteSelf}>Delete</button>\n                    <button onClick={this.reparent}>Re-parent</button>\n                </Fragment>}\n            </div>\n            {/* <div>\n                <strong>Children</strong> {\n                    children.map((child, i) => <ShapeNodeView key={i} node={child} onChange={(n) => this.onChangeChild(i, n)}/>)\n                }\n            </div> */}\n        </div>\n    }\n\n    private addChild = () =>\n    {\n        const newTree = sceneTreeAddChild(this.props.sceneTree, this.props.node, createSceneNode('New Child', {}));\n        store.execute(setSceneTree(newTree));\n    }\n\n    private deleteSelf = () =>\n    {\n        const newTree = sceneTreeDeleteChild(this.props.sceneTree, this.props.node);\n        store.execute(setSceneTree(newTree));\n    }\n\n    private reparent = () =>\n    {\n        const { node, sceneTree } = this.props;\n        const parent = node.parentId != undefined ? sceneTree.nodes[node.parentId] : undefined;\n        if (parent == null)\n        {\n            console.warn('Cannot reparent root node');\n            return;\n        }\n\n        store.execute(\n            setReparentModal({\n                show: true,\n                childNodeId: this.props.node.id\n            })\n        );\n    }\n\n    private toggleShape = () =>\n    {\n        const currentHasShape = this.props.node.hasShape;\n        this.updateField(!currentHasShape, 'hasShape');\n    }\n\n    private toggleLight = () =>\n    {\n        const currentHasLight = this.props.node.hasLight;\n        this.updateField(!currentHasLight, 'hasLight');\n    }\n\n    private onChangeName = (e: Event) =>\n    {\n        const value = (e.target as HTMLInputElement).value;\n        this.updateField(value, 'name');\n    }\n\n    private onChangePosition = (oldVec: vec3, newVec: vec3) =>\n    {\n        this.updateField(newVec, 'position');\n    }\n\n    private onChangeRotation = (oldQuat: quat, newQuat: quat) =>\n    {\n        this.updateField(newQuat, 'rotation');\n    }\n\n\n    private onChangeOpCode = (e: Event) =>\n    {\n        const value = (e.target as HTMLSelectElement).value as SdfOpCode;\n        this.updateField(value, 'childOpCode');\n    }\n\n    private onChangeShape = (shape: Shape) =>\n    {\n        this.updateField(shape, 'shape');\n    }\n\n    private onChangeLight = (light: Light) =>\n    {\n        this.updateField(light, 'light');\n    }\n\n    // private onChangeChild = (index: number, child: SceneNode) =>\n    // {\n    //     const children = this.props.node.children !== undefined ? [...this.props.node.children] : [];\n    //     children[index] = child;\n\n    //     this.updateField(children, 'children');\n    // }\n\n    private updateField = (value: any, field: keyof SceneNode) =>\n    {\n        console.log('Update shape node', field, value);\n        const newNode = {...this.props.node, [field]: value};\n        this.props.onChange(newNode, this.props.node);\n    }\n}", "export type Opaque<T, K> = T & { readonly _tag : K };\n\nexport type Editable<T> =\n{\n    -readonly [P in keyof T]: T[P];\n};\n\nexport function toRadian(degrees: number): number\n{\n    return degrees * Math.PI / 180.0;\n}\n\nexport function addClass(target: string, className: string, addIfTrue?: boolean): string\n{\n    if (addIfTrue == undefined || addIfTrue === true)\n    {\n        target += ' ' + className;\n    }\n    return target;\n}", "import { h, Component } from 'preact';\nimport { SceneNode } from '../ray-marching/scene-entities';\nimport { addClass } from '../common';\nimport './scene-node-tree-item.scss';\n\ninterface Props\n{\n    readonly node: SceneNode;\n    readonly depth: number;\n    readonly disable?: boolean;\n    readonly isSelected: boolean;\n    readonly onClicked: (node: SceneNode) => void;\n}\n\nexport default class ShapeNodeTreeItem extends Component<Props>\n{\n    public render()\n    {\n        const { depth, node, isSelected, disable } = this.props;\n\n        const className = addClass(addClass('scene-node-tree-item', 'is-selected', isSelected), 'is-disabled', disable === true);\n        return <div class={className} style={{'paddingLeft': (depth + 1) * 0.5 + 'rem'}} onClick={this.onClick}>\n            + {node.name}\n        </div>\n    }\n\n    private onClick = () =>\n    {\n        if (this.props.disable)\n        {\n            return;\n        }\n        this.props.onClicked(this.props.node);\n    }\n}", "import { h, Component } from 'preact';\nimport { SceneTree, sceneTreeFlatten } from '../ray-marching/scene-tree';\nimport ShapeNodeTreeItem from './scene-node-tree-item';\nimport { SceneNode, SceneNodeId } from '../ray-marching/scene-entities';\nimport './scene-node-tree.scss';\n\ninterface Props\n{\n    readonly sceneTree: SceneTree;\n    readonly selectedNodeId?: SceneNodeId;\n    readonly disabledNodeId?: ReadonlyArray<SceneNodeId>;\n    readonly onItemClicked: (node: SceneNode) => void;\n}\n\nexport default class SceneNodeTree extends Component<Props>\n{\n    public render()\n    {\n        return <div class='scene-node-tree'>\n            { this.renderNodeTree() }\n        </div>\n    }\n\n    private renderNodeTree = () =>\n    {\n        const { sceneTree , selectedNodeId, onItemClicked } = this.props;\n        const rootNode = sceneTree.nodes[sceneTree.rootNodeId];\n        const result: h.JSX.Element[] = [];\n        if (rootNode == undefined)\n        {\n            return result;\n        }\n\n        const flattenedTree = sceneTreeFlatten(sceneTree);\n        for (const entry of flattenedTree)\n        {\n            const isSelected = entry.node.id === selectedNodeId;\n            result.push(<ShapeNodeTreeItem isSelected={isSelected} depth={entry.depth} key={entry.node.id} node={entry.node} onClicked={onItemClicked} />);\n        }\n\n        return result;\n    }\n}", "import { h, Component } from 'preact';\nimport SceneNodeView from './scene-node-view';\nimport { store } from '../store/store';\nimport { setSelectedNode, updateNode } from '../store/store-state';\nimport SceneNodeTree from './scene-node-tree';\nimport { SceneTree } from '../ray-marching/scene-tree';\nimport { SceneNode, SceneNodeId } from '../ray-marching/scene-entities';\nimport './scene-tree-view.scss';\n\ninterface Props\n{\n    readonly sceneTree: SceneTree;\n    readonly selectedNodeId?: SceneNodeId;\n}\n\nexport default class SceneTreeView extends Component<Props>\n{\n    public render()\n    {\n        const { sceneTree, selectedNodeId } = this.props;\n\n        const selectedNode = sceneTree.nodes[selectedNodeId];\n\n        return <div class='scene-tree'>\n            <div class='scene-tree__contents outer-panel'>\n                <div class='inner-panel'>\n                    <SceneNodeTree sceneTree={sceneTree} selectedNodeId={selectedNodeId} onItemClicked={this.onNodeClicked} />\n                </div>\n                <div class='inner-panel scene-tree__nodes'>\n                    <SceneNodeView sceneTree={sceneTree} node={selectedNode} onChange={this.onChangeSelectedNode} /> </div>\n            </div>\n        </div>\n    }\n\n    private onNodeClicked = (node: SceneNode) =>\n    {\n        store.execute(setSelectedNode(node.id));\n    }\n\n    private onChangeSelectedNode = (newNode: SceneNode, oldNode: SceneNode) =>\n    {\n        store.execute(updateNode(newNode));\n    }\n}", "import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\n// We take the minimum timeout for requestAnimationFrame to ensure that\n// the callback is invoked after the next frame. 35ms is based on a 30hz\n// refresh rate, which is the minimum rate for a smooth user experience.\nconst RAF_TIMEOUT = 35;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = hookState._component.props !== p;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn prevScu\n\t\t\t\t\t? prevScu.call(this, p, s, c) || shouldUpdate\n\t\t\t\t\t: shouldUpdate;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tconst result = ref(createHandle());\n\t\t\t\treturn () => {\n\t\t\t\t\tref(null);\n\t\t\t\t\tif (result && typeof result == 'function') result();\n\t\t\t\t};\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n\n/**\n * Check if two values are the same value\n * @param {*} x\n * @param {*} y\n * @returns {boolean}\n */\nexport function is(x, y) {\n\treturn (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\n", "import { useState, useLayoutEffect, useEffect } from 'preact/hooks';\nimport { is } from './util';\n\n/**\n * This is taken from https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L84\n * on a high level this cuts out the warnings, ... and attempts a smaller implementation\n * @typedef {{ _value: any; _getSnapshot: () => any }} Store\n */\nexport function useSyncExternalStore(subscribe, getSnapshot) {\n\tconst value = getSnapshot();\n\n\t/**\n\t * @typedef {{ _instance: Store }} StoreRef\n\t * @type {[StoreRef, (store: StoreRef) => void]}\n\t */\n\tconst [{ _instance }, forceUpdate] = useState({\n\t\t_instance: { _value: value, _getSnapshot: getSnapshot }\n\t});\n\n\tuseLayoutEffect(() => {\n\t\t_instance._value = value;\n\t\t_instance._getSnapshot = getSnapshot;\n\n\t\tif (didSnapshotChange(_instance)) {\n\t\t\tforceUpdate({ _instance });\n\t\t}\n\t}, [subscribe, value, getSnapshot]);\n\n\tuseEffect(() => {\n\t\tif (didSnapshotChange(_instance)) {\n\t\t\tforceUpdate({ _instance });\n\t\t}\n\n\t\treturn subscribe(() => {\n\t\t\tif (didSnapshotChange(_instance)) {\n\t\t\t\tforceUpdate({ _instance });\n\t\t\t}\n\t\t});\n\t}, [subscribe]);\n\n\treturn value;\n}\n\n/** @type {(inst: Store) => boolean} */\nfunction didSnapshotChange(inst) {\n\tconst latestGetSnapshot = inst._getSnapshot;\n\tconst prevValue = inst._value;\n\ttry {\n\t\tconst nextValue = latestGetSnapshot();\n\t\treturn !is(prevValue, nextValue);\n\t} catch (error) {\n\t\treturn true;\n\t}\n}\n\nexport function startTransition(cb) {\n\tcb();\n}\n\nexport function useDeferredValue(val) {\n\treturn val;\n}\n\nexport function useTransition() {\n\treturn [false, startTransition];\n}\n\n// TODO: in theory this should be done after a VNode is diffed as we want to insert\n// styles/... before it attaches\nexport const useInsertionEffect = useLayoutEffect;\n", "import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p, c) {\n\tthis.props = p;\n\tthis.context = c;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function (props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n", "import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n", "import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionComponent}\n */\nexport function forwardRef(fn) {\n\tfunction Forwarded(props) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\treturn fn(clone, props.ref || null);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n", "import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n", "import { Component, createElement, options, Fragment } from 'preact';\nimport { MODE_HYDRATE } from '../../src/constants';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function (error, newVNode, oldVNode, errorInfo) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode, errorInfo);\n};\n\nconst oldUnmount = options.unmount;\noptions.unmount = function (vnode) {\n\t/** @type {import('./internal').Component} */\n\tconst component = vnode._component;\n\tif (component && component._onResolve) {\n\t\tcomponent._onResolve();\n\t}\n\n\t// if the component is still hydrating\n\t// most likely it is because the component is suspended\n\t// we set the vnode.type as `null` so that it is not a typeof function\n\t// so the unmount will remove the vnode._dom\n\tif (component && vnode._flags & MODE_HYDRATE) {\n\t\tvnode.type = null;\n\t}\n\n\tif (oldUnmount) oldUnmount(vnode);\n};\n\nfunction detachedClone(vnode, detachedParent, parentDom) {\n\tif (vnode) {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tvnode._component.__hooks._list.forEach(effect => {\n\t\t\t\tif (typeof effect._cleanup == 'function') effect._cleanup();\n\t\t\t});\n\n\t\t\tvnode._component.__hooks = null;\n\t\t}\n\n\t\tvnode = assign({}, vnode);\n\t\tif (vnode._component != null) {\n\t\t\tif (vnode._component._parentDom === parentDom) {\n\t\t\t\tvnode._component._parentDom = detachedParent;\n\t\t\t}\n\n\t\t\tvnode._component._force = true;\n\n\t\t\tvnode._component = null;\n\t\t}\n\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tdetachedClone(child, detachedParent, parentDom)\n\t\t\t);\n\t}\n\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode, detachedParent, originalParent) {\n\tif (vnode && originalParent) {\n\t\tvnode._original = null;\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tremoveOriginal(child, detachedParent, originalParent)\n\t\t\t);\n\n\t\tif (vnode._component) {\n\t\t\tif (vnode._component._parentDom === detachedParent) {\n\t\t\t\tif (vnode._dom) {\n\t\t\t\t\toriginalParent.appendChild(vnode._dom);\n\t\t\t\t}\n\t\t\t\tvnode._component._force = true;\n\t\t\t\tvnode._component._parentDom = originalParent;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {Promise} promise The thrown promise\n * @param {import('./internal').VNode<any, any>} suspendingVNode The suspending component\n */\nSuspense.prototype._childDidSuspend = function (promise, suspendingVNode) {\n\tconst suspendingComponent = suspendingVNode._component;\n\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent._onResolve = null;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._onResolve = onResolved;\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\t// If the suspension was during hydration we don't need to restore the\n\t\t\t// suspended children into the _children array\n\t\t\tif (c.state._suspended) {\n\t\t\t\tconst suspendedVNode = c.state._suspended;\n\t\t\t\tc._vnode._children[0] = removeOriginal(\n\t\t\t\t\tsuspendedVNode,\n\t\t\t\t\tsuspendedVNode._component._parentDom,\n\t\t\t\t\tsuspendedVNode._component._originalParentDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * We do not set `suspended: true` during hydration because we want the actual markup\n\t * to remain on screen and hydrate it when the suspense actually gets resolved.\n\t * While in non-hydration cases the usual fallback -> component flow would occour.\n\t */\n\tif (\n\t\t!c._pendingSuspensionCount++ &&\n\t\t!(suspendingVNode._flags & MODE_HYDRATE)\n\t) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function () {\n\tthis._suspenders = [];\n};\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {import('./internal').SuspenseComponent[\"props\"]} props\n * @param {import('./internal').SuspenseState} state\n */\nSuspense.prototype.render = function (props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children) {\n\t\t\tconst detachedParent = document.createElement('div');\n\t\t\tconst detachedComponent = this._vnode._children[0]._component;\n\t\t\tthis._vnode._children[0] = detachedClone(\n\t\t\t\tthis._detachOnNextRender,\n\t\t\t\tdetachedParent,\n\t\t\t\t(detachedComponent._originalParentDom = detachedComponent._parentDom)\n\t\t\t);\n\t\t}\n\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\t// Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n\t/** @type {import('./internal').VNode} */\n\tconst fallback =\n\t\tstate._suspended && createElement(Fragment, null, props.fallback);\n\tif (fallback) fallback._flags &= ~MODE_HYDRATE;\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tfallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('./internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\t/** @type {import('./internal').Component} */\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n", "import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function (child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function (props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate =\n\tSuspenseList.prototype.componentDidMount = function () {\n\t\t// Iterate through all children after mounting for two reasons:\n\t\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t\t//    The nodes can now be completely consumed from the linked list.\n\t\t// 2. Handle nodes that might have gotten resolved between render and\n\t\t//    componentDidMount.\n\t\tthis._map.forEach((node, child) => {\n\t\t\tresolve(this, child, node);\n\t\t});\n\t};\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { createElement, render } from 'preact';\n\n/**\n * @param {import('../../src/index').RenderableProps<{ context: any }>} props\n */\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\n\t_this.componentWillUnmount = function () {\n\t\trender(null, _this._temp);\n\t\t_this._temp = null;\n\t\t_this._container = null;\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t}\n\n\tif (!_this._temp) {\n\t\t// Ensure the element has a mask for useId invocations\n\t\tlet root = _this._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\t_this._container = container;\n\n\t\t// Create a fake DOM parent node that manages a subset of `container`'s children:\n\t\t_this._temp = {\n\t\t\tnodeType: 1,\n\t\t\tparentNode: container,\n\t\t\tchildNodes: [],\n\t\t\t_children: { _mask: root._mask },\n\t\t\tcontains: () => true,\n\t\t\tinsertBefore(child, before) {\n\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t_this._container.insertBefore(child, before);\n\t\t\t},\n\t\t\tremoveChild(child) {\n\t\t\t\tthis.childNodes.splice(this.childNodes.indexOf(child) >>> 1, 1);\n\t\t\t\t_this._container.removeChild(child);\n\t\t\t}\n\t\t};\n\t}\n\n\t// Render our wrapping element into temp.\n\trender(\n\t\tcreateElement(ContextProvider, { context: _this.context }, props._vnode),\n\t\t_this._temp\n\t);\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\tconst el = createElement(Portal, { _vnode: vnode, _container: container });\n\tel.containerInfo = container;\n\treturn el;\n}\n", "import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\nimport {\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tuseEffect,\n\tuseId,\n\tuseImperativeHandle,\n\tuseLayoutEffect,\n\tuseMemo,\n\tuseReducer,\n\tuseRef,\n\tuseState\n} from 'preact/hooks';\nimport {\n\tuseDeferredValue,\n\tuseInsertionEffect,\n\tuseSyncExternalStore,\n\tuseTransition\n} from './index';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS =\n\t/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\nconst ON_ANI = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;\nconst CAMEL_REPLACE = /[A-Z0-9]/g;\nconst IS_DOM = typeof document !== 'undefined';\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst onChangeInputType = type =>\n\t(typeof Symbol != 'undefined' && typeof Symbol() == 'symbol'\n\t\t? /fil|che|rad/\n\t\t: /fil|che|ra/\n\t).test(type);\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nconst classNameDescriptorNonEnumberable = {\n\tenumerable: false,\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nfunction handleDomVNode(vnode) {\n\tlet props = vnode.props,\n\t\ttype = vnode.type,\n\t\tnormalizedProps = {};\n\n\tlet isNonDashedType = type.indexOf('-') === -1;\n\tfor (let i in props) {\n\t\tlet value = props[i];\n\n\t\tif (\n\t\t\t(i === 'value' && 'defaultValue' in props && value == null) ||\n\t\t\t// Emulate React's behavior of not rendering the contents of noscript tags on the client.\n\t\t\t(IS_DOM && i === 'children' && type === 'noscript') ||\n\t\t\ti === 'class' ||\n\t\t\ti === 'className'\n\t\t) {\n\t\t\t// Skip applying value if it is null/undefined and we already set\n\t\t\t// a default value\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet lowerCased = i.toLowerCase();\n\t\tif (i === 'defaultValue' && 'value' in props && props.value == null) {\n\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\ti = 'value';\n\t\t} else if (i === 'download' && value === true) {\n\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t// value will be used as the file name and the file will be called\n\t\t\t// \"true\" upon downloading it.\n\t\t\tvalue = '';\n\t\t} else if (lowerCased === 'translate' && value === 'no') {\n\t\t\tvalue = false;\n\t\t} else if (lowerCased[0] === 'o' && lowerCased[1] === 'n') {\n\t\t\tif (lowerCased === 'ondoubleclick') {\n\t\t\t\ti = 'ondblclick';\n\t\t\t} else if (\n\t\t\t\tlowerCased === 'onchange' &&\n\t\t\t\t(type === 'input' || type === 'textarea') &&\n\t\t\t\t!onChangeInputType(props.type)\n\t\t\t) {\n\t\t\t\tlowerCased = i = 'oninput';\n\t\t\t} else if (lowerCased === 'onfocus') {\n\t\t\t\ti = 'onfocusin';\n\t\t\t} else if (lowerCased === 'onblur') {\n\t\t\t\ti = 'onfocusout';\n\t\t\t} else if (ON_ANI.test(i)) {\n\t\t\t\ti = lowerCased;\n\t\t\t}\n\t\t} else if (isNonDashedType && CAMEL_PROPS.test(i)) {\n\t\t\ti = i.replace(CAMEL_REPLACE, '-$&').toLowerCase();\n\t\t} else if (value === null) {\n\t\t\tvalue = undefined;\n\t\t}\n\n\t\t// Add support for onInput and onChange, see #3561\n\t\t// if we have an oninput prop already change it to oninputCapture\n\t\tif (lowerCased === 'oninput') {\n\t\t\ti = lowerCased;\n\t\t\tif (normalizedProps[i]) {\n\t\t\t\ti = 'oninputCapture';\n\t\t\t}\n\t\t}\n\n\t\tnormalizedProps[i] = value;\n\t}\n\n\t// Add support for array select values: <select multiple value={[]} />\n\tif (\n\t\ttype == 'select' &&\n\t\tnormalizedProps.multiple &&\n\t\tArray.isArray(normalizedProps.value)\n\t) {\n\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\tchild.props.selected =\n\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t});\n\t}\n\n\t// Adding support for defaultValue in select tag\n\tif (type == 'select' && normalizedProps.defaultValue != null) {\n\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\tif (normalizedProps.multiple) {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.defaultValue.indexOf(child.props.value) != -1;\n\t\t\t} else {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.defaultValue == child.props.value;\n\t\t\t}\n\t\t});\n\t}\n\n\tif (props.class && !props.className) {\n\t\tnormalizedProps.class = props.class;\n\t\tObject.defineProperty(\n\t\t\tnormalizedProps,\n\t\t\t'className',\n\t\t\tclassNameDescriptorNonEnumberable\n\t\t);\n\t} else if (props.className && !props.class) {\n\t\tnormalizedProps.class = normalizedProps.className = props.className;\n\t} else if (props.class && props.className) {\n\t\tnormalizedProps.class = normalizedProps.className = props.className;\n\t}\n\n\tvnode.props = normalizedProps;\n}\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\t// only normalize props on Element nodes\n\tif (typeof vnode.type === 'string') {\n\t\thandleDomVNode(vnode);\n\t}\n\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function (vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\nconst oldDiffed = options.diffed;\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = function (vnode) {\n\tif (oldDiffed) {\n\t\toldDiffed(vnode);\n\t}\n\n\tconst props = vnode.props;\n\tconst dom = vnode._dom;\n\n\tif (\n\t\tdom != null &&\n\t\tvnode.type === 'textarea' &&\n\t\t'value' in props &&\n\t\tprops.value !== dom.value\n\t) {\n\t\tdom.value = props.value == null ? '' : props.value;\n\t}\n\n\tcurrentComponent = null;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t},\n\t\t\tuseCallback,\n\t\t\tuseContext,\n\t\t\tuseDebugValue,\n\t\t\tuseDeferredValue,\n\t\t\tuseEffect,\n\t\t\tuseId,\n\t\t\tuseImperativeHandle,\n\t\t\tuseInsertionEffect,\n\t\t\tuseLayoutEffect,\n\t\t\tuseMemo,\n\t\t\t// useMutableSource, // experimental-only and replaced by uSES, likely not worth supporting\n\t\t\tuseReducer,\n\t\t\tuseRef,\n\t\t\tuseState,\n\t\t\tuseSyncExternalStore,\n\t\t\tuseTransition\n\t\t}\n\t}\n};\n", "import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseId,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport {\n\tuseInsertionEffect,\n\tstartTransition,\n\tuseDeferredValue,\n\tuseSyncExternalStore,\n\tuseTransition\n} from './hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '18.3.1'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Check if the passed element is a Fragment node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isFragment(element) {\n\treturn isValidElement(element) && element.type === Fragment;\n}\n\n/**\n * Check if the passed element is a Memo node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isMemo(element) {\n\treturn (\n\t\t!!element &&\n\t\t!!element.displayName &&\n\t\t(typeof element.displayName === 'string' ||\n\t\t\telement.displayName instanceof String) &&\n\t\telement.displayName.startsWith('Memo(')\n\t);\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * In React, `flushSync` flushes the entire tree and forces a rerender. It's\n * implmented here as a no-op.\n * @template Arg\n * @template Result\n * @param {(arg: Arg) => Result} callback function that runs before the flush\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n * @returns\n */\nconst flushSync = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\n// compat to react-is\nexport const isElement = isValidElement;\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tisFragment,\n\tisMemo,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\tuseInsertionEffect,\n\tstartTransition,\n\tuseDeferredValue,\n\tuseSyncExternalStore,\n\tuseTransition,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseId,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseInsertionEffect,\n\tuseTransition,\n\tuseDeferredValue,\n\tuseSyncExternalStore,\n\tstartTransition,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tisElement,\n\tisFragment,\n\tisMemo,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n", "import { h, Component } from 'preact';\nimport { createPortal } from 'preact/compat';\nimport './modal.scss';\n\ninterface Props\n{\n    readonly show: boolean;\n    readonly class?: string;\n    readonly portalContainer?: string;\n    readonly onRequestClose: () => void;\n}\n\ninterface ModalCountMap\n{\n    [key: string]: number;\n}\n\nexport default class Modal extends Component<Props>\n{\n    private static currentNumModals: ModalCountMap = {};\n    private static prevNumModals: ModalCountMap = {};\n\n    public render()\n    {\n        const { show, onRequestClose } = this.props;\n\n        if (show === false)\n        {\n            return null;\n        }\n\n        const portalContainer = this.props.portalContainer ?? 'modals';\n        const modalEl = Modal.getModalEl(portalContainer);\n        const baseClassName = 'modal-body outer-panel ';\n        const className = this.props.class != undefined ? baseClassName + this.props.class : baseClassName;\n\n        return createPortal(<div class='modal-backdrop' onPointerDown={onRequestClose}>\n                <div class={className} onPointerDown={this.preventClose}>\n                    { this.props.children }\n                </div>\n            </div>, modalEl);\n    }\n\n    private preventClose = (e: PointerEvent) =>\n    {\n        e.stopImmediatePropagation();\n    }\n\n    public static afterRender()\n    {\n        let toHide: string[] | undefined = undefined;\n        let toShow: string[] | undefined = undefined;\n\n        for (const elName in this.currentNumModals)\n        {\n            const count = this.currentNumModals[elName];\n            const prevCount = this.prevNumModals[elName] || 0;\n            if (count === 0 && prevCount > 0)\n            {\n                if (toHide === undefined)\n                {\n                    toHide = [];\n                }\n                toHide.push(elName);\n            }\n            else if (count > 0 && prevCount === 0)\n            {\n                if (toShow === undefined)\n                {\n                    toShow = [];\n                }\n                toShow.push(elName);\n            }\n        }\n\n        for (const elName in this.prevNumModals)\n        {\n            if (!this.currentNumModals.hasOwnProperty(elName))\n            {\n                if (toHide === undefined)\n                {\n                    toHide = [];\n                }\n                toHide.push(elName);\n            }\n        }\n\n        this.prevNumModals = this.currentNumModals;\n        this.currentNumModals = {};\n\n        if (toHide != undefined)\n        {\n            for (const elName of toHide)\n            {\n                const el = document.getElementById(elName);\n                el.style.display = \"none\";\n            }\n        }\n        if (toShow != undefined)\n        {\n            for (const elName of toShow)\n            {\n                const el = document.getElementById(elName);\n                el.style.display = 'block';\n            }\n        }\n    }\n\n    private static getModalEl(container: string)\n    {\n        const el = document.getElementById(container);\n        const current = this.currentNumModals[container] || 0;\n        this.currentNumModals[container] = current + 1;\n\n        return el;\n    }\n}", "import { h, Component } from 'preact';\nimport { SceneTree } from '../ray-marching/scene-tree';\nimport Modal from './modal';\nimport { SceneNode, SceneNodeId } from '../ray-marching/scene-entities';\nimport SceneNodeTree from './scene-node-tree';\n\ninterface Props\n{\n    readonly show: boolean;\n    readonly disabledNodeIds: ReadonlyArray<SceneNodeId>;\n    readonly sceneTree: SceneTree;\n    readonly onRequestClose: () => void;\n    readonly onItemClicked: (node: SceneNode) => void;\n}\n\nexport default class SceneNodeTreeModal extends Component<Props>\n{\n    public render()\n    {\n        const { show, sceneTree, disabledNodeIds, onRequestClose } = this.props;\n\n        return <Modal show={show} onRequestClose={onRequestClose}>\n            <SceneNodeTree sceneTree={sceneTree} disabledNodeId={disabledNodeIds} onItemClicked={this.onItemClicked} />\n        </Modal>\n    }\n\n    private onItemClicked = (node: SceneNode) =>\n    {\n        this.props.onItemClicked(node);\n    }\n}", "import { h, Component } from 'preact';\nimport { ReparentModalState, setReparentModal, setSceneTree } from '../store/store-state';\nimport { sceneTreeMoveChild, SceneTree } from '../ray-marching/scene-tree';\nimport { store } from '../store/store';\nimport { SceneNode } from '../ray-marching/scene-entities';\nimport SceneNodeTreeModal from './scene-node-tree-modal';\n\ninterface Props\n{\n    readonly state: ReparentModalState;\n    readonly sceneTree: SceneTree;\n}\n\nexport default class ReparentModal extends Component<Props>\n{\n    public render()\n    {\n        const { show } = this.props.state;\n        const disabledNodeIds = this.getDisabledNodeIds();\n\n        return <SceneNodeTreeModal show={show} disabledNodeIds={disabledNodeIds}\n            sceneTree={this.props.sceneTree} onRequestClose={this.onCloseModal} onItemClicked={this.onReparentSelected} />\n    }\n\n    private onCloseModal = () =>\n    {\n        store.execute(setReparentModal({show: false}));\n    }\n\n    private getDisabledNodeIds = () =>\n    {\n        const { show, childNodeId } = this.props.state;\n        if (!show)\n        {\n            return [];\n        }\n\n        const { sceneTree } = this.props;\n\n        const child = sceneTree.nodes[childNodeId];\n        return [child.id, child.parentId];\n    }\n\n    private onReparentSelected = (newParent: SceneNode) =>\n    {\n        if (this.props.state.childNodeId == undefined)\n        {\n            return;\n        }\n\n        const child = this.props.sceneTree.nodes[this.props.state.childNodeId];\n        const newTree = sceneTreeMoveChild(this.props.sceneTree, newParent, child);\n        store.execute(setSceneTree(newTree));\n    }\n}", "import { h, Component, Ref, createRef } from 'preact';\nimport { RawSceneModalState, setRawSceneModal, setSceneTree } from '../store/store-state';\nimport { SceneTree } from '../ray-marching/scene-tree';\nimport Modal from './modal';\nimport { store } from '../store/store';\nimport { ChangeEvent } from 'preact/compat';\nimport './raw-scene-modal.scss';\n\ninterface Props\n{\n    readonly state: RawSceneModalState;\n    readonly sceneTree: SceneTree;\n}\n\nexport default class RawSceneModal extends Component<Props>\n{\n    private prevSceneTree: SceneTree | undefined = undefined;\n    private preRef = createRef<HTMLDivElement>();\n\n    public render()\n    {\n        const { show } = this.props.state;\n        const { sceneTree } = this.props;\n        let sceneText = '';\n        if (show && this.prevSceneTree !== sceneTree)\n        {\n            sceneText = JSON.stringify(sceneTree, null, 2);\n        }\n\n        return <Modal show={show} onRequestClose={this.onCloseModal} class='raw-scene-modal'>\n            <div ref={this.preRef} class='raw-scene-modal__text' contenteditable>\n                <pre>{sceneText}</pre>\n            </div>\n\n            <span class='control-group'>\n                <button onClick={this.loadFromHtml}>Load From Json</button>\n                <label class='button'>\n                    Load From File\n                    <input type='file' onChange={this.loadFromFile} />\n                </label>\n                <button onClick={this.downloadText}>Download Json</button>\n            </span>\n        </Modal>;\n    }\n\n    private onCloseModal = () =>\n    {\n        store.execute(setRawSceneModal({show: false}));\n    }\n\n    private downloadText = () =>\n    {\n        const blob = new Blob([this.preRef.current.innerText], { type: 'application/json'});\n\n        const link = document.createElement('a');\n        link.href = URL.createObjectURL(blob);\n        link.download = 'scene.json';\n\n        link.click();\n\n        URL.revokeObjectURL(link.href);\n    }\n\n    private loadFromFile = (e: ChangeEvent<HTMLInputElement>) =>\n    {\n        const file = (e.target as HTMLInputElement).files[0];\n        if (file == undefined)\n        {\n            return;\n        }\n\n        const reader = new FileReader();\n        reader.onload = this.onFileReaderLoad;\n    }\n\n    private onFileReaderLoad = (ev: ProgressEvent<FileReader>): any =>\n    {\n        const reader = ev.target;\n        if (typeof(reader.result) === 'string')\n        {\n            this.loadFromText(reader.result);\n        }\n        else\n        {\n            console.log('Expected string to load file from');\n        }\n    }\n\n    private loadFromHtml = () =>\n    {\n        const json = this.preRef.current.innerText;\n        this.loadFromText(json);\n    }\n\n    private loadFromText = (json: string) =>\n    {\n        const parse = JSON.parse(json);\n        if (parse != null)\n        {\n            store.execute(setSceneTree(parse));\n        }\n    }\n}", "import { h, Component, Fragment } from \"preact\";\nimport { AppState } from \"../store/store-state\";\nimport { WebGLViewport } from \"./webgl-viewport\";\nimport SceneGraph from \"./scene-tree-view\";\nimport { SceneConverter } from \"../ray-marching/scene-converter\";\nimport ReparentModal from \"./reparent-modal\";\nimport \"./webgl-app.scss\"\nimport RawSceneModal from \"./raw-scene-modal\";\n\ninterface Props\n{\n    readonly state: AppState;\n    readonly sceneConverter: SceneConverter;\n}\n\nexport class WebGLApp extends Component<Props>\n{\n    constructor()\n    {\n        super();\n    }\n\n    public render()\n    {\n        const sceneConverter = this.props.sceneConverter;\n        const { viewports, sceneTree, selectedNodeId, reparentModal, rawSceneModal } = this.props.state;\n        console.log('App render', this.props.state);\n\n        return <Fragment>\n            {/* <nav class=\"navbar outer-panel\">\n                <button>File</button>\n            </nav> */}\n\n            <div class=\"main-view\">\n                <div class=\"viewports\">\n                    <WebGLViewport viewportIndex={0} options={viewports[0].options} sceneConverter={sceneConverter} />\n                </div>\n                <SceneGraph sceneTree={sceneTree} selectedNodeId={selectedNodeId} />\n            </div>\n\n            <ReparentModal state={reparentModal} sceneTree={sceneTree} />\n            <RawSceneModal state={rawSceneModal} sceneTree={sceneTree} />\n\n        </Fragment>\n    }\n}", "import equal from \"fast-deep-equal\";\nimport { quatIdentity, rquat, rvec3, rvec4, vec3ApproxEquals, vec3One, vec3Zero, vec4One } from \"../gl-matrix-ts\";\nimport { SceneTree } from \"./scene-tree\";\nimport { LightingModelInt, LightingModelLambert, LightingModelPhong, LightingModelType, LightingModelUnlit, SceneNode, SceneNodes, SdfOpCode, SdfOpCodeInt, SdfOpCodeIntersection, SdfOpCodeNone, SdfOpCodeSubtraction, SdfOpCodeUnion, SdfOpCodeXor, ShapeType, ShapeTypeBox, ShapeTypeHexPrism, ShapeTypeInt, ShapeTypeNone, ShapeTypeSphere } from \"./scene-entities\";\n\ninterface ShaderLight\n{\n    readonly position: rvec3;\n    readonly radius: number;\n    readonly colour: rvec4;\n}\nexport const lightDataSize = 3 + 1 + 4;\n\ninterface ShaderMaterialIndex\n{\n    readonly index: number;\n    readonly weight: number;\n}\ninterface ShaderShape\n{\n    readonly position: rvec3;\n    readonly maxSize: number;\n    readonly rotation: rquat;\n    readonly shapeType: ShapeTypeInt;\n    readonly shapeParams: rvec3;\n    readonly material: number;\n}\nexport const shapeDataSize = 4 + 4 + 4 + 4;\n\ninterface ShaderMaterial\n{\n    readonly diffuseColour: rvec3;\n    readonly lightingModel: LightingModelInt;\n    readonly specularColour: rvec3;\n    readonly shininess: number;\n}\nexport const materialDataSize = 4 + 4;\n\nconst SdfOpCodeMap: { readonly [key: string]: SdfOpCodeInt } =\n{\n    'none': SdfOpCodeNone,\n    'union': SdfOpCodeUnion,\n    'intersection': SdfOpCodeIntersection,\n    'subtraction': SdfOpCodeSubtraction,\n    'xor': SdfOpCodeXor,\n}\nconst ShapeTypeMap: { readonly [key: string]: ShapeTypeInt } =\n{\n    'none': ShapeTypeNone,\n    'box': ShapeTypeBox,\n    'sphere': ShapeTypeSphere,\n    'hexPrism': ShapeTypeHexPrism,\n}\nconst LightingModelMap: { readonly [key: string]: LightingModelInt} =\n{\n    'unlit': LightingModelUnlit,\n    'lambert': LightingModelLambert,\n    'phong': LightingModelPhong\n}\n\nfunction toShapeTypeInt(type: ShapeType): ShapeTypeInt\n{\n    return ShapeTypeMap[type] || ShapeTypeNone;\n}\nfunction toOpCodeInt(type: SdfOpCode): SdfOpCodeInt\n{\n    return SdfOpCodeMap[type] || SdfOpCodeNone;\n}\nfunction toLightingModelInt(type: LightingModelType): LightingModelInt\n{\n    return LightingModelMap[type] || LightingModelUnlit;\n}\n\nexport type ShapeOperation = number | SdfOpCode;\n\nexport class SceneConverter\n{\n    private lights: ShaderLight[] = [];\n    private lightDataArray: number[] = [];\n\n    private materials: ShaderMaterial[] = [];\n    private materialDataArray: number[] = [];\n\n    private shapes: ShaderShape[] = [];\n    private shapeDataArray: number[] = [];\n\n    private operations: ShapeOperation[] = [];\n    private numberOperations: number[] = [];\n\n    private previousTree?: SceneTree;\n\n    public getLightDataArray()\n    {\n        return this.lightDataArray;\n    }\n\n    public getLights()\n    {\n        return this.lights;\n    }\n\n    public getNumLights()\n    {\n        return this.lights.length;\n    }\n\n    public getMaterials()\n    {\n        return this.materials;\n    }\n\n    public getMaterialDataArray()\n    {\n        return this.materialDataArray;\n    }\n\n    public getNumMaterials()\n    {\n        return this.materials.length;\n    }\n\n    public getShapeDataArray()\n    {\n        return this.shapeDataArray;\n    }\n\n    public getShapes()\n    {\n        return this.shapes;\n    }\n\n    public getNumTotalShapes()\n    {\n        return this.shapes.length;\n    }\n\n    public setOperations(operations: ShapeOperation[])\n    {\n        this.operations = operations;\n        this.updateOperationNumbers();\n    }\n\n    public getOperations()\n    {\n        return this.operations;\n    }\n\n    public getOperationNumbers()\n    {\n        return this.numberOperations;\n    }\n\n    public setLight(index: number, light: Partial<ShaderLight>)\n    {\n        if (index < 0)\n        {\n            throw new Error(`Out of bounds light index ${index}`);\n        }\n\n        if (index >= this.lights.length)\n        {\n            this.lights[index] = { ...SceneConverter.createNewLight(), ...light };\n        }\n        else\n        {\n            this.lights[index] = { ...this.lights[index], ...light };\n        }\n\n        this.updateLight(index);\n    }\n\n    public setMaterial(index: number, material: Partial<ShaderMaterial>)\n    {\n        if (index < 0)\n        {\n            throw new Error(`Out of bounds material index ${index}`);\n        }\n\n        if (index >= this.materials.length)\n        {\n            this.materials[index] = { ...SceneConverter.createNewMaterial(), ...material };\n        }\n        else\n        {\n            this.materials[index] = { ...this.materials[index], ...material };\n        }\n\n        this.updateMaterial(index);\n    }\n\n    public updateShapesFromTree(sceneTree: SceneTree)\n    {\n        if (this.previousTree === sceneTree)\n        {\n            return;\n        }\n\n        const rootNode = sceneTree.nodes[sceneTree.rootNodeId];\n        if (!rootNode)\n        {\n            return;\n        }\n\n        const { operations, shapes, lights, materials } = SceneConverter.createShapesFromNode(sceneTree);\n        if (!equal(this.operations, operations))\n        {\n            this.operations = operations;\n            console.log('Operations', this.operations);\n\n            this.updateOperationNumbers();\n        }\n\n        if (!equal(this.shapes, shapes))\n        {\n            console.log('Shapes', this.shapes);\n            this.shapes = shapes;\n            this.shapeDataArray.length = 0;\n            for (let i = 0; i < this.shapes.length; i++)\n            {\n                this.updateShape(i);\n            }\n        }\n\n        if (!equal(this.lights, lights))\n        {\n            this.lights = lights;\n            console.log('Lights', this.lights);\n            this.lightDataArray.length = 0;\n            for (let i = 0; i < this.lights.length; i++)\n            {\n                this.updateLight(i);\n            }\n        }\n\n        if (!equal(this.materials, materials))\n        {\n            this.materials = materials;\n            console.log('Materials', this.materials);\n            this.materialDataArray.length = 0;\n            for (let i = 0; i < this.materials.length; i++)\n            {\n                this.updateMaterial(i);\n            }\n        }\n    }\n\n    public static createShapesFromNode(sceneTree: SceneTree)\n    {\n        const rootNode = sceneTree.nodes[sceneTree.rootNodeId];\n        if (!rootNode)\n        {\n            return;\n        }\n\n        const opsStack: ShapeOperation[] = [];\n        const shapeStack: ShaderShape[] = [];\n        const lights: ShaderLight[] = [];\n        const materials: ShaderMaterial[] = [];\n        this.pushToStack(opsStack, shapeStack, lights, materials, rootNode, sceneTree.nodes);\n\n        opsStack.reverse();\n\n        return {\n            operations: opsStack,\n            shapes: shapeStack,\n            lights, materials\n        };\n    }\n\n    private static pushToStack(opsStack: ShapeOperation[], shapeStack: ShaderShape[], lights: ShaderLight[], materials: ShaderMaterial[], node: SceneNode, nodes: SceneNodes)\n    {\n        if (node.childOpCode !== 'none')\n        {\n            let firstChild = true;\n            for (let i = 0; i < node.childrenIds.length; i++)\n            {\n                const child = nodes[node.childrenIds[i]];\n                if (child.hasShape || child.childOpCode !== 'none')\n                {\n                    if (firstChild)\n                    {\n                        firstChild = false;\n                    }\n                    else\n                    {\n                        opsStack.push(node.childOpCode);\n                    }\n                }\n            }\n        }\n\n        if (node.hasShape)\n        {\n            let index = shapeStack.findIndex(s => equal(s, node.shape));\n            if (index < 0)\n            {\n                index = shapeStack.length;\n                const converted = SceneConverter.convertToShape(node, materials);\n                if (converted != null)\n                {\n                    shapeStack.push(converted);\n                }\n            }\n\n            opsStack.push(index);\n        }\n\n        if (node.hasLight)\n        {\n            const converted = SceneConverter.convertToLight(node);\n            if (converted != null)\n            {\n                lights.push(converted);\n            }\n        }\n\n        for (const childId of node.childrenIds)\n        {\n            this.pushToStack(opsStack, shapeStack, lights, materials, nodes[childId], nodes);\n        }\n    }\n\n    public setShape(index: number, shape: Partial<ShaderShape>)\n    {\n        if (index < 0)\n        {\n            throw new Error(`Out of bounds shape index ${index}`);\n        }\n\n        if (index >= this.shapes.length)\n        {\n            this.shapes[index] = SceneConverter.createNewShape(shape);\n        }\n        else\n        {\n            this.shapes[index] = { ...this.shapes[index], ...shape };\n        }\n\n        this.updateShape(index);\n    }\n\n    private updateLight(index: number)\n    {\n        const dataIndex = index * lightDataSize;\n        const light = this.lights[index];\n\n        this.lightDataArray[dataIndex    ] = light.position.x;\n        this.lightDataArray[dataIndex + 1] = light.position.y;\n        this.lightDataArray[dataIndex + 2] = light.position.z;\n        this.lightDataArray[dataIndex + 3] = light.radius;\n        this.lightDataArray[dataIndex + 4] = light.colour.x;\n        this.lightDataArray[dataIndex + 5] = light.colour.y;\n        this.lightDataArray[dataIndex + 6] = light.colour.z;\n        this.lightDataArray[dataIndex + 7] = light.colour.w;\n    }\n\n    private updateMaterial(index: number)\n    {\n        const dataIndex = index * materialDataSize;\n        const material = this.materials[index];\n\n        this.materialDataArray[dataIndex    ] = material.diffuseColour.x;\n        this.materialDataArray[dataIndex + 1] = material.diffuseColour.y;\n        this.materialDataArray[dataIndex + 2] = material.diffuseColour.z;\n        this.materialDataArray[dataIndex + 3] = material.lightingModel;\n        this.materialDataArray[dataIndex + 4] = material.specularColour.x;\n        this.materialDataArray[dataIndex + 5] = material.specularColour.y;\n        this.materialDataArray[dataIndex + 6] = material.specularColour.z;\n        this.materialDataArray[dataIndex + 7] = material.shininess;\n    }\n\n    private updateShape(index: number)\n    {\n        const dataIndex = index * shapeDataSize;\n        const shape = this.shapes[index];\n\n        this.shapeDataArray[dataIndex     ] = shape.position.x;\n        this.shapeDataArray[dataIndex +  1] = shape.position.y;\n        this.shapeDataArray[dataIndex +  2] = shape.position.z;\n        this.shapeDataArray[dataIndex +  3] = shape.maxSize;\n\n        this.shapeDataArray[dataIndex +  4] = shape.rotation.x;\n        this.shapeDataArray[dataIndex +  5] = shape.rotation.y;\n        this.shapeDataArray[dataIndex +  6] = shape.rotation.z;\n        this.shapeDataArray[dataIndex +  7] = shape.rotation.w;\n\n        this.shapeDataArray[dataIndex +  8] = shape.shapeType;\n        this.shapeDataArray[dataIndex +  9] = shape.shapeParams.x;\n        this.shapeDataArray[dataIndex + 10] = shape.shapeParams.y;\n        this.shapeDataArray[dataIndex + 11] = shape.shapeParams.z;\n\n        this.shapeDataArray[dataIndex + 12] = Math.round(shape.material);\n        this.shapeDataArray[dataIndex + 13] = 0; // Unused, but needed for padding\n        this.shapeDataArray[dataIndex + 14] = 0;\n        this.shapeDataArray[dataIndex + 15] = 0;\n    }\n\n    private updateOperationNumbers()\n    {\n        this.numberOperations = this.operations.map(i =>\n        {\n            if (typeof(i) === 'string')\n            {\n                return toOpCodeInt(i);\n            }\n            return i;\n        });\n    }\n\n    public static convertToShape(sceneNode: SceneNode, materials: ShaderMaterial[]): ShaderShape | null\n    {\n        const shape = sceneNode.shape;\n        if (shape == null)\n        {\n            return null;\n        }\n\n        const material: ShaderMaterial = {\n            diffuseColour: shape.diffuseColour,\n            lightingModel: toLightingModelInt(shape.lightingModel),\n            specularColour: shape.specularColour,\n            shininess: shape.shininess\n        }\n        let materialIndex = this.findApproxMaterial(material, materials);\n        if (materialIndex < 0)\n        {\n            materialIndex = materials.length;\n            materials.push(material);\n        }\n\n        return {\n            material: materialIndex,\n            maxSize: shape.maxSize,\n            position: sceneNode.position,\n            rotation: sceneNode.rotation,\n            shapeParams: shape.shapeParams,\n            shapeType: toShapeTypeInt(shape.type)\n        }\n    }\n\n    public static convertToLight(sceneNode: SceneNode): ShaderLight | null\n    {\n        const light = sceneNode.light;\n        if (light == null)\n        {\n            return null;\n        }\n\n        return {\n            colour: light.colour,\n            position: sceneNode.position,\n            radius: light.radius\n        }\n    }\n\n    public static createNewMaterial(): ShaderMaterial\n    {\n        return {\n            diffuseColour: vec3One(),\n            lightingModel: LightingModelLambert,\n            specularColour: vec3One(),\n            shininess: 10\n        }\n    }\n\n    public static createNewLight(): ShaderLight\n    {\n        return {\n            position: vec3Zero(),\n            radius: 10,\n            colour: vec4One()\n        }\n    }\n\n    public static createNewShape(partial: Partial<ShaderShape>): ShaderShape\n    {\n        return {\n            position: vec3Zero(),\n            rotation: quatIdentity(),\n            maxSize: 0,\n            shapeType: ShapeTypeNone,\n            shapeParams: vec3Zero(),\n            material: 0,\n\n            ...partial\n        }\n    }\n\n    private static findApproxMaterial(material: ShaderMaterial, materials: ShaderMaterial[])\n    {\n        for (let i = 0; i < materials.length; i++)\n        {\n            const current = materials[i];\n            if (current.lightingModel !== material.lightingModel ||\n                Math.abs(current.shininess - material.shininess) < 0.0001)\n            {\n                continue;\n            }\n            if (!vec3ApproxEquals(current.diffuseColour, material.diffuseColour))\n            {\n                continue;\n            }\n            if (!vec3ApproxEquals(current.specularColour, material.specularColour))\n            {\n                continue;\n            }\n\n            return i;\n        }\n\n        return -1;\n    }\n}", "import { h, render } from 'preact';\nimport { WebGLApp } from '../components/webgl-app';\nimport { store } from '../store/store';\nimport { SceneConverter } from '../ray-marching/scene-converter';\nimport { AppState, setSceneTree } from '../store/store-state';\nimport { SceneNode, SceneNodes } from '../ray-marching/scene-entities';\nimport { createNewLightNode, createNewShapeNode, SceneTree, sceneTreeAddChildMutable } from '../ray-marching/scene-tree';\nimport { Editable } from '../common';\nimport Modal from '../components/modal';\nimport '../normalize.css';\nimport './styles.scss';\n\nconst sceneConverter = new SceneConverter();\nstore.subscribe(state => state.sceneTree, updateFromStoreChange);\n\nfunction updateFromStoreChange(state: AppState)\n{\n    sceneConverter.updateShapesFromTree(state.sceneTree);\n}\n\nconst appEl = document.getElementById(\"app\");\nfunction renderApp()\n{\n    render(<WebGLApp state={store.state()} sceneConverter={sceneConverter} />, appEl);\n    Modal.afterRender();\n}\n\nrenderApp();\nstore.subscribeAny(renderApp);\n\nfunction makeNodeMap(...nodes: SceneNode[]): SceneNodes\n{\n    const result: Editable<SceneNodes> = {};\n    for (const node of nodes)\n    {\n        result[node.id] = node;\n    }\n    return result;\n}\n\nfunction loadDefaultSdfScene()\n{\n    const rootNode = createNewShapeNode('Root', null, undefined, undefined, 'subtraction');\n    const hexPrism = createNewShapeNode('Hex Prism', {\n        type: 'hexPrism',\n        shapeParams: {x: 0.75, y: 2, z: 0},\n        maxSize: 1.5,\n        diffuseColour: {x: 0.5, y: 0.5, z: 0.5}\n    });\n    const boxAndSphere = createNewShapeNode('Box & Sphere', undefined, undefined, undefined, 'union');\n\n    sceneTreeAddChildMutable(rootNode, hexPrism);\n    sceneTreeAddChildMutable(rootNode, boxAndSphere);\n\n    const box = createNewShapeNode('Box', {\n        type: \"box\",\n        shapeParams: { x: 6, y: 1, z: 6 },\n        diffuseColour: { x: 0.2, y: 0.25, z: 0.3 },\n        lightingModel: 'lambert'\n    }, { x: 0, y: -1.5, z: 0 });\n    const sphere = createNewShapeNode('Sphere', {\n        type: \"sphere\",\n        shapeParams: { x: 1, y: 2, z: 1 },\n        maxSize: 2.0,\n        diffuseColour: { x: 0.1, y: 0.2, z: 0.9 },\n        lightingModel: 'phong'\n    })\n    sceneTreeAddChildMutable(boxAndSphere, box);\n    sceneTreeAddChildMutable(boxAndSphere, sphere);\n\n    const redLight = createNewLightNode('Red Light', {\n        colour: {x: 1.0, y: 0.8, z: 0.6, w: 1}\n    }, {x: 4, y: 2, z: 3});\n    const greenLight = createNewLightNode('Green Light', {\n        colour: {x: 0.2, y: 1.0, z: 0.6, w: 1}\n    }, {x: -4, y: 2, z: 3});\n    sceneTreeAddChildMutable(rootNode, redLight);\n    sceneTreeAddChildMutable(rootNode, greenLight);\n\n    const nodes = makeNodeMap(rootNode, hexPrism, boxAndSphere, box, sphere, redLight, greenLight);\n\n    const tree: SceneTree = {\n        nodes, rootNodeId: rootNode.id\n    }\n\n    store.execute(setSceneTree(tree));\n}\n\nloadDefaultSdfScene();"],
  "mappings": "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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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",
  "names": ["EmptyModifier", "exports", "DataStore", "initialState", "modifier", "isNewState", "newState", "selector", "subscription", "comparer", "selectorName", "startValue", "obj", "SelectorContext", "index", "callback", "state", "newValue", "name", "result", "require_fast_deep_equal", "__commonJSMin", "exports", "module", "equal", "a", "b", "length", "i", "keys", "key", "slice", "options", "vnodeId", "isValidElement", "rerenderQueue", "prevDebounce", "defer", "depthSort", "CAPTURE_REGEX", "eventClock", "eventProxy", "eventProxyCapture", "i", "EMPTY_OBJ", "EMPTY_ARR", "IS_NON_DIMENSIONAL", "isArray", "Array", "assign", "obj", "props", "removeNode", "node", "parentNode", "removeChild", "createElement", "type", "children", "key", "ref", "normalizedProps", "arguments", "length", "call", "defaultProps", "createVNode", "original", "vnode", "__k", "__", "__b", "__e", "__c", "constructor", "__v", "__i", "__u", "createRef", "current", "Fragment", "BaseComponent", "context", "this", "getDomSibling", "childIndex", "sibling", "updateParentDomPointers", "child", "base", "enqueueRender", "c", "__d", "push", "process", "__r", "debounceRendering", "component", "newVNode", "oldVNode", "oldDom", "commitQueue", "refQueue", "l", "sort", "shift", "__P", "diff", "__n", "namespaceURI", "commitRoot", "diffChildren", "parentDom", "renderResult", "newParentVNode", "oldParentVNode", "globalContext", "namespace", "excessDomChildren", "isHydrating", "childVNode", "newDom", "firstChildDom", "result", "oldChildren", "newChildrenLength", "constructNewChildrenArray", "applyRef", "insert", "nextSibling", "skewedIndex", "matchingIndex", "oldChildrenLength", "remainingOldChildren", "skew", "String", "undefined", "findMatchingIndex", "unmount", "parentVNode", "contains", "insertBefore", "nodeType", "toChildArray", "out", "some", "x", "y", "setStyle", "style", "value", "setProperty", "test", "dom", "name", "oldValue", "useCapture", "lowerCaseName", "o", "cssText", "replace", "toLowerCase", "_attached", "addEventListener", "removeEventListener", "e", "removeAttribute", "setAttribute", "createEventProxy", "eventHandler", "_dispatched", "event", "tmp", "isNew", "oldProps", "oldState", "snapshot", "clearProcessingException", "newProps", "isClassComponent", "provider", "componentContext", "renderHook", "count", "newType", "outer", "prototype", "render", "contextType", "__E", "doRender", "sub", "state", "__h", "_sb", "__s", "getDerivedStateFromProps", "componentWillMount", "componentDidMount", "componentWillReceiveProps", "shouldComponentUpdate", "componentWillUpdate", "componentDidUpdate", "getChildContext", "getSnapshotBeforeUpdate", "cloneNode", "then", "MODE_HYDRATE", "indexOf", "diffElementNodes", "diffed", "root", "cb", "map", "newHtml", "oldHtml", "newChildren", "inputValue", "checked", "localName", "document", "createTextNode", "createElementNS", "is", "__m", "data", "childNodes", "attributes", "__html", "innerHTML", "content", "hasRefUnmount", "skipRemove", "r", "componentWillUnmount", "replaceNode", "documentElement", "firstChild", "slice", "EMPTY_ARR", "options", "__e", "error", "vnode", "oldVNode", "errorInfo", "component", "ctor", "handled", "__", "__c", "constructor", "getDerivedStateFromError", "setState", "__d", "componentDidCatch", "__E", "e", "vnodeId", "isValidElement", "undefined", "BaseComponent", "prototype", "update", "callback", "s", "this", "__s", "state", "assign", "props", "__v", "_sb", "push", "enqueueRender", "forceUpdate", "__h", "render", "Fragment", "rerenderQueue", "defer", "Promise", "then", "bind", "resolve", "setTimeout", "depthSort", "a", "b", "__b", "process", "__r", "CAPTURE_REGEX", "eventClock", "eventProxy", "createEventProxy", "eventProxyCapture", "i", "vert_default", "frag_default", "sdf_functions_default", "includePragma", "Shader", "_Shader", "program", "includes", "text", "matches", "match", "toInclude", "gl", "vertText", "fragText", "cleanup", "vert", "frag", "error", "mathf", "_mathf", "a", "b", "value", "min", "max", "t", "current", "target", "maxDelta", "difference", "vec3ScaleAndAddBy", "target", "left", "right", "scale", "vec3Distance", "dx", "dy", "dz", "vec3TransformQuat", "out", "v", "q", "x", "y", "z", "w2", "uvx", "uvy", "uvz", "uuvx", "uuvy", "uuvz", "vec3Zero", "vec3One", "vec3ApproxEquals", "left", "right", "delta", "vec3Distance", "vec4One", "quatIdentity", "quatFromEuler", "q", "x", "y", "z", "order", "mathf", "halfToRad", "sx", "cx", "sy", "cy", "sz", "cz", "positions", "tempAxisQuat", "quatIdentity", "mat3ArraySetFromQuat", "m", "q", "x2", "y2", "z2", "xx", "yx", "yy", "zx", "zy", "zz", "wx", "wy", "wz", "WebGLSdfRenderer", "_WebGLSdfRenderer", "vec3Zero", "gl", "shader", "positionBuffer", "uShapes", "uOperations", "uNumOperations", "uHighlight", "uLights", "uNumLights", "uMaterials", "uCameraPosition", "uCameraMatrix", "uAspectRatio", "uMaxMarchingSteps", "uEpsilon", "uFlags", "horizontal", "vertical", "quatFromEuler", "forward", "vec3TransformQuat", "vec3ScaleAndAddBy", "width", "height", "scaledWidth", "scaledHeight", "aspectRatio", "scene", "ops", "canvas", "includeLookup", "sdf_functions_default", "Shader", "vert_default", "frag_default", "positionAttributeLoc", "name", "attribute", "location", "import_simple_data_store", "defaultRenderOptions", "defaultViewport", "store", "DataStore", "SdfOpCodeNone", "SdfOpCodeUnion", "SdfOpCodeIntersection", "SdfOpCodeSubtraction", "SdfOpCodeXor", "ShapeTypeNone", "ShapeTypeBox", "ShapeTypeSphere", "ShapeTypeHexPrism", "LightingModelUnlit", "LightingModelLambert", "LightingModelPhong", "makeShapeNodeId", "sceneTreeUpdateNode", "tree", "node", "newNodes", "sceneTreeFlatten", "tree", "rootNode", "result", "addToTree", "createNewLight", "light", "vec4One", "createSceneNode", "name", "node", "makeShapeNodeId", "vec3Zero", "quatIdentity", "createNewShape", "createNewLightNode", "position", "rotation", "createNewShapeNode", "shape", "childOpCode", "sceneTreeAddChildMutable", "parent", "child", "sceneTreeAddChild", "tree", "nodes", "sceneTreeDeleteChild", "oldParent", "oldIndex", "id", "childrenIds", "sceneTreeMoveChild", "newParent", "addToTree", "depth", "index", "result", "childId", "setViewportOptions", "index", "options", "state", "viewport", "defaultViewport", "newViewport", "viewports", "setReparentModal", "setRawSceneModal", "updateNode", "node", "sceneTreeUpdateNode", "setSceneTree", "sceneTree", "setSelectedNode", "selectedNodeId", "selectedParentNodeId", "LabeledRange", "props", "_", "WebGLViewportOptions", "x", "pixelated", "renderScale", "enableShadows", "enableShowMarching", "epsilon", "maxMarchingStep", "store", "setRawSceneModal", "value", "options", "setViewportOptions", "selectedValue", "WebGLViewport", "x", "b", "canvasEl", "WebGLSdfRenderer", "canvasClassName", "_", "WebGLViewportOptions", "size", "options", "dx", "dy", "delta", "newZoom", "isVec3", "x", "isVec4", "VectorView", "v", "disabled", "isV3", "isV4", "_", "field", "strValue", "value", "ShapeView", "x", "shape", "isPhong", "_", "VectorView", "value", "oldVec", "newVec", "field", "newShape", "LightView", "x", "light", "_", "VectorView", "oldVec", "newVec", "value", "field", "newShape", "SceneNodeView", "x", "node", "sceneTree", "_", "parent", "selectedOpCode", "VectorView", "ShapeView", "LightView", "k", "newTree", "sceneTreeAddChild", "createSceneNode", "store", "setSceneTree", "sceneTreeDeleteChild", "setReparentModal", "currentHasShape", "currentHasLight", "value", "oldVec", "newVec", "oldQuat", "newQuat", "shape", "light", "field", "newNode", "addClass", "target", "className", "addIfTrue", "ShapeNodeTreeItem", "x", "depth", "node", "isSelected", "disable", "className", "addClass", "_", "SceneNodeTree", "x", "_", "sceneTree", "selectedNodeId", "onItemClicked", "rootNode", "result", "flattenedTree", "sceneTreeFlatten", "entry", "isSelected", "ShapeNodeTreeItem", "SceneTreeView", "x", "sceneTree", "selectedNodeId", "selectedNode", "_", "SceneNodeTree", "SceneNodeView", "node", "store", "setSelectedNode", "newNode", "oldNode", "updateNode", "currentIndex", "currentComponent", "previousComponent", "prevRaf", "afterPaintEffects", "options", "_options", "oldBeforeDiff", "__b", "oldBeforeRender", "__r", "oldAfterDiff", "diffed", "oldCommit", "__c", "oldBeforeUnmount", "unmount", "oldRoot", "__", "flushAfterPaintEffects", "component", "afterPaintEffects", "shift", "__P", "__H", "__h", "forEach", "invokeCleanup", "invokeEffect", "e", "options", "__e", "__v", "__b", "vnode", "currentComponent", "oldBeforeDiff", "__", "parentDom", "__k", "__m", "oldRoot", "__r", "oldBeforeRender", "currentIndex", "hooks", "__c", "previousComponent", "hookItem", "__N", "_pendingArgs", "diffed", "oldAfterDiff", "c", "length", "push", "prevRaf", "requestAnimationFrame", "afterNextFrame", "commitQueue", "some", "filter", "cb", "oldCommit", "unmount", "oldBeforeUnmount", "hasErrored", "s", "HAS_RAF", "callback", "raf", "done", "clearTimeout", "timeout", "cancelAnimationFrame", "setTimeout", "hook", "comp", "cleanup", "assign", "obj", "props", "i", "shallowDiffers", "a", "b", "useLayoutEffect", "PureComponent", "p", "c", "this", "props", "context", "PureComponent", "prototype", "Component", "isPureReactComponent", "shouldComponentUpdate", "props", "state", "shallowDiffers", "this", "oldDiffHook", "options", "__b", "vnode", "type", "__f", "ref", "REACT_FORWARD_SYMBOL", "Symbol", "for", "oldCatchError", "options", "__e", "error", "newVNode", "oldVNode", "errorInfo", "then", "component", "vnode", "__", "__c", "__k", "oldUnmount", "unmount", "detachedClone", "detachedParent", "parentDom", "__H", "forEach", "effect", "assign", "__P", "map", "child", "removeOriginal", "originalParent", "__v", "appendChild", "Suspense", "this", "__u", "_suspenders", "__b", "suspended", "__a", "SuspenseList", "this", "_next", "_map", "options", "unmount", "vnode", "component", "__c", "__R", "__u", "type", "oldUnmount", "Suspense", "prototype", "Component", "promise", "suspendingVNode", "suspendingComponent", "c", "_suspenders", "push", "resolve", "suspended", "__v", "resolved", "onResolved", "onSuspensionComplete", "state", "__a", "suspendedVNode", "__k", "removeOriginal", "__P", "__O", "setState", "__b", "pop", "forceUpdate", "then", "componentWillUnmount", "render", "props", "detachedParent", "document", "createElement", "detachedComponent", "detachedClone", "fallback", "Fragment", "children", "list", "child", "node", "delete", "revealOrder", "size", "length", "ContextProvider", "getChildContext", "context", "Portal", "_this", "container", "_container", "_temp", "root", "__m", "__", "nodeType", "parentNode", "childNodes", "contains", "insertBefore", "before", "removeChild", "splice", "indexOf", "createPortal", "el", "containerInfo", "delegated", "get", "unsuspend", "wrappedUnsuspend", "Map", "toChildArray", "reverse", "i", "set", "componentDidUpdate", "componentDidMount", "forEach", "REACT_ELEMENT_TYPE", "Symbol", "for", "CAMEL_PROPS", "ON_ANI", "CAMEL_REPLACE", "IS_DOM", "onChangeInputType", "test", "Component", "prototype", "isReactComponent", "forEach", "key", "Object", "defineProperty", "configurable", "get", "this", "set", "v", "writable", "value", "oldEventHook", "options", "event", "empty", "isPropagationStopped", "cancelBubble", "isDefaultPrevented", "defaultPrevented", "e", "persist", "nativeEvent", "currentComponent", "classNameDescriptorNonEnumberable", "enumerable", "class", "oldVNodeHook", "vnode", "type", "props", "normalizedProps", "isNonDashedType", "indexOf", "i", "IS_DOM", "lowerCased", "toLowerCase", "onChangeInputType", "ON_ANI", "test", "CAMEL_PROPS", "replace", "CAMEL_REPLACE", "multiple", "Array", "isArray", "toChildArray", "children", "child", "selected", "defaultValue", "className", "$$typeof", "REACT_ELEMENT_TYPE", "oldBeforeRender", "__r", "__c", "oldDiffed", "diffed", "dom", "__e", "Modal", "_Modal", "x", "show", "onRequestClose", "portalContainer", "modalEl", "baseClassName", "className", "$", "_", "toHide", "toShow", "elName", "count", "prevCount", "el", "container", "current", "SceneNodeTreeModal", "x", "show", "sceneTree", "disabledNodeIds", "onRequestClose", "_", "Modal", "SceneNodeTree", "node", "ReparentModal", "x", "show", "disabledNodeIds", "_", "SceneNodeTreeModal", "store", "setReparentModal", "childNodeId", "sceneTree", "child", "newParent", "newTree", "sceneTreeMoveChild", "setSceneTree", "RawSceneModal", "x", "b", "show", "sceneTree", "sceneText", "_", "Modal", "store", "setRawSceneModal", "blob", "link", "reader", "ev", "json", "parse", "setSceneTree", "WebGLApp", "x", "sceneConverter", "viewports", "sceneTree", "selectedNodeId", "reparentModal", "rawSceneModal", "_", "k", "WebGLViewport", "SceneTreeView", "ReparentModal", "RawSceneModal", "import_fast_deep_equal", "lightDataSize", "shapeDataSize", "materialDataSize", "SdfOpCodeMap", "SdfOpCodeNone", "SdfOpCodeUnion", "SdfOpCodeIntersection", "SdfOpCodeSubtraction", "SdfOpCodeXor", "ShapeTypeMap", "ShapeTypeNone", "ShapeTypeBox", "ShapeTypeSphere", "ShapeTypeHexPrism", "LightingModelMap", "LightingModelUnlit", "LightingModelLambert", "LightingModelPhong", "toShapeTypeInt", "type", "toOpCodeInt", "toLightingModelInt", "SceneConverter", "_SceneConverter", "operations", "index", "light", "material", "sceneTree", "shapes", "lights", "materials", "equal", "i", "rootNode", "opsStack", "shapeStack", "node", "nodes", "firstChild", "child", "s", "converted", "childId", "shape", "dataIndex", "sceneNode", "materialIndex", "vec3One", "vec3Zero", "vec4One", "partial", "quatIdentity", "current", "vec3ApproxEquals", "sceneConverter", "SceneConverter", "store", "state", "updateFromStoreChange", "appEl", "renderApp", "E", "_", "WebGLApp", "Modal", "makeNodeMap", "nodes", "result", "node", "loadDefaultSdfScene", "rootNode", "createNewShapeNode", "hexPrism", "boxAndSphere", "sceneTreeAddChildMutable", "box", "sphere", "redLight", "createNewLightNode", "greenLight", "tree", "setSceneTree"]
}
