{
  "version": 3,
  "sources": ["../src/gl-matrix-ts/mathf.ts", "../src/gl-matrix-ts/vec3.ts", "../src/gl-matrix-ts/mat4.ts", "../src/gl-matrix-ts/vec2.ts", "../src/gl-matrix-ts/vec4.ts", "../src/gl-matrix-ts/quat.ts", "../src/sdf-scene.ts", "../src/ray-marching.ts", "../src/render-scenes.ts", "../src/worker.ts"],
  "sourcesContent": ["/**\n * Common utilities\n * @module glMatrix\n */\nexport type AngleOrder = 'xyz' | 'xzy' | 'yxz' | 'yzx' | 'zxy' | 'zyx';\n\nexport default class mathf {\n    // Configuration Constants\n    static readonly EPSILON = 0.000001;\n    static readonly ANGLE_ORDER: AngleOrder = \"zyx\";\n    static readonly DegToRad = Math.PI / 180;\n    static readonly RadToDeg = 180 / Math.PI;\n\n    /**\n     * Convert Degree To Radian\n     *\n     * @param {number} a Angle in Degrees\n     */\n    static toRadian(a: number) {\n        return a * this.DegToRad;\n    }\n\n    /**\n     * Tests whether or not the arguments have approximately the same value, within an absolute\n     * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n     * than or equal to 1.0, and a relative tolerance is used for larger values)\n     *\n     * @param {number} a The first number to test.\n     * @param {number} b The second number to test.\n     * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n     */\n    equals(a: number, b: number) {\n        return Math.abs(a - b) <= mathf.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n    }\n\n    /**\n     * \u9650\u5B9A\u5728\u6700\u5C0F\u503C\u548C\u6700\u5927\u503C\u4E4B\u95F4\n     * @param value\n     * @param min\n     * @param max\n     * @returns\n     */\n    public static clamp(value: number, min: number, max: number) {\n        return Math.max(Math.min(value, max), min);\n    }\n\n    /**\n     * \u63D2\u503C\n     * @param a\n     * @param b\n     * @param t\n     * @returns\n     */\n    public static lerp(a: number, b: number, t: number) {\n        return a + (b - a) * t;\n    }\n\n    /**\n     * \u5F53\u524D\u503C\u5411target\u6BCF\u6B21\u6700\u591A\u79FB\u52A8maxDelta\u8DDD\u79BB\n     * @param current\n     * @param target\n     * @param maxDelta\n     * @returns\n     */\n    public static moveTowards(current: number, target: number, maxDelta: number) {\n        const difference = target - current;\n        if (Math.abs(difference) <= maxDelta) {\n            return target;\n        } else {\n            return current + Math.sign(difference) * maxDelta;\n        }\n    }\n\n    /**\n     * \u53CD\u63D2\u503C\n     * @param a\n     * @param b\n     * @param t\n     * @returns\n     */\n    inverseLerp(a: number, b: number, t: number) {\n        if (a === b) {\n            return 0;\n        } else {\n            return (t - a) / (b - a);\n        }\n    }\n}", "import { rmat3 } from \"./mat3\";\nimport { rmat4 } from \"./mat4\";\nimport { rquat } from \"./quat\";\n\nexport interface vec3\n{\n    x: number;\n    y: number;\n    z: number;\n}\n\nexport type rvec3 = Readonly<vec3>;\n\n/**\n * Clones this vector\n *\n * @param v the vector to clone\n * @returns a new vector\n */\nexport function vec3Clone(v: rvec3): vec3\n{\n    return {x: v.x, y: v.y, z: v.z};\n}\n\n/**\n * Copy the values from one vec3 to another\n * @param v the target vector\n * @param a the copy vector\n * @returns the target vector\n */\nexport function vec3Copy(v: vec3, a: rvec3)\n{\n    v.x = a.x;\n    v.y = a.y;\n    v.z = a.z;\n    return v;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param v the target vector\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @returns the target vector\n */\nexport function vec3Set(v: vec3, x: number, y: number, z: number)\n{\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Calculates the length vector v\n *\n * @params the source vector\n * @returns length of v\n */\nexport function vec3Length(v: rvec3)\n{\n    return Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2);\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @returns squared length of v\n */\nexport function vec3SquaredLength(v: rvec3)\n{\n    return v.x ** 2 + v.y ** 2 + v.z ** 2;\n}\n\n/**\n * Adds vector other into vec\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3AddTo(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x + right.x;\n    v.y = left.y + right.y;\n    v.z = left.z + right.z;\n    return v;\n}\n\n/**\n * Adds two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Add(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n    }\n}\n\n/**\n * Subtracts vector other from vector vec\n\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3SubFrom(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x - right.x;\n    v.y = left.y - right.y;\n    v.z = left.z - right.z;\n    return v;\n}\n\n/**\n * Subtracts vector other from vector vec into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Sub(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n    }\n}\n\n/**\n * Multiplies the left vector by the right vector\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3MulTo(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x * right.x;\n    v.y = left.y * right.y;\n    v.z = left.z * right.z;\n    return v;\n}\n\n/**\n * Multiplies the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Mul(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x * right.x,\n        y: left.y * right.y,\n        z: left.z * right.z,\n    }\n}\n\n/**\n * Divides the left vector by the right vector\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3DivBy(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    v.x = left.x / right.x;\n    v.y = left.y / right.y;\n    v.z = left.z / right.z;\n    return v;\n}\n\n/**\n * Divides the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Div(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.x / right.x,\n        y: left.y / right.y,\n        z: left.z / right.z,\n    }\n}\n\n/**\n * Scales the target vector by a scalar number\n * @param v the target vector\n * @param left the left vector\n * @param right amount to scale the vector by\n * @returns the target vector\n */\nexport function vec3ScaleBy(v: vec3, left: vec3 | rvec3, right: number)\n{\n    v.x = left.x * right;\n    v.y = left.y * right;\n    v.z = left.z * right;\n    return v;\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec3Scale(v: rvec3, scale: number): vec3\n{\n    return {\n        x: v.x * scale,\n        y: v.y * scale,\n        z: v.z * scale\n    };\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec3ScaleAndAddBy(target: vec3, left: rvec3, right: rvec3, scale: number): vec3\n{\n    target.x = left.x + (right.x * scale);\n    target.y = left.y + (right.y * scale);\n    target.z = left.z + (right.z * scale);\n    return target;\n}\n\n/**\n * Calculates the Euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns the distance between left and right\n */\nexport function vec3Distance(left: rvec3, right: rvec3)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    return Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);\n}\n\n/**\n * Calculates the squared euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns the square distance between left and right\n */\nexport function vec3SquaredDistance(left: rvec3, right: rvec3)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    return dx ** 2 + dy ** 2 + dz ** 2;\n}\n\n/**\n * Negates the components of vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec3Negate(v: vec3)\n{\n    v.x = -v.x;\n    v.y = -v.y;\n    v.z = -v.z;\n    return v;\n}\n\n/**\n * Negates the components of vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Negated(v: rvec3): vec3\n{\n    return {\n        x: -v.x,\n        y: -v.y,\n        z: -v.z\n    }\n}\n\n/**\n * Inverse of the components of a vector\n *\n * @param v the target vector\n * @param source the source vector\n * @returns the target vector\n */\nexport function vec3Inverse(v: vec3, source: vec3 | rvec3)\n{\n    v.x = 1.0 / source.x;\n    v.y = 1.0 / source.y;\n    v.z = 1.0 / source.z;\n    return v;\n}\n\n/**\n * Returns the inverse of the components of a vector into a new vector\n *\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Inversed(v: rvec3): vec3\n{\n    return {\n        x: 1.0 / v.x,\n        y: 1.0 / v.y,\n        z: 1.0 / v.z\n    };\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec3Normalize(v: vec3, source: vec3 | rvec3)\n{\n    let sqrtLen = vec3SquaredLength(source);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x = source.x * sqrtLen;\n    v.y = source.y * sqrtLen;\n    v.z = source.z * sqrtLen;\n    return v;\n}\n\nexport function vec3NormalizeValues(v: vec3, x: number, y: number, z: number)\n{\n    let sqrtLen = x ** 2 + y ** 2 + z ** 2;\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x = x * sqrtLen;\n    v.y = y * sqrtLen;\n    v.z = z * sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3Normalized(v: rvec3): vec3\n{\n    let sqrtLen = vec3SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen\n    }\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec3NormalizedValues(x: number, y: number, z: number): vec3\n{\n    let sqrtLen = x ** 2 + y ** 2 + z ** 2;\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: x * sqrtLen,\n        y: y * sqrtLen,\n        z: z * sqrtLen\n    }\n}\n\n/**\n * Calculates the dot product of two vec3's\n * @param left the left vector\n * @param right the right vector\n * @returns dot product of left and right\n */\nexport function vec3Dot(left: rvec3, right: rvec3)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z;\n}\n\n/**\n * Computes the cross product of two vectors into the target vector\n *\n * @param v the  target vector\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec3CrossBy(v: vec3, left: vec3 | rvec3, right: rvec3)\n{\n    const x = left.y * right.z - left.z * right.y;\n    const y = left.z * right.x - left.x * right.z;\n    const z = left.x * right.y - left.y * right.x;\n\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Computes the cross product of two vectors into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec3Cross(left: rvec3, right: rvec3): vec3\n{\n    return {\n        x: left.y * right.z - left.z * right.y,\n        y: left.z * right.x - left.x * right.z,\n        z: left.x * right.y - left.y * right.x\n    };\n}\n\n/**\n * Performs a linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs (not clamped)\n * @returns a new vector\n */\nexport function vec3Lerp(left: rvec3, right: rvec3, t: number): vec3\n{\n    return {\n        x: left.x + t * (right.x - left.x),\n        y: left.y + t * (right.y - left.y),\n        z: left.z + t * (right.z - left.z)\n    };\n}\n\n/**\n * Performs a spherical linear interpolation between two vectors\n *\n * @param v the target vector\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3SlerpBy(v: vec3, left: vec3 | rvec3, right: rvec3, t: number)\n{\n    const angle = Math.acos(Math.min(Math.max(vec3Dot(left, right), -1), 1));\n    const sinTotal = 1.0 / Math.sin(angle);\n\n    const ratioA = Math.sin((1 - t) * angle) * sinTotal;\n    const ratioB = Math.sin(t * angle) * sinTotal;\n\n    const x = ratioA * left.x + ratioB * right.x;\n    const y = ratioA * left.y + ratioB * right.y;\n    const z = ratioA * left.z + ratioB * right.z;\n\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Performs a spherical linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns a new vector\n */\nexport function vec3Slerp(left: rvec3, right: rvec3, t: number): vec3\n{\n    const angle = Math.acos(Math.min(Math.max(vec3Dot(left, right), -1), 1));\n    const sinTotal = 1.0 / Math.sin(angle);\n\n    const ratioA = Math.sin((1 - t) * angle) * sinTotal;\n    const ratioB = Math.sin(t * angle) * sinTotal;\n\n    return {\n        x: ratioA * left.x + ratioB * right.x,\n        y: ratioA * left.y + ratioB * right.y,\n        z: ratioA * left.z + ratioB * right.z\n    };\n}\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param v the target vector\n * @param v1 the first operand\n * @param v2 the second operand\n * @param v3 the third operand\n * @param v4 the fourth operand\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3Hermite(v: vec3, v1: rvec3, v2: rvec3, v3: rvec3, v4: rvec3, t: number)\n{\n    const factorTimes2 = t * t;\n    const factor1 = factorTimes2 * (2 * t - 3) + 1;\n    const factor2 = factorTimes2 * (t - 2) + t;\n    const factor3 = factorTimes2 * (t - 1);\n    const factor4 = factorTimes2 * (3 - 2 * t);\n\n    v.x = v1.x * factor1 + v2.x * factor2 + v3.x * factor3 + v4.x * factor4;\n    v.y = v1.y * factor1 + v2.y * factor2 + v3.y * factor3 + v4.y * factor4;\n    v.z = v1.z * factor1 + v2.z * factor2 + v3.z * factor3 + v4.z * factor4;\n    return v;\n}\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param v the target vector\n * @param v1 the first operand\n * @param v2 the second operand\n * @param v3 the third operand\n * @param v4 the fourth operand\n * @param t interpolation amount, in the range [0-1], between the two inputs\n * @returns the target vector\n */\nexport function vec3Bezier(v: vec3, v1: rvec3, v2: rvec3, v3: rvec3, v4: rvec3, t: number)\n{\n    const inverseFactor = 1 - t;\n    const inverseFactorTimesTwo = inverseFactor * inverseFactor;\n    const factorTimes2 = t * t;\n    const factor1 = inverseFactorTimesTwo * inverseFactor;\n    const factor2 = 3 * t * inverseFactorTimesTwo;\n    const factor3 = 3 * factorTimes2 * inverseFactor;\n    const factor4 = factorTimes2 * t;\n\n    v.x = v1.x * factor1 + v2.x * factor2 + v3.x * factor3 + v4.x * factor4;\n    v.y = v1.y * factor1 + v2.y * factor2 + v3.y * factor3 + v4.y * factor4;\n    v.z = v1.z * factor1 + v2.z * factor2 + v3.z * factor3 + v4.z * factor4;\n    return v;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param out the target vector\n * @param m the matrix to transform with\n * @returns the target matrix\n */\nexport function vec3TransformMat4(out: vec3, v: vec3 | rvec3, m: rmat4)\n{\n    const vx = v.x,\n        vy = v.y,\n        vz = v.z;\n\n    let w = m.m03 * vx + m.m13 * vy + m.m23 * vz + m.m33;\n    if (w != 0)\n    {\n        w = 1.0 / w;\n    }\n    else\n    {\n        w = 1.0;\n    }\n\n    out.x = (m.m00 * vx + m.m10 * vy + m.m20 * vz + m.m30) / w;\n    out.y = (m.m01 * vx + m.m11 * vy + m.m21 * vz + m.m31) / w;\n    out.z = (m.m02 * vx + m.m12 * vy + m.m22 * vz + m.m32) / w;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param v the target vector\n * @param m the 3x3 matrix to transform with\n * @returns the target vector\n */\nexport function vec3TransformMat3(out: vec3, v: vec3 | rvec3, m: rmat3)\n{\n    const vx = v.x,\n        vy = v.y,\n        vz = v.z;\n\n    out.x = vx * m.m00 + vy * m.m10 + vz * m.m20,\n    out.y = vx * m.m01 + vy * m.m11 + vz * m.m21,\n    out.z = vx * m.m02 + vy * m.m12 + vz * m.m22\n    return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param out the target vector\n * @param v the vector transform\n * @param q quaternion to transform with\n * @returns the target vector\n */\nexport function vec3TransformQuat(out: vec3, v: vec3 | rvec3, q: rquat)\n{\n    if (q.x === 0 && q.y === 0 && q.z === 0 && q.w === 1)\n    {\n        out.x = v.x;\n        out.y = v.y;\n        out.z = v.z;\n        return out;\n    }\n\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n    const x = v.x,\n        y = v.y,\n        z = v.z;\n\n    const w2 = q.w * 2;\n    let uvx = q.y * z - q.z * y,\n        uvy = q.z * x - q.x * z,\n        uvz = q.x * y - q.y * x;\n\n    const uuvx = (q.y * uvz - q.z * uvy) * 2,\n        uuvy = (q.z * uvx - q.x * uvz) * 2,\n        uuvz = (q.x * uvy - q.y * uvx) * 2;\n\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n\n    // return vec3.add(out, a, vec3.add(out, uv, uuv));\n    out.x = x + uvx + uuvx;\n    out.y = y + uvy + uuvy;\n    out.z = z + uvz + uuvz;\n    return out;\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} origin The origin of the rotation\n * @param {number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n/*\nexport function vec3RotateX(out: vec3, v: vec3 | rvec3, origin: rvec3, rad: number)\n{\n    //Translate point to the origin\n    const px = v.x - origin.x,\n        py = v.y - origin.y,\n        pz = v.z - origin.z;\n\n    const srad = Math.sin(rad),\n        crad = Math.cos(rad);\n\n    //perform rotation\n    //rx = px;\n    const ry = py * crad - pz * srad,\n        rz = py * srad + pz * crad;\n\n    //translate to correct position\n    out.x = px + origin.x;\n    out.y = ry + origin.y;\n    out.z = rz + origin.z;\n    return out;\n}\n    */\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     * @param {vec3} origin The origin of the rotation\n     * @param {number} rad The angle of rotation in radians\n     * @returns {vec3} out\n     */\n    /*\n    rotateY(origin: vec3, rad: number) {\n        const data = this.data;\n        const b = origin.data;\n        let p = ,\n            r = [];\n        //Translate point to the origin\n        p[0] = data[0] - b[0];\n        p[1] = data[1] - b[1];\n        p[2] = data[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n\n        //translate to correct position\n\n        return this.set(r[0] + b[0], r[1] + b[1], r[2] + b[2]);\n    }\n        */\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     * @param {vec3} origin The origin of the rotation\n     * @param {number} rad The angle of rotation in radians\n     * @returns {vec3} out\n     */\n    /*\n    rotateZ(origin: vec3, rad: number) {\n        const data = this.data;\n        const b = origin.data;\n        let p = [],\n            r = [];\n        //Translate point to the origin\n        p[0] = data[0] - b[0];\n        p[1] = data[1] - b[1];\n        p[2] = data[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n        r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n        r[2] = p[2];\n\n        //translate to correct position\n\n        return this.set(r[0] + b[0], r[1] + b[1], r[2] + b[2]);\n    }\n        */\n\n    /**\n     * Get the angle between two 3D vectors\n     * @param {vec3} vector The second operand\n     * @returns {number} The angle in radians\n     */\n    /*\n    angle(vector: vec3) {\n        const data = this.data;\n        const b = vector.data;\n        let ax = data[0],\n            ay = data[1],\n            az = data[2],\n            bx = b[0],\n            by = b[1],\n            bz = b[2],\n            mag = Math.sqrt(\n                (ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)\n            ),\n            cosine = mag && this.dot(vector) / mag;\n        return Math.acos(Math.min(Math.max(cosine, -1), 1));\n    }\n        */\n\n/**\n * Creates a zero vector\n */\nexport function vec3Zero(): vec3\n{\n    return {x: 0, y: 0, z: 0}\n}\n\n/**\n * Creates a zero vector\n */\nexport function vec3One(): vec3\n{\n    return {x: 1, y: 1, z: 1}\n}\n\nexport function vec3Abs(v: rvec3): vec3\n{\n    return {\n        x: Math.abs(v.x),\n        y: Math.abs(v.y),\n        z: Math.abs(v.z),\n    }\n}\n\nexport function vec3Max(v: rvec3, s: number): vec3\n{\n    return {\n        x: Math.max(v.x, s),\n        y: Math.max(v.y, s),\n        z: Math.max(v.z, s),\n    }\n}\n\nexport function vec3Min(v: rvec3, s: number): vec3\n{\n    return {\n        x: Math.min(v.x, s),\n        y: Math.min(v.y, s),\n        z: Math.min(v.z, s),\n    }\n}", "import mathf from \"./mathf\";\nimport { quat, rquat } from \"./quat\";\nimport { vec3, rvec3, vec3Zero } from \"./vec3\";\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n */\nexport interface mat4\n{\n    m00: number;\n    m01: number;\n    m02: number;\n    m03: number;\n    m10: number;\n    m11: number;\n    m12: number;\n    m13: number;\n    m20: number;\n    m21: number;\n    m22: number;\n    m23: number;\n    m30: number;\n    m31: number;\n    m32: number;\n    m33: number;\n}\n\nexport type rmat4 = Readonly<mat4>;\n\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {mat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\nexport function mat4Clone(m: rmat4): mat4\n{\n    return {\n        m00: m.m00, m01: m.m01, m02: m.m02, m03: m.m03,\n        m10: m.m10, m11: m.m11, m12: m.m12, m13: m.m13,\n        m20: m.m20, m21: m.m21, m22: m.m22, m23: m.m23,\n        m30: m.m30, m31: m.m31, m32: m.m32, m33: m.m33\n    }\n}\n\n/**\n * Copy the values from one mat4 to another\n * @returns {mat4} out\n */\nexport function mat4Copy(left: mat4, right: rmat4): mat4\n{\n    left.m00 = right.m00;\n    left.m01 = right.m01;\n    left.m02 = right.m02;\n    left.m03 = right.m03;\n    left.m10 = right.m10;\n    left.m11 = right.m11;\n    left.m12 = right.m12;\n    left.m13 = right.m13;\n    left.m20 = right.m20;\n    left.m21 = right.m21;\n    left.m22 = right.m22;\n    left.m23 = right.m23;\n    left.m30 = right.m30;\n    left.m31 = right.m31;\n    left.m32 = right.m32;\n    left.m33 = right.m33;\n    return left;\n}\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {number} m00 Component in column 0, row 0 position (index 0)\n * @param {number} m01 Component in column 0, row 1 position (index 1)\n * @param {number} m02 Component in column 0, row 2 position (index 2)\n * @param {number} m03 Component in column 0, row 3 position (index 3)\n * @param {number} m10 Component in column 1, row 0 position (index 4)\n * @param {number} m11 Component in column 1, row 1 position (index 5)\n * @param {number} m12 Component in column 1, row 2 position (index 6)\n * @param {number} m13 Component in column 1, row 3 position (index 7)\n * @param {number} m20 Component in column 2, row 0 position (index 8)\n * @param {number} m21 Component in column 2, row 1 position (index 9)\n * @param {number} m22 Component in column 2, row 2 position (index 10)\n * @param {number} m23 Component in column 2, row 3 position (index 11)\n * @param {number} m30 Component in column 3, row 0 position (index 12)\n * @param {number} m31 Component in column 3, row 1 position (index 13)\n * @param {number} m32 Component in column 3, row 2 position (index 14)\n * @param {number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\nexport function mat4Set(\n    m: mat4,\n    m00: number,\n    m01: number,\n    m02: number,\n    m03: number,\n    m10: number,\n    m11: number,\n    m12: number,\n    m13: number,\n    m20: number,\n    m21: number,\n    m22: number,\n    m23: number,\n    m30: number,\n    m31: number,\n    m32: number,\n    m33: number)\n{\n    m.m00 = m00;\n    m.m01 = m01;\n    m.m02 = m02;\n    m.m03 = m03;\n    m.m10 = m10;\n    m.m11 = m11;\n    m.m12 = m12;\n    m.m13 = m13;\n    m.m20 = m20;\n    m.m21 = m21;\n    m.m22 = m22;\n    m.m23 = m23;\n    m.m30 = m30;\n    m.m31 = m31;\n    m.m32 = m32;\n    m.m33 = m33;\n    return m;\n}\n\n/**\n * Creates a mat4 identity matrix\n */\nexport function mat4Identity(): mat4\n{\n    return {\n        m00: 1, m01: 0, m02: 0, m03: 0,\n        m10: 0, m11: 1, m12: 0, m13: 0,\n        m20: 0, m21: 0, m22: 1, m23: 0,\n        m30: 0, m31: 0, m32: 0, m33: 1\n    }\n}\n\n/**\n * Transpose the values of a mat4\n *\n * @returns {mat4} out\n */\nexport function mat4Transpose(m: mat4): mat4\n{\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    const a01 = m.m01,\n      a02 = m.m02,\n      a03 = m.m03;\n    const a12 = m.m12,\n      a13 = m.m13;\n    const a23 = m.m23;\n\n    m.m01 = m.m10;\n    m.m02 = m.m20;\n    m.m03 = m.m30;\n    m.m10 = a01;\n    m.m12 = m.m21;\n    m.m13 = m.m31;\n    m.m20 = a02;\n    m.m21 = a12;\n    m.m23 = m.m32;\n    m.m30 = a03;\n    m.m31 = a13;\n    m.m32 = a23;\n    return m;\n}\n\n/**\n * Inverts a mat4\n *\n * @returns {mat4} out\n */\nexport function mat4Invert(m: mat4): mat4\n{\n    const a00 = m.m00,\n      a01 = m.m01,\n      a02 = m.m02,\n      a03 = m.m03;\n    const a10 = m.m10,\n      a11 = m.m11,\n      a12 = m.m12,\n      a13 = m.m13;\n    const a20 = m.m20,\n      a21 = m.m21,\n      a22 = m.m22,\n      a23 = m.m23;\n    const a30 = m.m30,\n      a31 = m.m31,\n      a32 = m.m32,\n      a33 = m.m33;\n\n    const b00 = a00 * a11 - a01 * a10;\n    const b01 = a00 * a12 - a02 * a10;\n    const b02 = a00 * a13 - a03 * a10;\n    const b03 = a01 * a12 - a02 * a11;\n    const b04 = a01 * a13 - a03 * a11;\n    const b05 = a02 * a13 - a03 * a12;\n    const b06 = a20 * a31 - a21 * a30;\n    const b07 = a20 * a32 - a22 * a30;\n    const b08 = a20 * a33 - a23 * a30;\n    const b09 = a21 * a32 - a22 * a31;\n    const b10 = a21 * a33 - a23 * a31;\n    const b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n      return null;\n    }\n    det = 1.0 / det;\n\n    m.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    m.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    m.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    m.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    m.m10 = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    m.m11 = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    m.m12 = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    m.m13 = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    m.m20 = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    m.m21 = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    m.m22 = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    m.m23 = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    m.m30 = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    m.m31 = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    m.m32 = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    m.m33 = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n    return m;\n}\n\n  /**\n   * Calculates the adjugate of a mat4\n   *\n   * @returns {mat4} out\n   */\n  export function mat4Adjoint(m: mat4): mat4\n  {\n    const a00 = m.m00,\n      a01 = m.m01,\n      a02 = m.m02,\n      a03 = m.m03;\n    const a10 = m.m10,\n      a11 = m.m11,\n      a12 = m.m12,\n      a13 = m.m13;\n    const a20 = m.m20,\n      a21 = m.m21,\n      a22 = m.m22,\n      a23 = m.m23;\n    const a30 = m.m30,\n      a31 = m.m31,\n      a32 = m.m32,\n      a33 = m.m33;\n\n    const b00 = a00 * a11 - a01 * a10;\n    const b01 = a00 * a12 - a02 * a10;\n    const b02 = a00 * a13 - a03 * a10;\n    const b03 = a01 * a12 - a02 * a11;\n    const b04 = a01 * a13 - a03 * a11;\n    const b05 = a02 * a13 - a03 * a12;\n    const b06 = a20 * a31 - a21 * a30;\n    const b07 = a20 * a32 - a22 * a30;\n    const b08 = a20 * a33 - a23 * a30;\n    const b09 = a21 * a32 - a22 * a31;\n    const b10 = a21 * a33 - a23 * a31;\n    const b11 = a22 * a33 - a23 * a32;\n\n    m.m00 = a11 * b11 - a12 * b10 + a13 * b09;\n    m.m01 = a02 * b10 - a01 * b11 - a03 * b09;\n    m.m02 = a31 * b05 - a32 * b04 + a33 * b03;\n    m.m03 = a22 * b04 - a21 * b05 - a23 * b03;\n    m.m10 = a12 * b08 - a10 * b11 - a13 * b07;\n    m.m11 = a00 * b11 - a02 * b08 + a03 * b07;\n    m.m12 = a32 * b02 - a30 * b05 - a33 * b01;\n    m.m13 = a20 * b05 - a22 * b02 + a23 * b01;\n    m.m20 = a10 * b10 - a11 * b08 + a13 * b06;\n    m.m21 = a01 * b08 - a00 * b10 - a03 * b06;\n    m.m22 = a30 * b04 - a31 * b02 + a33 * b00;\n    m.m23 = a21 * b02 - a20 * b04 - a23 * b00;\n    m.m30 = a11 * b07 - a10 * b09 - a12 * b06;\n    m.m31 = a00 * b09 - a01 * b07 + a02 * b06;\n    m.m32 = a31 * b01 - a30 * b03 - a32 * b00;\n    m.m33 = a20 * b03 - a21 * b01 + a22 * b00;\n\n    return m;\n  }\n\n/**\n * Calculates the determinant of a mat4\n *\n * @returns {number} determinant of a\n */\nexport function mat4Determinant(m: rmat4)\n{\n    const b0 = m.m00 * m.m11 - m.m01 * m.m10;\n    const b1 = m.m00 * m.m12 - m.m02 * m.m10;\n    const b2 = m.m01 * m.m12 - m.m02 * m.m11;\n    const b3 = m.m20 * m.m31 - m.m21 * m.m30;\n    const b4 = m.m20 * m.m32 - m.m22 * m.m30;\n    const b5 = m.m21 * m.m32 - m.m22 * m.m31;\n    const b6 = m.m00 * b5 - m.m01 * b4 + m.m02 * b3;\n    const b7 = m.m10 * b5 - m.m11 * b4 + m.m12 * b3;\n    const b8 = m.m20 * b2 - m.m21 * b1 + m.m22 * b0;\n    const b9 = m.m30 * b2 - m.m31 * b1 + m.m32 * b0;\n\n    // Calculate the determinant\n    return m.m13 * b6 - m.m03 * b7 + m.m33 * b8 - m.m23 * b9;\n}\n\n  /**\n   * Multiplies two mat4s\n   *\n   * @param {mat4} matrix the second operand\n   * @returns {mat4} out\n   */\n  export function mat4Mul(left: mat4, right: rmat4)\n  {\n    const a00 = left.m00,\n      a01 = left.m01,\n      a02 = left.m02,\n      a03 = left.m03;\n    const a10 = left.m10,\n      a11 = left.m11,\n      a12 = left.m12,\n      a13 = left.m13;\n    const a20 = left.m20,\n      a21 = left.m21,\n      a22 = left.m22,\n      a23 = left.m23;\n    const a30 = left.m30,\n      a31 = left.m31,\n      a32 = left.m32,\n      a33 = left.m33;\n\n    // Cache only the current line of the second matrix\n    let b0 = right.m00,\n      b1 = right.m01,\n      b2 = right.m02,\n      b3 = right.m03;\n    left.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    left.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    left.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    left.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = right.m10;\n    b1 = right.m11;\n    b2 = right.m12;\n    b3 = right.m13;\n    left.m10 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    left.m11 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    left.m12 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    left.m13 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = right.m20;\n    b1 = right.m21;\n    b2 = right.m22;\n    b3 = right.m23;\n    left.m20 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    left.m21 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    left.m22 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    left.m23 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = right.m30;\n    b1 = right.m31;\n    b2 = right.m32;\n    b3 = right.m33;\n    left.m30 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    left.m31 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    left.m32 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    left.m33 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    return left;\n  }\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nexport function mat4Translate(m: mat4, v: rvec3)\n{\n    m.m30 = m.m00 * v.x + m.m10 * v.y + m.m20 * v.z + m.m30;\n    m.m31 = m.m01 * v.x + m.m11 * v.y + m.m21 * v.z + m.m31;\n    m.m32 = m.m02 * v.x + m.m12 * v.y + m.m22 * v.z + m.m32;\n    m.m33 = m.m03 * v.x + m.m13 * v.y + m.m23 * v.z + m.m33;\n\n    return m;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nexport function mat4Scale(m: mat4, v: rvec3)\n{\n    m.m00 = m.m00 * v.x;\n    m.m01 = m.m01 * v.x;\n    m.m02 = m.m02 * v.x;\n    m.m03 = m.m03 * v.x;\n    m.m10 = m.m10 * v.y;\n    m.m11 = m.m11 * v.y;\n    m.m12 = m.m12 * v.y;\n    m.m13 = m.m13 * v.y;\n    m.m20 = m.m20 * v.z;\n    m.m21 = m.m21 * v.z;\n    m.m22 = m.m22 * v.z;\n    m.m23 = m.m23 * v.z;\n    return m;\n}\n\n  /**\n   * Rotates a mat4 by the given angle around the given axis\n   *\n   * @param {number} rad the angle to rotate the matrix by\n   * @param {vec3} axis the axis to rotate around\n   * @returns {mat4} out\n   */\n  export function mat4Rotate(m: mat4, rad: number, axis: rvec3)\n  {\n    let x = axis.x,\n      y = axis.y,\n      z = axis.z;\n    let len = Math.sqrt(x ** 2 + y ** 2 + z ** 2);\n\n    if (len < mathf.EPSILON)\n    {\n      return null;\n    }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n    const t = 1 - c;\n\n    const a00 = m.m00,\n      a01 = m.m01,\n      a02 = m.m02,\n      a03 = m.m03;\n    const a10 = m.m10,\n      a11 = m.m11,\n      a12 = m.m12,\n      a13 = m.m13;\n    const a20 = m.m20,\n      a21 = m.m21,\n      a22 = m.m22,\n      a23 = m.m23;\n\n    // Construct the elements of the rotation matrix\n    const b00 = x * x * t + c;\n    const b01 = y * x * t + z * s;\n    const b02 = z * x * t - y * s;\n    const b10 = x * y * t - z * s;\n    const b11 = y * y * t + c;\n    const b12 = z * y * t + x * s;\n    const b20 = x * z * t + y * s;\n    const b21 = y * z * t - x * s;\n    const b22 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    m.m00 = a00 * b00 + a10 * b01 + a20 * b02;\n    m.m01 = a01 * b00 + a11 * b01 + a21 * b02;\n    m.m02 = a02 * b00 + a12 * b01 + a22 * b02;\n    m.m03 = a03 * b00 + a13 * b01 + a23 * b02;\n    m.m10 = a00 * b10 + a10 * b11 + a20 * b12;\n    m.m11 = a01 * b10 + a11 * b11 + a21 * b12;\n    m.m12 = a02 * b10 + a12 * b11 + a22 * b12;\n    m.m13 = a03 * b10 + a13 * b11 + a23 * b12;\n    m.m20 = a00 * b20 + a10 * b21 + a20 * b22;\n    m.m21 = a01 * b20 + a11 * b21 + a21 * b22;\n    m.m22 = a02 * b20 + a12 * b21 + a22 * b22;\n    m.m23 = a03 * b20 + a13 * b21 + a23 * b22;\n\n    return m;\n  }\n\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function mat4RotateX(m: mat4, rad: number)\n{\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n    const a10 = m.m10,\n      a11 = m.m11,\n      a12 = m.m12,\n      a13 = m.m13;\n    const a20 = m.m20,\n      a21 = m.m21,\n      a22 = m.m22,\n      a23 = m.m23;\n\n    m.m10 = a10 * c + a20 * s;\n    m.m11 = a11 * c + a21 * s;\n    m.m12 = a12 * c + a22 * s;\n    m.m13 = a13 * c + a23 * s;\n    m.m20 = a20 * c - a10 * s;\n    m.m21 = a21 * c - a11 * s;\n    m.m22 = a22 * c - a12 * s;\n    m.m23 = a23 * c - a13 * s;\n    return m;\n}\n\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function mat4RotateY(m: mat4, rad: number)\n{\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n    const a00 = m.m00,\n      a01 = m.m01,\n      a02 = m.m02,\n      a03 = m.m03;\n    const a20 = m.m20,\n      a21 = m.m21,\n      a22 = m.m22,\n      a23 = m.m23;\n\n    // Perform axis-specific matrix multiplication\n    m.m00 = a00 * c - a20 * s;\n    m.m01 = a01 * c - a21 * s;\n    m.m02 = a02 * c - a22 * s;\n    m.m03 = a03 * c - a23 * s;\n    m.m20 = a00 * s + a20 * c;\n    m.m21 = a01 * s + a21 * c;\n    m.m22 = a02 * s + a22 * c;\n    m.m23 = a03 * s + a23 * c;\n    return m;\n}\n\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function mat4RotateZ(m: mat4, rad: number)\n{\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n    const a00 = m.m00,\n      a01 = m.m01,\n      a02 = m.m02,\n      a03 = m.m03;\n    const a10 = m.m10,\n      a11 = m.m11,\n      a12 = m.m12,\n      a13 = m.m13;\n\n    // Perform axis-specific matrix multiplication\n    m.m00 = a00 * c + a10 * s;\n    m.m01 = a01 * c + a11 * s;\n    m.m02 = a02 * c + a12 * s;\n    m.m03 = a03 * c + a13 * s;\n    m.m10 = a10 * c - a00 * s;\n    m.m11 = a11 * c - a01 * s;\n    m.m12 = a12 * c - a02 * s;\n    m.m13 = a13 * c - a03 * s;\n    return m;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nexport function mat4SetFromTranslation(m: mat4, v: rvec3)\n{\n    m.m00 = 1;\n    m.m01 = 0;\n    m.m02 = 0;\n    m.m03 = 0;\n    m.m10 = 0;\n    m.m11 = 1;\n    m.m12 = 0;\n    m.m13 = 0;\n    m.m20 = 0;\n    m.m21 = 0;\n    m.m22 = 1;\n    m.m23 = 0;\n    m.m30 = v.x;\n    m.m31 = v.y;\n    m.m32 = v.z;\n    m.m33 = 1;\n    return m;\n}\n\nexport function mat4FromTranslation(v: rvec3): mat4\n{\n    return {\n        m00: 1, m01: 0, m02: 0, m03: 0,\n        m10: 0, m11: 1, m12: 0, m13: 0,\n        m20: 0, m21: 0, m22: 1, m23: 0,\n        m30: v.x, m31: v.y, m32: v.z, m33: 1\n    }\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n * @param {vec3} v Scaling vector\n * @returns {mat4} out\n */\nexport function mat4SetFromScaling(m: mat4, v: rvec3)\n{\n    m.m00 = v.x;\n    m.m01 = 0;\n    m.m02 = 0;\n    m.m03 = 0;\n    m.m10 = 0;\n    m.m11 = v.y;\n    m.m12 = 0;\n    m.m13 = 0;\n    m.m20 = 0;\n    m.m21 = 0;\n    m.m22 = v.z;\n    m.m23 = 0;\n    m.m30 = 0;\n    m.m31 = 0;\n    m.m32 = 0;\n    m.m33 = 1;\n    return m;\n}\n\nexport function mat4FromScaling(v: rvec3): mat4\n{\n    return {\n        m00: v.x, m01: 0, m02: 0, m03: 0,\n        m10: 0, m11: v.y, m12: 0, m13: 0,\n        m20: 0, m21: 0, m22: v.z, m23: 0,\n        m30: 0, m31: 0, m32: 0, m33: 1\n    }\n}\n\n  /**\n   * Creates a matrix from a given angle around a given axis\n   * This is equivalent to (but much faster than):\n   *\n   *     mat4.identity(dest);\n   *     mat4.rotate(dest, dest, rad, axis);\n   *\n   * @param {number} rad the angle to rotate the matrix by\n   * @param {vec3} axis the axis to rotate around\n   * @returns {mat4} out\n   */\n  export function mat4SetFromRotation(m: mat4, rad: number, axis: rvec3)\n  {\n    let x = axis.x,\n      y = axis.y,\n      z = axis.z;\n    let len = Math.sqrt(x ** 2 + y ** 2 + z ** 2);\n\n    if (len < mathf.EPSILON) {\n      return null;\n    }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n    const t = 1 - c;\n\n    // Perform rotation-specific matrix multiplication\n    m.m00 = x * x * t + c;\n    m.m01 = y * x * t + z * s;\n    m.m02 = z * x * t - y * s;\n    m.m03 = 0;\n    m.m10 = x * y * t - z * s;\n    m.m11 = y * y * t + c;\n    m.m12 = z * y * t + x * s;\n    m.m13 = 0;\n    m.m20 = x * z * t + y * s;\n    m.m21 = y * z * t - x * s;\n    m.m22 = z * z * t + c;\n    m.m23 = 0;\n    m.m30 = 0;\n    m.m31 = 0;\n    m.m32 = 0;\n    m.m33 = 1;\n    return this;\n  }\n\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n * @param {number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function mat4SetFromXRotation(m: mat4, rad: number)\n{\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    m.m00 = 1;\n    m.m01 = 0;\n    m.m02 = 0;\n    m.m03 = 0;\n    m.m10 = 0;\n    m.m11 = c;\n    m.m12 = s;\n    m.m13 = 0;\n    m.m20 = 0;\n    m.m21 = -s;\n    m.m22 = c;\n    m.m23 = 0;\n    m.m30 = 0;\n    m.m31 = 0;\n    m.m32 = 0;\n    m.m33 = 1;\n    return m;\n}\n\n  /**\n   * Creates a matrix from the given angle around the Y axis\n   * This is equivalent to (but much faster than):\n   *\n   *     mat4.identity(dest);\n   *     mat4.rotateY(dest, dest, rad);\n   * @param {number} rad the angle to rotate the matrix by\n   * @returns {mat4} out\n   */\n  export function mat4SetFromYRotation(m: mat4, rad: number)\n  {\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    m.m00 = c;\n    m.m01 = 0;\n    m.m02 = -s;\n    m.m03 = 0;\n    m.m10 = 0;\n    m.m11 = 1;\n    m.m12 = 0;\n    m.m13 = 0;\n    m.m20 = s;\n    m.m21 = 0;\n    m.m22 = c;\n    m.m23 = 0;\n    m.m30 = 0;\n    m.m31 = 0;\n    m.m32 = 0;\n    m.m33 = 1;\n    return m;\n  }\n\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n * @param {number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function mat4SetFromZRotation(m: mat4, rad: number)\n{\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    m.m00 = c;\n    m.m01 = s;\n    m.m02 = 0;\n    m.m03 = 0;\n    m.m10 = -s;\n    m.m11 = c;\n    m.m12 = 0;\n    m.m13 = 0;\n    m.m20 = 0;\n    m.m21 = 0;\n    m.m22 = 1;\n    m.m23 = 0;\n    m.m30 = 0;\n    m.m31 = 0;\n    m.m32 = 0;\n    m.m33 = 1;\n    return m;\n}\n\n  /**\n   * Creates a matrix from a quaternion rotation and vector translation\n   * This is equivalent to (but much faster than):\n   *\n   *     mat4.identity(dest);\n   *     mat4.translate(dest, vec);\n   *     let quatMat = mat4.create();\n   *     quat4.toMat4(quat, quatMat);\n   *     mat4.multiply(dest, quatMat);\n   * @param {quat4} q Rotation quaternion\n   * @param {vec3} v Translation vector\n   * @returns {mat4} out\n   */\n  export function mat4SetFromRotationTranslation(m: mat4, q: rquat, v: rvec3)\n  {\n    // Quaternion math\n    const x = q.x,\n      y = q.y,\n      z = q.z,\n      w = q.w;\n\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n\n    const xx = x * x2;\n    const xy = x * y2;\n    const xz = x * z2;\n    const yy = y * y2;\n    const yz = y * z2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n\n    m.m00 = 1 - (yy + zz);\n    m.m01 = xy + wz;\n    m.m02 = xz - wy;\n    m.m03 = 0;\n    m.m10 = xy - wz;\n    m.m11 = 1 - (xx + zz);\n    m.m12 = yz + wx;\n    m.m13 = 0;\n    m.m20 = xz + wy;\n    m.m21 = yz - wx;\n    m.m22 = 1 - (xx + yy);\n    m.m23 = 0;\n    m.m30 = v.x;\n    m.m31 = v.y;\n    m.m32 = v.z;\n    m.m33 = 1;\n\n    return this;\n  }\n  /**\n   * Returns the translation vector component of a transformation\n   *  matrix. If a matrix is built with fromRotationTranslation,\n   *  the returned vector will be the same as the translation vector\n   *  originally supplied.\n   * @return {vec3} out\n   */\n  export function mat4GetTranslation(m: rmat4, out: vec3)\n  {\n    out.x = m.m30;\n    out.y = m.m31;\n    out.z = m.m32;\n    return out;\n  }\n\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @return {vec3} out\n */\nexport function mat4GetScaling(m: rmat4, out: vec3)\n{\n    out.x = Math.sqrt(m.m11 ** 2 + m.m12 ** 2 + m.m13 ** 2),\n    out.y = Math.sqrt(m.m21 ** 2 + m.m22 ** 2 + m.m23 ** 2),\n    out.z = Math.sqrt(m.m31 ** 2 + m.m32 ** 2 + m.m33 ** 2)\n    return  out;\n}\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @return {quat} out\n */\nexport function mat4GetRotation(m: rmat4, out: quat)\n{\n    const scaling = mat4GetScaling(m, vec3Zero());\n\n    const is1 = 1 / scaling.x;\n    const is2 = 1 / scaling.y;\n    const is3 = 1 / scaling.z;\n\n    const sm11 = m.m00 * is1;\n    const sm12 = m.m01 * is2;\n    const sm13 = m.m02 * is3;\n    const sm21 = m.m10 * is1;\n    const sm22 = m.m11 * is2;\n    const sm23 = m.m12 * is3;\n    const sm31 = m.m20 * is1;\n    const sm32 = m.m21 * is2;\n    const sm33 = m.m22 * is3;\n\n    const trace = sm11 + sm22 + sm33;\n    if (trace > 0)\n    {\n        const S = Math.sqrt(trace + 1.0) * 2;\n        out.w = 0.25 * S;\n        out.x = (sm23 - sm32) / S;\n        out.y = (sm31 - sm13) / S;\n        out.z = (sm12 - sm21) / S;\n    }\n    else if (sm11 > sm22 && sm11 > sm33)\n    {\n        const S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n        out.w = (sm23 - sm32) / S;\n        out.x = 0.25 * S;\n        out.y = (sm12 + sm21) / S;\n        out.z = (sm31 + sm13) / S;\n        }\n    else if (sm22 > sm33)\n    {\n        const S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n        out.w = (sm31 - sm13) / S;\n        out.x = (sm12 + sm21) / S;\n        out.y = 0.25 * S;\n        out.z = (sm23 + sm32) / S;\n    }\n    else\n    {\n        const S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n        out.w = (sm12 - sm21) / S;\n        out.x = (sm31 + sm13) / S;\n        out.y = (sm23 + sm32) / S;\n        out.z = 0.25 * S;\n    }\n\n    return out;\n}\n\n/**\n * Decomposes a transformation matrix into its rotation, translation\n * and scale components. Returns only the rotation component\n * @param  {quat} q Quaternion to receive the rotation component\n * @param  {vec3} t Vector to receive the translation vector\n * @param  {vec3} s Vector to receive the scaling factor\n * @returns {quat} out_r\n */\nexport function mat4Decompose(m: rmat4, q: quat, t: vec3, s: vec3): rmat4\n{\n    t.x = m.m30;\n    t.y = m.m31;\n    t.z = m.m32;\n\n    s.x = Math.sqrt(m.m00 ** 2 + m.m01 ** 2 + m.m02 ** 2);\n    s.y = Math.sqrt(m.m10 ** 2 + m.m11 ** 2 + m.m12 ** 2);\n    s.z = Math.sqrt(m.m20 ** 2 + m.m21 ** 2 + m.m22 ** 2);\n\n    const is1 = 1 / s.x;\n    const is2 = 1 / s.y;\n    const is3 = 1 / s.z;\n\n    const sm11 = m.m00 * is1;\n    const sm12 = m.m01 * is2;\n    const sm13 = m.m02 * is3;\n    const sm21 = m.m10 * is1;\n    const sm22 = m.m11 * is2;\n    const sm23 = m.m12 * is3;\n    const sm31 = m.m20 * is1;\n    const sm32 = m.m21 * is2;\n    const sm33 = m.m22 * is3;\n\n    const trace = sm11 + sm22 + sm33;\n\n    if (trace > 0)\n    {\n        const S = Math.sqrt(trace + 1.0) * 2;\n        q.w = 0.25 * S;\n        q.x = (sm23 - sm32) / S;\n        q.y = (sm31 - sm13) / S;\n        q.z = (sm12 - sm21) / S;\n    }\n    else if (sm11 > sm22 && sm11 > sm33)\n    {\n        const S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n        q.w = (sm23 - sm32) / S;\n        q.x = 0.25 * S;\n        q.y = (sm12 + sm21) / S;\n        q.z = (sm31 + sm13) / S;\n    }\n    else if (sm22 > sm33)\n    {\n        const S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n        q.w = (sm31 - sm13) / S;\n        q.x = (sm12 + sm21) / S;\n        q.y = 0.25 * S;\n        q.z = (sm23 + sm32) / S;\n    }\n    else\n    {\n        const S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n        q.w = (sm12 - sm21) / S;\n        q.x = (sm31 + sm13) / S;\n        q.y = (sm23 + sm32) / S;\n        q.z = 0.25 * S;\n    }\n    return m;\n  }\n\n  /**\n   * Creates a matrix from a quaternion rotation, vector translation and vector scale\n   * This is equivalent to (but much faster than):\n   *\n   *     mat4.identity(dest);\n   *     mat4.translate(dest, vec);\n   *     let quatMat = mat4.create();\n   *     quat4.toMat4(quat, quatMat);\n   *     mat4.multiply(dest, quatMat);\n   *     mat4.scale(dest, scale)\n   * @param {quat4} q Rotation quaternion\n   * @param {vec3} v Translation vector\n   * @param {vec3} s Scaling vector\n   * @returns {mat4} out\n   */\n  export function mat4SetFromRotationTranslationScale(m: mat4, q: rquat, v: rvec3, s: rvec3)\n  {\n    // Quaternion math\n    const x2 = q.x + q.x;\n    const y2 = q.y + q.y;\n    const z2 = q.z + q.z;\n\n    const xx = q.x * x2;\n    const xy = q.x * y2;\n    const xz = q.x * z2;\n    const yy = q.y * y2;\n    const yz = q.y * z2;\n    const zz = q.z * z2;\n    const wx = q.w * x2;\n    const wy = q.w * y2;\n    const wz = q.w * z2;\n\n    m.m00 = (1 - (yy + zz)) * s.x;\n    m.m01 = (xy + wz) * s.x;\n    m.m02 = (xz - wy) * s.x;\n    m.m03 = 0;\n    m.m10 = (xy - wz) * s.y;\n    m.m11 = (1 - (xx + zz)) * s.y;\n    m.m12 = (yz + wx) * s.y;\n    m.m13 = 0;\n    m.m20 = (xz + wy) * s.z;\n    m.m21 = (yz - wx) * s.z;\n    m.m22 = (1 - (xx + yy)) * s.z;\n    m.m23 = 0;\n    m.m30 = v.x;\n    m.m31 = v.y;\n    m.m32 = v.z;\n    m.m33 = 1;\n\n    return m;\n  }\n\n  /**\n   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n   * This is equivalent to (but much faster than):\n   *\n   *     mat4.identity(dest);\n   *     mat4.translate(dest, vec);\n   *     mat4.translate(dest, origin);\n   *     let quatMat = mat4.create();\n   *     quat4.toMat4(quat, quatMat);\n   *     mat4.multiply(dest, quatMat);\n   *     mat4.scale(dest, scale)\n   *     mat4.translate(dest, negativeOrigin);\n   * @param {quat4} q Rotation quaternion\n   * @param {vec3} v Translation vector\n   * @param {vec3} s Scaling vector\n   * @param {vec3} o The origin vector around which to scale and rotate\n   * @returns {mat4} out\n   */\n  export function mat4SetFromRotationTranslationScaleOrigin(m: mat4, q: rquat, v: rvec3, s: rvec3, o: rvec3)\n  {\n    // Quaternion math\n    const x2 = q.x + q.x;\n    const y2 = q.y + q.y;\n    const z2 = q.z + q.z;\n\n    const xx = q.x * x2;\n    const xy = q.x * y2;\n    const xz = q.x * z2;\n    const yy = q.y * y2;\n    const yz = q.y * z2;\n    const zz = q.z * z2;\n    const wx = q.w * x2;\n    const wy = q.w * y2;\n    const wz = q.w * z2;\n\n    const out0 = (1 - (yy + zz)) * s.x;\n    const out1 = (xy + wz) * s.x;\n    const out2 = (xz - wy) * s.x;\n    const out4 = (xy - wz) * s.y;\n    const out5 = (1 - (xx + zz)) * s.y;\n    const out6 = (yz + wx) * s.y;\n    const out8 = (xz + wy) * s.z;\n    const out9 = (yz - wx) * s.z;\n    const out10 = (1 - (xx + yy)) * s.z;\n\n    m.m00 = out0;\n    m.m01 = out1;\n    m.m02 = out2;\n    m.m03 = 0;\n    m.m10 = out4;\n    m.m11 = out5;\n    m.m12 = out6;\n    m.m13 = 0;\n    m.m20 = out8;\n    m.m21 = out9;\n    m.m22 = out10;\n    m.m23 = 0;\n    m.m30 = v.x + o.x - (out0 * o.x + out4 * o.y + out8 * o.z);\n    m.m31 = v.y + o.y - (out1 * o.x + out5 * o.y + out9 * o.z);\n    m.m32 = v.z + o.z - (out2 * o.x + out6 * o.y + out10 * o.z);\n    m.m33 = 1;\n\n    return m;\n  }\n\n  /**\n   * Calculates a 4x4 matrix from the given quaternion\n   * @param {ReadonlyQuat} q Quaternion to create matrix from\n   * @returns {mat4} out\n   */\n  export function mat4SetFromQuat(m: mat4, q: rquat)\n  {\n    const x2 = q.x + q.x;\n    const y2 = q.y + q.y;\n    const z2 = q.z + q.z;\n\n    const xx = q.x * x2;\n    const yx = q.y * x2;\n    const yy = q.y * y2;\n    const zx = q.z * x2;\n    const zy = q.z * y2;\n    const zz = q.z * z2;\n    const wx = q.w * x2;\n    const wy = q.w * y2;\n    const wz = q.w * z2;\n\n    m.m00 = 1 - yy - zz;\n    m.m01 = yx + wz;\n    m.m02 = zx - wy;\n    m.m03 = 0;\n\n    m.m10 = yx - wz;\n    m.m11 = 1 - xx - zz;\n    m.m12 = zy + wx;\n    m.m13 = 0;\n\n    m.m20 = zx + wy;\n    m.m21 = zy - wx;\n    m.m22 = 1 - xx - yy;\n    m.m23 = 0;\n\n    m.m30 = 0;\n    m.m31 = 0;\n    m.m32 = 0;\n    m.m33 = 1;\n\n    return m;\n  }\n\n  /**\n   * Generates a frustum matrix with the given bounds\n   *\n   * @param {number} left Left bound of the frustum\n   * @param {number} right Right bound of the frustum\n   * @param {number} bottom Bottom bound of the frustum\n   * @param {number} top Top bound of the frustum\n   * @param {number} near Near bound of the frustum\n   * @param {number} far Far bound of the frustum\n   * @returns {mat4} out\n   */\n  export function mat4SetFrustum(m: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number)\n  {\n    const rl = 1 / (right - left);\n    const tb = 1 / (top - bottom);\n    const nf = 1 / (near - far);\n    m.m00 = near * 2 * rl;\n    m.m01 = 0;\n    m.m02 = 0;\n    m.m03 = 0;\n    m.m10 = 0;\n    m.m11 = near * 2 * tb;\n    m.m12 = 0;\n    m.m13 = 0;\n    m.m20 = (right + left) * rl;\n    m.m21 = (top + bottom) * tb;\n    m.m22 = (far + near) * nf;\n    m.m23 = -1;\n    m.m30 = 0;\n    m.m31 = 0;\n    m.m32 = far * near * 2 * nf;\n    m.m33 = 0;\n    return m;\n  }\n\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\nexport function mat4SetPerspectiveNO(m: mat4, fovy: number, aspect: number, near: number, far: number)\n{\n    const f = 1.0 / Math.tan(fovy / 2);\n    m.m00 = f / aspect;\n    m.m01 = 0;\n    m.m02 = 0;\n    m.m03 = 0;\n    m.m10 = 0;\n    m.m11 = f;\n    m.m12 = 0;\n    m.m13 = 0;\n    m.m20 = 0;\n    m.m21 = 0;\n    m.m23 = -1;\n    m.m30 = 0;\n    m.m31 = 0;\n    m.m33 = 0;\n\n    if (far != null && far !== Infinity)\n    {\n        const nf = 1 / (near - far);\n        m.m22 = (far + near) * nf;\n        m.m32 = 2 * far * near * nf;\n    }\n    else\n    {\n        m.m22 = -1;\n        m.m32 = -2 * near;\n    }\n    return m;\n}\n\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\nexport function mat4SetPerspectiveZO(m: mat4, fovy: number, aspect: number, near: number, far: number)\n{\n    const f = 1.0 / Math.tan(fovy / 2);\n    m.m00 = f / aspect;\n    m.m01 = 0;\n    m.m02 = 0;\n    m.m03 = 0;\n    m.m10 = 0;\n    m.m11 = f;\n    m.m12 = 0;\n    m.m13 = 0;\n    m.m20 = 0;\n    m.m21 = 0;\n    m.m23 = -1;\n    m.m30 = 0;\n    m.m31 = 0;\n    m.m33 = 0;\n\n    if (far != null && far !== Infinity)\n    {\n        const nf = 1 / (near - far);\n        m.m22 = far * nf;\n        m.m32 = far * near * nf;\n    }\n    else\n    {\n        m.m22 = -1;\n        m.m32 = -near;\n    }\n    return m;\n}\n\nexport interface FieldOfViewVR\n{\n    upDegrees: number;\n    downDegrees: number;\n    leftDegrees: number;\n    rightDegrees: number;\n}\n\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experimental WebVR API.\n *\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function mat4SetPerspectiveFromFieldOfView(m: mat4, fov: Readonly<FieldOfViewVR>, near: number, far: number)\n{\n    const upTan = Math.tan((fov.upDegrees * Math.PI) / 180.0);\n    const downTan = Math.tan((fov.downDegrees * Math.PI) / 180.0);\n    const leftTan = Math.tan((fov.leftDegrees * Math.PI) / 180.0);\n    const rightTan = Math.tan((fov.rightDegrees * Math.PI) / 180.0);\n    const xScale = 2.0 / (leftTan + rightTan);\n    const yScale = 2.0 / (upTan + downTan);\n\n    m.m00 = xScale;\n    m.m01 = 0.0;\n    m.m02 = 0.0;\n    m.m03 = 0.0;\n    m.m10 = 0.0;\n    m.m11 = yScale;\n    m.m12 = 0.0;\n    m.m13 = 0.0;\n    m.m20 = -((leftTan - rightTan) * xScale * 0.5);\n    m.m21 = (upTan - downTan) * yScale * 0.5;\n    m.m22 = far / (near - far);\n    m.m23 = -1.0;\n    m.m30 = 0.0;\n    m.m31 = 0.0;\n    m.m32 = (far * near) / (near - far);\n    m.m33 = 0.0;\n\n    return m;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function mat4SetOrthoNO(m: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number)\n{\n    const lr = 1 / (left - right);\n    const bt = 1 / (bottom - top);\n    const nf = 1 / (near - far);\n\n    m.m00 = -2 * lr;\n    m.m01 = 0;\n    m.m02 = 0;\n    m.m03 = 0;\n    m.m10 = 0;\n    m.m11 = -2 * bt;\n    m.m12 = 0;\n    m.m13 = 0;\n    m.m20 = 0;\n    m.m21 = 0;\n    m.m22 = 2 * nf;\n    m.m23 = 0;\n    m.m30 = (left + right) * lr;\n    m.m31 = (top + bottom) * bt;\n    m.m32 = (far + near) * nf;\n    m.m33 = 1;\n\n    return this;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function mat4SetOrthoZO(m: mat4, left: number, right: number, bottom: number, top: number, near: number, far: number)\n{\n    const lr = 1 / (left - right);\n    const bt = 1 / (bottom - top);\n    const nf = 1 / (near - far);\n\n    m.m00 = -2 * lr;\n    m.m01 = 0;\n    m.m02 = 0;\n    m.m03 = 0;\n    m.m10 = 0;\n    m.m11 = -2 * bt;\n    m.m12 = 0;\n    m.m13 = 0;\n    m.m20 = 0;\n    m.m21 = 0;\n    m.m22 = nf;\n    m.m23 = 0;\n    m.m30 = (left + right) * lr;\n    m.m31 = (top + bottom) * bt;\n    m.m32 = near * nf;\n    m.m33 = 1;\n\n    return m;\n}\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nexport function mat4SetLookAt(m: mat4, eye: rvec3, center: rvec3, up: rvec3)\n{\n    let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n\n    if (\n      Math.abs(eye.x - center.x) < mathf.EPSILON &&\n      Math.abs(eye.y - center.y) < mathf.EPSILON &&\n      Math.abs(eye.z - center.z) < mathf.EPSILON\n    )\n    {\n        return this.identity();\n    }\n\n    z0 = eye.x - center.x;\n    z1 = eye.y - center.y;\n    z2 = eye.z - center.z;\n\n    len = 1 / Math.sqrt(z0 ** 2 + z1 ** 2 + z2 ** 2);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n\n    x0 = up.y * z2 - up.z * z1;\n    x1 = up.z * z0 - up.x * z2;\n    x2 = up.x * z1 - up.y * z0;\n    len = Math.sqrt(x0 ** 2 + x1 ** 2 + x2 ** 2);\n    if (!len)\n    {\n        x0 = 0;\n        x1 = 0;\n        x2 = 0;\n    }\n    else\n    {\n        len = 1 / len;\n        x0 *= len;\n        x1 *= len;\n        x2 *= len;\n    }\n\n    y0 = z1 * x2 - z2 * x1;\n    y1 = z2 * x0 - z0 * x2;\n    y2 = z0 * x1 - z1 * x0;\n\n    len = Math.sqrt(y0 ** 2 + y1 ** 2 + y2 ** 2);\n    if (!len)\n    {\n        y0 = 0;\n        y1 = 0;\n        y2 = 0;\n    }\n    else\n    {\n        len = 1 / len;\n        y0 *= len;\n        y1 *= len;\n        y2 *= len;\n    }\n\n    m.m00 = x0;\n    m.m01 = y0;\n    m.m02 = z0;\n    m.m03 = 0;\n    m.m10 = x1;\n    m.m11 = y1;\n    m.m12 = z1;\n    m.m13 = 0;\n    m.m20 = x2;\n    m.m21 = y2;\n    m.m22 = z2;\n    m.m23 = 0;\n    m.m30 = -(x0 * eye.x + x1 * eye.y + x2 * eye.z);\n    m.m31 = -(y0 * eye.x + y1 * eye.y + y2 * eye.z);\n    m.m32 = -(z0 * eye.x + z1 * eye.y + z2 * eye.z);\n    m.m33 = 1;\n\n    return m;\n}\n\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nexport function mat4SetTargetTo(m: mat4, eye: rvec3, center: rvec3, up: rvec3)\n{\n    let z0 = eye.x - center.x,\n      z1 = eye.y - center.y,\n      z2 = eye.z - center.z;\n\n    let len = z0 ** 2 + z1 ** 2 + z2 ** 2;\n    if (len > 0)\n    {\n        len = 1 / Math.sqrt(len);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n    }\n\n    let x0 = up.y * z2 - up.z * z1,\n      x1 = up.z * z0 - up.x * z2,\n      x2 = up.x * z1 - up.y * z0;\n\n    len = x0 ** 2 + x1 ** 2 + x2 ** 2;\n    if (len > 0)\n    {\n        len = 1 / Math.sqrt(len);\n        x0 *= len;\n        x1 *= len;\n        x2 *= len;\n    }\n\n    m.m00 = x0;\n    m.m01 = x1;\n    m.m02 = x2;\n    m.m03 = 0;\n    m.m10 = z1 * x2 - z2 * x1;\n    m.m11 = z2 * x0 - z0 * x2;\n    m.m12 = z0 * x1 - z1 * x0;\n    m.m13 = 0;\n    m.m20 = z0;\n    m.m21 = z1;\n    m.m22 = z2;\n    m.m23 = 0;\n    m.m30 = eye.x;\n    m.m31 = eye.y;\n    m.m32 = eye.z;\n    m.m33 = 1;\n    return m;\n}\n\n  /**\n   * Returns Frobenius norm of a mat4\n   *\n   * @returns {number} Frobenius norm\n   */\n  export function mat4Frob(m: rmat4)\n  {\n    return Math.hypot(\n        m.m00, m.m01, m.m02, m.m03,\n        m.m10, m.m11, m.m12, m.m13,\n        m.m20, m.m21, m.m22, m.m23,\n        m.m30, m.m31, m.m32, m.m33\n    );\n  }\n\n/**\n * Adds two mat4's\n * @param {mat4} left the second operand\n * @returns {mat4} out\n */\nexport function mat4Add(left: mat4, right: rmat4)\n{\n    left.m00 += right.m00;\n    left.m01 += right.m01;\n    left.m02 += right.m02;\n    left.m03 += right.m03;\n    left.m10 += right.m10;\n    left.m11 += right.m11;\n    left.m12 += right.m12;\n    left.m13 += right.m13;\n    left.m20 += right.m20;\n    left.m21 += right.m21;\n    left.m22 += right.m22;\n    left.m23 += right.m23;\n    left.m30 += right.m30;\n    left.m31 += right.m31;\n    left.m32 += right.m32;\n    left.m33 += right.m33;\n    return left;\n}\n\n  /**\n   * Subtracts matrix b from matrix a\n   * @param {mat4} matrix the second operand\n   * @returns {mat4} out\n   */\n  export function mat4Sub(left: mat4, right: rmat4)\n  {\n    left.m00 -= right.m00;\n    left.m01 -= right.m01;\n    left.m02 -= right.m02;\n    left.m03 -= right.m03;\n    left.m10 -= right.m10;\n    left.m11 -= right.m11;\n    left.m12 -= right.m12;\n    left.m13 -= right.m13;\n    left.m20 -= right.m20;\n    left.m21 -= right.m21;\n    left.m22 -= right.m22;\n    left.m23 -= right.m23;\n    left.m30 -= right.m30;\n    left.m31 -= right.m31;\n    left.m32 -= right.m32;\n    left.m33 -= right.m33;\n    return left;\n  }\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {number} s amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nexport function mat4MulScalar(m: mat4, s: number)\n{\n    m.m00 *= s;\n    m.m01 *= s;\n    m.m02 *= s;\n    m.m03 *= s;\n    m.m10 *= s;\n    m.m11 *= s;\n    m.m12 *= s;\n    m.m13 *= s;\n    m.m20 *= s;\n    m.m21 *= s;\n    m.m22 *= s;\n    m.m23 *= s;\n    m.m30 *= s;\n    m.m31 *= s;\n    m.m32 *= s;\n    m.m33 *= s;\n    return m;\n}", "import { vec3 } from \"./vec3\";\n\nexport interface vec2\n{\n    x: number;\n    y: number;\n}\n\nexport type rvec2 = Readonly<vec2>;\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param v the vector to clone\n * @returns a new vector\n */\nexport function vec2Clone(v: rvec2): vec2\n{\n    return {x: v.x, y: v.y};\n}\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param v the source vector\n * @param a the copy vector\n * @returns the target vector\n */\nexport function vec2Copy(v: vec2, a: rvec2)\n{\n    v.x = a.x;\n    v.y = a.y;\n    return v;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param v the target vector\n * @param x X component\n * @param y Y component\n * @returns the target vector\n */\nexport function vec2Set(v: vec2, x: number, y: number)\n{\n    v.x = x;\n    v.y = y;\n    return v;\n}\n\n/**\n * Calculates the length of a vector\n *\n * @params v the target vector\n * @returns length of a\n */\nexport function vec2Length(v: rvec2)\n{\n    return Math.sqrt(v.x ** 2 + v.y ** 2);\n}\n\n/**\n * Calculates the length of a vector\n *\n * @params v the target vector\n * @returns length of a\n */\nexport function vec2LengthValues(x: number, y: number)\n{\n    return Math.sqrt(x ** 2 + y ** 2);\n}\n\n\n/**\n * Calculates the squared length of a vec2\n *\n * @params v the target vector\n * @returns squared length of a\n */\nexport function vec2SquaredLength(v: rvec2)\n{\n    return v.x ** 2 + v.y ** 2;\n}\n\n/**\n * Adds vector other into vec\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec2AddTo(left: vec2, right: rvec2)\n{\n    left.x += right.x;\n    left.y += right.y;\n    return left;\n}\n\n/**\n * Adds two vectors into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec2Add(left: rvec2, right: rvec2): vec2\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y\n    }\n}\n\n/**\n * Subtracts vector other from vector vec\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function vec2SubFrom(left: vec2, right: rvec2)\n{\n    left.x -= right.x;\n    left.y -= right.y;\n    return left;\n}\n\n/**\n * Subtracts vector other from vector vec into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec2Sub(left: rvec2, right: rvec2): vec2\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n    }\n}\n\n/**\n * Multiplies the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function vec2MulTo(left: vec2, right: rvec2)\n{\n    left.x *= right.x;\n    left.y *= right.y;\n    return left;\n}\n\n/**\n * Multiplies the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec2Mul(left: rvec2, right: rvec2): vec2\n{\n    return {\n        x: left.x * right.x,\n        y: left.y * right.y\n    }\n}\n\n/**\n * Divides the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec2DivBy(vec: vec2, other: rvec2)\n{\n    vec.x /= other.x;\n    vec.y /= other.y;\n    return vec;\n}\n\n/**\n * Divides the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec2Div(left: rvec2, right: rvec2): vec2\n{\n    return {\n        x: left.x / right.x,\n        y: left.y / right.y\n    }\n}\n\n/**\n * Scales the target vector by a scalar number\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns the target vector\n */\nexport function vec2ScaleBy(v: vec2, scale: number)\n{\n    v.x *= scale;\n    v.y *= scale;\n    return v;\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec2Scale(v: rvec2, scale: number): vec2\n{\n    return {\n        x: v.x * scale,\n        y: v.y * scale\n    };\n}\n\nexport function vec2ScaleAndAdd(left: rvec2, right: rvec2, scale: number): vec2\n{\n    return {\n        x: left.x + (right.x * scale),\n        y: left.y + (right.y * scale),\n    }\n}\n\n/**\n * Calculates the Euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns distance between left and right\n */\nexport function vec2Distance(left: rvec2, right: rvec2)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    return Math.sqrt(dx ** 2 + dy ** 2);\n}\n\n/**\n * Calculates the squared euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns squery distance between left and right\n */\nexport function vec2SquaredDistance(left: rvec2, right: rvec2)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    return dx ** 2 + dy ** 2;\n}\n\n/**\n * Negates the components of vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec2Negate(v: vec2)\n{\n    v.x = -v.x;\n    v.y = -v.y;\n    return v;\n}\n\n/**\n * Negates the components of vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec2Negated(v: rvec2): vec2\n{\n    return {\n        x: -v.x,\n        y: -v.y\n    }\n}\n\n/**\n * Inverse of the components of a vector\n *\n * @params v the target vector\n * @returns the target vector\n */\nexport function vec2Inverse(v: vec2)\n{\n    v.x = 1.0 / v.x;\n    v.y = 1.0 / v.y;\n    return v;\n}\n\n/**\n * Returns the inverse of the components of a vector into a new vector\n *\n * @params v the target vector\n * @returns a new vector\n */\nexport function vec2Inversed(v: rvec2): vec2\n{\n    return {\n        x: 1.0 / v.x,\n        y: 1.0 / v.y\n    };\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec2Normalize(v: vec2)\n{\n    let sqrtLen = vec2SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x *= sqrtLen;\n    v.y *= sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec2Normalized(v: rvec2): vec2\n{\n    let sqrtLen = vec2SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen\n    }\n}\n\n/**\n * Calculates the dot product of two vec2's\n * @param left the left vector\n * @param right the right vector\n * @returns dot product of left and right\n */\nexport function vec2Dot(left: rvec2, right: rvec2)\n{\n    return left.x * right.x + left.y * right.y;\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n * @param left the left vector\n * @param right the right vector\n * @returns the resulting 3D vector, will only have a z value.\n */\nexport function vec2Cross(left: rvec2, right: rvec2): vec3\n{\n    const z = left.x * right.y - left.y * right.x;\n    return {x: 0, y: 0, z};\n}\n\n/**\n * Performs a linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs (not clamped)\n * @returns a new vector\n */\nexport function vec2Lerp(left: rvec2, right: rvec2, t: number): vec2\n{\n    return {\n        x: left.x + t * (right.x - left.x),\n        y: left.y + t * (right.y - left.y)\n    };\n}\n\n  /**\n   * Transforms the vec2 with a mat2\n   * @param {ReadonlyMat2} matrix matrix to transform with\n   * @returns {vec2} out\n   */\n//   transformMat2(matrix: mat2) {\n//     const data=this.data\n//     const m=matrix.data;\n//     var x = data[0],\n//       y = data[1];\n//     return this.set(\n//       m[0] * x + m[2] * y,\n//       m[1] * x + m[3] * y\n//     );\n//   }\n\n\n  /**\n   * Transforms the vec2 with a mat3\n   * 3rd vector component is implicitly '1'\n   *\n   * @param {mat3} matrix matrix to transform with\n   * @returns {vec2} out\n   */\n//   transformMat3(matrix: mat3) {\n//     const a=this.data;\n//     const m=matrix.data;\n//     var x = a[0],\n//       y = a[1];\n//     return this.set(\n//       m[0] * x + m[3] * y + m[6],\n//       m[1] * x + m[4] * y + m[7]\n//     );\n//   }\n\n  /**\n   * Transforms the vec2 with a mat4\n   * 3rd vector component is implicitly '0'\n   * 4th vector component is implicitly '1'\n   * @param {mat4} matrix matrix to transform with\n   * @returns {vec2} out\n   */\n//   transformMat4(matrix: mat4) {\n//     const a=this.data;\n//     const m=matrix.data;\n//     let x = a[0];\n//     let y = a[1];\n//     return this.set(\n//       m[0] * x + m[4] * y + m[12],\n//       m[1] * x + m[5] * y + m[13]\n//     );\n//   }\n\n/**\n * Rotate a 2D vector\n * @param {vec2} origin The origin of the rotation\n * @param {number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\nexport function vec2Rotate(left: vec2, right: rvec2, rad: number)\n{\n    //Translate point to the origin\n    const p0 = left.x - right.x,\n      p1 = left.y - right.y,\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad);\n\n    //perform rotation and translate to correct position\n    left.x = p0 * cosC - p1 * sinC + right[0];\n    left.y = p0 * sinC + p1 * cosC + right[1];\n    return left;\n}\n\n/**\n * Get the angle between two 2D vectors\n * @param left the left vector\n * @param right the right vector\n * @returns The angle in radians\n */\nexport function vec2Angle(left: rvec2, right: rvec2)\n{\n    const x1 = left.x,\n      y1 = left.y,\n      x2 = right.x,\n      y2 = right.y,\n      // mag is the product of the magnitudes of a and b\n      mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)),\n      // mag &&.. short circuits if mag == 0\n      cosine = mag && (x1 * x2 + y1 * y2) / mag;\n\n    // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n    return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n\n/**\n * Creates a zero vector\n */\nexport function vec2Zero(): vec2\n{\n    return {x: 0, y: 0}\n}", "export interface vec4\n{\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\nexport type rvec4 = Readonly<vec4>;\n\n/**\n * Clones this vector\n *\n * @param v the vector to clone\n * @returns a new vector\n */\nexport function vec4Clone(v: rvec4): vec4\n{\n    return {x: v.x, y: v.y, z: v.z, w: v.w};\n}\n\n/**\n * Copy the values from one vec4 to another\n * @param v the target vector\n * @param a the copy vector\n * @returns the target vector\n */\nexport function vec4Copy(v: vec4, a: rvec4)\n{\n    v.x = a.x;\n    v.y = a.y;\n    v.z = a.z;\n    v.w = a.w;\n    return v;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param v the target vector\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @param w W component\n * @returns the target vector\n */\nexport function vec4Set(v: vec4, x: number, y: number, z: number, w: number)\n{\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    v.w = w;\n    return v;\n}\n\n/**\n * Calculates the length vector v\n *\n * @params the source vector\n * @returns length of v\n */\nexport function vec4Length(v: rvec4)\n{\n    return Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2 + v.w ** 2);\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @params the source vector\n * @returns squared length of v\n */\nexport function vec4SquaredLength(v: rvec4)\n{\n    return v.x ** 2 + v.y ** 2 + v.z ** 2 + v.w ** 2;\n}\n\n/**\n * Adds vector other into vec\n * @param left the left vector\n * @param right the right vector\n * @returns the target vector\n */\nexport function vec4AddTo(left: vec4, right: rvec4)\n{\n    left.x += right.x;\n    left.y += right.y;\n    left.z += right.z;\n    left.w += right.w;\n    return left;\n}\n\n/**\n * Adds two vectors into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Add(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n        w: left.w + right.w\n    }\n}\n\n/**\n * Subtracts vector other from vector vec\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function vec4SubFrom(left: vec4, right: rvec4)\n{\n    left.x -= right.x;\n    left.y -= right.y;\n    left.z -= right.z;\n    left.w -= right.w;\n    return left;\n}\n\n/**\n * Subtracts vector other from vector vec into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Sub(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n        w: left.w - right.w,\n    }\n}\n\n/**\n * Multiplies the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function vec4MulTo(left: vec4, right: rvec4)\n{\n    left.x *= right.x;\n    left.y *= right.y;\n    left.z *= right.z;\n    left.w *= right.w;\n    return left;\n}\n\n/**\n * Multiplies the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Mul(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x * right.x,\n        y: left.y * right.y,\n        z: left.z * right.z,\n        w: left.w * right.w,\n    }\n}\n\n/**\n * Divides the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4DivBy(vec: vec4, other: rvec4)\n{\n    vec.x /= other.x;\n    vec.y /= other.y;\n    vec.z /= other.z;\n    vec.w /= other.w;\n    return vec;\n}\n\n/**\n * Divides the left vector by the right vector into a new vector\n * @param left the left vector\n * @param right the right vector\n * @returns a new vector\n */\nexport function vec4Div(left: rvec4, right: rvec4): vec4\n{\n    return {\n        x: left.x / right.x,\n        y: left.y / right.y,\n        z: left.z / right.z,\n        w: left.w / right.w,\n    }\n}\n\n/**\n * Scales the target vector by a scalar number\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns the target vector\n */\nexport function vec4ScaleBy(v: vec4, scale: number)\n{\n    v.x *= scale;\n    v.y *= scale;\n    v.z *= scale;\n    v.w *= scale;\n    return v;\n}\n\n/**\n * Scales the target vector by a scalar number into a new vector\n * @param v the target vector\n * @param scale amount to scale the vector by\n * @returns a new vector\n */\nexport function vec4Scale(v: rvec4, scale: number): vec4\n{\n    return {\n        x: v.x * scale,\n        y: v.y * scale,\n        z: v.z * scale,\n        w: v.w * scale\n    };\n}\n\n/**\n * Calculates the Euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns distance between left and right\n */\nexport function vec4Distance(left: rvec4, right: rvec4)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    const dw = left.w - right.w;\n    return Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2 + dw ** 2);\n}\n\n/**\n * Calculates the squared euclidean distance between two vectors\n * @param left the left operand\n * @param right the right operand\n * @returns squery distance between left and right\n */\nexport function vec4SquaredDistance(left: rvec4, right: rvec4)\n{\n    const dx = left.x - right.x;\n    const dy = left.y - right.y;\n    const dz = left.z - right.z;\n    const dw = left.w - right.w;\n    return dx ** 2 + dy ** 2 + dz ** 2 + dw ** 2;\n}\n\n/**\n * Negates the components of vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec4Negate(v: vec4)\n{\n    v.x = -v.x;\n    v.y = -v.y;\n    v.z = -v.z;\n    v.w = -v.w;\n    return v;\n}\n\n/**\n * Negates the components of vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec4Negated(v: rvec4): vec4\n{\n    return {\n        x: -v.x,\n        y: -v.y,\n        z: -v.z,\n        w: -v.w\n    }\n}\n\n/**\n * Inverse of the components of a vector\n *\n * @params v the target vector\n * @returns the target vector\n */\nexport function vec4Inverse(v: vec4)\n{\n    v.x = 1.0 / v.x;\n    v.y = 1.0 / v.y;\n    v.z = 1.0 / v.z;\n    v.w = 1.0 / v.w;\n    return v;\n}\n\n/**\n * Returns the inverse of the components of a vector into a new vector\n *\n * @params v the target vector\n * @returns a new vector\n */\nexport function vec4Inversed(v: rvec4): vec4\n{\n    return {\n        x: 1.0 / v.x,\n        y: 1.0 / v.y,\n        z: 1.0 / v.z,\n        w: 1.0 / v.w\n    };\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function vec4Normalize(v: vec4)\n{\n    let sqrtLen = vec4SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x *= sqrtLen;\n    v.y *= sqrtLen;\n    v.z *= sqrtLen;\n    v.w *= sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function vec4Normalized(v: rvec4): vec4\n{\n    let sqrtLen = vec4SquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen,\n        w: v.w * sqrtLen\n    }\n}\n\n/**\n * Calculates the dot product of two vec4's\n * @param left the left vector\n * @param right the right vector\n * @returns dot product of left and right\n */\nexport function vec4Dot(left: rvec4, right: rvec4)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n}\n\n\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param v1 the first vector\n * @param v2 the second vector\n * @param v3 the third vector\n * @returns a new vector\n */\nexport function vec4Cross(v1: rvec4, v2: rvec4, v3: rvec4): vec4\n{\n    const A = v2.x * v3.y - v2.y * v3.x,\n      B = v2.x * v3.z - v2.z * v3.x,\n      C = v2.x * v3.w - v2.w * v3.x,\n      D = v2.y * v3.z - v2.z * v3.y,\n      E = v2.y * v3.w - v2.w * v3.y,\n      F = v2.z * v3.w - v2.w * v3.z;\n    const G = v1.x;\n    const H = v1.y;\n    const I = v1.z;\n    const J = v1.w;\n\n    return {\n      x: H * F - I * E + J * D,\n      y: -(G * F) + I * C - J * B,\n      z: G * E - H * C + J * A,\n      w: -(G * D) + H * B - I * A\n    };\n}\n\n/**\n * Performs a linear interpolation between two vectors into a new vector\n *\n * @param left the left vector\n * @param right the right vector\n * @param t interpolation amount, in the range [0-1], between the two inputs (not clamped)\n * @returns a new vector\n */\nexport function vec4Lerp(left: rvec4, right: rvec4, t: number): vec4\n{\n    return {\n        x: left.x + t * (right.x - left.x),\n        y: left.y + t * (right.y - left.y),\n        z: left.z + t * (right.z - left.z),\n        w: left.w + t * (right.w - left.w)\n    };\n}\n\n\n  /**\n   * Transforms the vec4 with a mat4.\n   * @param {mat4} matrix matrix to transform with\n   * @returns {vec4} out\n   */\n  /*\n  transformMat4(matrix: mat4) {\n    const { data: out, data: a } = this;\n    const m = matrix.data;\n    let x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return this;\n  }\n    */\n\n  /**\n   * Transforms the vec4 with a quat\n   * @param {ReadonlyQuat} rotation quaternion to transform with\n   * @returns {vec4} out\n   */\n  /*\n  transformQuat(rotation: quat) {\n    const { data: out, data: a } = this;\n    const q = rotation.data;\n    let x = a[0],\n      y = a[1],\n      z = a[2];\n    let qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n\n    // calculate quat * vec\n    let ix = qw * x + qy * z - qz * y;\n    let iy = qw * y + qz * x - qx * z;\n    let iz = qw * z + qx * y - qy * x;\n    let iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    out[3] = a[3];\n    return this;\n  }*/\n\n/**\n * Creates a zero vector\n */\nexport function vec4Zero(): vec4\n{\n    return {x: 0, y: 0, z: 0, w: 0}\n}\n\nexport function vec4One(): vec4\n{\n    return {x: 1, y: 1, z: 1, w: 1}\n}", "import mathf, { AngleOrder } from \"./mathf\";\nimport { rvec3, vec3, vec3Cross, vec3CrossBy, vec3Dot, vec3Normalize, vec3SquaredLength } from \"./vec3\";\n\nexport interface quat\n{\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\nexport type rquat = Readonly<quat>;\n\nexport function quatIdentity(): quat\n{\n    return {x: 0, y: 0, z: 0, w: 1}\n}\n\n/**\n * Clones this quat\n *\n * @param v the quat to clone\n * @returns a new quat\n */\nexport function quatClone(v: rquat): quat\n{\n    return {x: v.x, y: v.y, z: v.z, w: v.w};\n}\n\n/**\n * Calculates the length quat q\n *\n * @params the source quat\n * @returns length of q\n */\nexport function quatLength(q: rquat)\n{\n    return Math.sqrt(q.x ** 2 + q.y ** 2 + q.z ** 2 + q.w ** 2);\n}\n\n/**\n * Calculates the squared length of a quat\n *\n * @params the source quat\n * @returns squared length of q\n */\nexport function quatSquaredLength(q: rquat)\n{\n    return q.x ** 2 + q.y ** 2 + q.z ** 2 + q.w ** 2;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis, then returns it.\n * @param q the target quat\n * @param axis the axis around which to rotate\n * @param rad the angle in radians\n * @returns the target quat\n */\nexport function quatSetAxisAngle(q: quat, axis: rvec3, rad: number)\n{\n    rad = rad * 0.5;\n    const s = Math.sin(rad);\n\n    q.x = s * axis.x;\n    q.y = s * axis.y;\n    q.z = s * axis.z;\n    q.w = Math.cos(rad);\n    return q\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as provided in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param out Vector receiving the axis of rotation\n * @param q Quaternion to be decomposed\n * @return Angle, in radians, of the rotation\n */\nexport function quatGetAxisAngle(out: vec3, q: rquat)\n{\n    const rad = Math.acos(q.w) * 2.0;\n    const s = Math.sin(rad / 2.0);\n\n    if (s > mathf.EPSILON)\n    {\n      out.x = q.x / s;\n      out.y = q.y / s;\n      out.z = q.z / s;\n    }\n    else\n    {\n      // If s is zero, return any axis (no rotation - axis does not matter)\n      out.x = 1;\n      out.y = 0;\n      out.z = 0;\n    }\n    return rad;\n}\n\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param left the left quat\n * @param right the right quat\n * @return Angle, in radians, between the two quaternions\n */\nexport function quatGetAngle(left: rquat, right: rquat)\n{\n    const dot = quatDot(left, right);\n    return Math.acos(2 * dot * dot - 1);\n}\n\n/**\n * Calculates the dot product of two quat's\n * @param left the left quat\n * @param right the right quat\n * @returns dot product of left and right\n */\nexport function quatDot(left: rquat, right: rquat)\n{\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n}\n\n  /**\n * Set the components of a quat to the given values\n *\n * @param x X component\n * @param y Y component\n * @param z Z component\n * @param w W component\n * @returns the target quat\n */\nexport function quatSet(q: quat, x: number, y: number, z: number, w: number)\n{\n    q.x = x;\n    q.y = y;\n    q.z = z;\n    q.w = w;\n    return q;\n}\n\n/**\n * Multiplies the left vector by the right vector\n * @param left the left vector\n * @param right the right vector\n * @returns the left vector\n */\nexport function quatMulTo(left: quat, right: rquat)\n{\n    const ax = left.x,\n      ay = left.y,\n      az = left.z,\n      aw = left.w;\n    const bx = right.x,\n      by = right.y,\n      bz = right.z,\n      bw = right.w;\n\n    left.x = ax * bw + aw * bx + ay * bz - az * by;\n    left.y = ay * bw + aw * by + az * bx - ax * bz;\n    left.z = az * bw + aw * bz + ax * by - ay * bx;\n    left.w = aw * bw - ax * bx - ay * by - az * bz;\n\n    return left;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function quatRotateX(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const bx = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw + aw * bx;\n    q.y = ay * bw + az * bx;\n    q.z = az * bw - ay * bx;\n    q.w = aw * bw - ax * bx;\n    return q;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function quatRotateY(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const by = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw - az * by;\n    q.y = ay * bw + aw * by;\n    q.z = az * bw + ax * by;\n    q.w = aw * bw - ay * by;\n    return q;\n}\n\n  /**\n   * Rotates a quaternion by the given angle about the Z axis\n   *\n   * @param {quat} out quat receiving operation result\n   * @param {quat} a quat to rotate\n   * @param {number} rad angle (in radians) to rotate\n   * @returns {quat} out\n   */\nexport function quatRotateZ(q: quat, rad: number)\n{\n    rad *= 0.5;\n\n    const ax = q.x,\n      ay = q.y,\n      az = q.z,\n      aw = q.w;\n    const bz = Math.sin(rad),\n      bw = Math.cos(rad);\n\n    q.x = ax * bw + ay * bz;\n    q.y = ay * bw - ax * bz;\n    q.z = az * bw + aw * bz;\n    q.w = aw * bw - az * bz;\n    return q;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @returns a new quat\n */\nexport function quatCalculateW(q: rquat): quat\n{\n    return {\n      x: q.x,\n      y: q.y,\n      z: q.z,\n      w: Math.sqrt(Math.abs(1.0 - q.x * q.x - q.y * q.y - q.z * q.z))\n    };\n}\n\n/**\n * Adds vector other into vec\n * @param left the left quat\n * @param right the right quat\n * @returns the target quat\n */\nexport function quatAddTo(left: quat, right: rquat)\n{\n    left.x += right.x;\n    left.y += right.y;\n    left.z += right.z;\n    left.w += right.w;\n    return left;\n}\n\n/**\n * Adds two vectors into a new quat\n * @param left the left quat\n * @param right the right quat\n * @returns a new quat\n */\nexport function quatAdd(left: rquat, right: rquat): quat\n{\n    return {\n        x: left.x + right.x,\n        y: left.y + right.y,\n        z: left.z + right.z,\n        w: left.w + right.w\n    }\n}\n\n/**\n * Subtracts quat other from quat vec\n * @param left the left quat\n * @param right the right quat\n * @returns the left quat\n */\nexport function quatSubFrom(left: quat, right: rquat)\n{\n    left.x -= right.x;\n    left.y -= right.y;\n    left.z -= right.z;\n    left.w -= right.w;\n    return left;\n}\n\n/**\n * Subtracts quat other from quat vec into a new quat\n * @param left the left quat\n * @param right the right quat\n * @returns a new quat\n */\nexport function quatSub(left: rquat, right: rquat): quat\n{\n    return {\n        x: left.x - right.x,\n        y: left.y - right.y,\n        z: left.z - right.z,\n        w: left.w - right.w,\n    }\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n * @param {quat} q the second operand\n * @param {number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function quatSlerp(left: rquat, right: rquat, t: number): quat\n{\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n    const ax = left.x,\n      ay = left.y,\n      az = left.z,\n      aw = left.w;\n    let bx = right.x,\n      by = right.y,\n      bz = right.z,\n      bw = right.w;\n\n    let omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    }\n\n    // calculate coefficients\n    if (1.0 - cosom > mathf.EPSILON)\n    {\n      // standard case (slerp)\n      omega = Math.acos(cosom);\n      sinom = Math.sin(omega);\n      scale0 = Math.sin((1.0 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    }\n    else\n    {\n      // \"from\" and \"to\" quaternions are very close\n      //  ... so we can do a linear interpolation\n      scale0 = 1.0 - t;\n      scale1 = t;\n    }\n    // calculate final values\n    return {\n      x: scale0 * ax + scale1 * bx,\n      y: scale0 * ay + scale1 * by,\n      z: scale0 * az + scale1 * bz,\n      w: scale0 * aw + scale1 * bw\n    };\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @returns {quat} out\n */\nexport function quatInvert(q: quat)\n{\n    const a0 = q.x,\n      a1 = q.y,\n      a2 = q.z,\n      a3 = q.w;\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1.0 / dot : 0;\n\n    q.x = -a0 * invDot;\n    q.y = -a1 * invDot;\n    q.z = -a2 * invDot;\n    q.w = a3 * invDot;\n    return q;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @returns {quat} out\n */\nexport function quatInverted(q: rquat): quat\n{\n    const a0 = q.x,\n      a1 = q.y,\n      a2 = q.z,\n      a3 = q.w;\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1.0 / dot : 0;\n\n    return {\n      x: -a0 * invDot,\n      y: -a1 * invDot,\n      z: -a2 * invDot,\n      w: a3 * invDot\n    };\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n * @returns {quat} out\n */\nexport function quatConjugate(q: quat)\n{\n    q.x = -q.x;\n    q.y = -q.y;\n    q.z = -q.z;\n    q.w = q.w;\n    return q;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n * @returns {quat} out\n */\nexport function quatConjugated(q: rquat): quat\n{\n    return {\n        x: -q.x,\n        y: -q.y,\n        z: -q.z,\n        w: -q.w\n    }\n}\n\n  /**\n   * Creates a quaternion from the given 3x3 rotation matrix.\n   *\n   * NOTE: The resultant quaternion is not normalized, so you should be sure\n   * to renormalize the quaternion yourself where necessary.\n   * @param {mat3} matrix rotation matrix\n   * @returns {quat} out\n   * @function\n   */\n  /*\n  fromMat3(matrix: mat3) {\n    const data=this.data\n    const m=matrix.data;\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    let fTrace = m[0] + m[4] + m[8];\n    let fRoot;\n\n    if (fTrace > 0.0) {\n      // |w| > 1/2, may as well choose w > 1/2\n      fRoot = Math.sqrt(fTrace + 1.0); // 2w\n      data[3] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot; // 1/(4w)\n      data[0] = (m[5] - m[7]) * fRoot;\n      data[1] = (m[6] - m[2]) * fRoot;\n      data[2] = (m[1] - m[3]) * fRoot;\n    } else {\n      // |w| <= 1/2\n      let i = 0;\n      if (m[4] > m[0]) i = 1;\n      if (m[8] > m[i * 3 + i]) i = 2;\n      let j = (i + 1) % 3;\n      let k = (i + 2) % 3;\n\n      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n      data[i] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot;\n      data[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n      data[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n      data[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n    return this;\n  }\n    */\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @params q the target quat\n * @param x Angle to rotate around X axis in degrees.\n * @param y Angle to rotate around Y axis in degrees.\n * @param z Angle to rotate around Z axis in degrees.\n * @param order Intrinsic order for conversion, default is zyx.\n * @returns the target quat\n */\nexport function quatFromEuler(q: quat, x: number, y: number, z: number, order: AngleOrder = mathf.ANGLE_ORDER)\n{\n    const halfToRad = Math.PI / 360;\n    x *= halfToRad;\n    z *= halfToRad;\n    y *= halfToRad;\n\n    const sx = Math.sin(x);\n    const cx = Math.cos(x);\n    const sy = Math.sin(y);\n    const cy = Math.cos(y);\n    const sz = Math.sin(z);\n    const cz = Math.cos(z);\n\n    switch (order) {\n      case \"xyz\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"xzy\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      case \"yxz\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz - sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      case \"yzx\":\n        q.x = sx * cy * cz + cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"zxy\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz + sx * sy * cz;\n        q.w = cx * cy * cz - sx * sy * sz;\n        break;\n\n      case \"zyx\":\n        q.x = sx * cy * cz - cx * sy * sz;\n        q.y = cx * sy * cz + sx * cy * sz;\n        q.z = cx * cy * sz - sx * sy * cz;\n        q.w = cx * cy * cz + sx * sy * sz;\n        break;\n\n      default:\n        throw new Error('Unknown angle order ' + order);\n    }\n\n    return this;\n}\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nexport function quatRotationTo(q: quat, a: rvec3, right: rvec3)\n{\n    const dot = vec3Dot(a, right);\n    if (dot < -0.999999)\n    {\n        const xUnit = {x: 1, y: 0, z: 0};\n        let tmpVec3 = vec3CrossBy(xUnit, xUnit, a);\n        if (vec3SquaredLength(tmpVec3) < mathf.EPSILON)\n        {\n            const yUnit = {x: 0, y: 1, z : 0};\n            tmpVec3 = vec3CrossBy(yUnit, yUnit, a);\n        }\n\n        vec3Normalize(tmpVec3, tmpVec3);\n\n        quatSetAxisAngle(q, tmpVec3, Math.PI);\n        return q;\n    }\n    else if (dot > 0.999999)\n    {\n        q.x = 0;\n        q.y = 0;\n        q.z = 0;\n        q.w = 1;\n        return this;\n    }\n    else\n    {\n        const tmpVec3 = vec3Cross(a, right);\n        q.x = tmpVec3.x;\n        q.y = tmpVec3.y;\n        q.z = tmpVec3.z;\n        q.w = 1 + dot;\n        return quatNormalize(q);\n    }\n}\n\n/**\n * Normalize the given vector v\n * @param v the target vector\n * @returns the target vector\n */\nexport function quatNormalize(v: quat)\n{\n    let sqrtLen = quatSquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    v.x *= sqrtLen;\n    v.y *= sqrtLen;\n    v.z *= sqrtLen;\n    v.w *= sqrtLen;\n    return v;\n}\n\n/**\n * Normalize the given vector v into a new vector\n * @param v the target vector\n * @returns a new vector\n */\nexport function quatNormalized(v: rquat): quat\n{\n    let sqrtLen = quatSquaredLength(v);\n    if (sqrtLen > 0)\n    {\n        sqrtLen = 1.0 / Math.sqrt(sqrtLen);\n    }\n\n    return {\n        x: v.x * sqrtLen,\n        y: v.y * sqrtLen,\n        z: v.z * sqrtLen,\n        w: v.w * sqrtLen\n    }\n}\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} b the second operand\n * @param {quat} c the third operand\n * @param {quat} d the fourth operand\n * @param {number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function quatSQlerp(a: rquat, b: rquat, c: rquat, d: rquat, t: number)\n{\n    const temp1 = quatSlerp(a, d, t);\n    const temp2 = quatSlerp(b, c, t);\n    return quatSlerp(temp1, temp2, 2 * t * (1 - t));\n};\n\n  /**\n   * Sets the specified quaternion with values corresponding to the given\n   * axes. Each axis is a vec3 and is expected to be unit length and\n   * perpendicular to all other specified axes.\n   *\n   * @param {vec3} view  the vector representing the viewing direction\n   * @param {vec3} right the vector representing the local \"right\" direction\n   * @param {vec3} up    the vector representing the local \"up\" direction\n   * @returns {quat} out\n   */\n//   export function quatSetAxes(view: vec3, right: vec3, up: vec3) {\n//     let _matrix = new mat3();\n//     const { data: matr } = _matrix;\n//     const { data: r } = right;\n//     const { data: v } = view;\n//     const { data: u } = up;\n//     matr[0] = r[0];\n//     matr[3] = r[1];\n//     matr[6] = r[2];\n\n//     matr[1] = u[0];\n//     matr[4] = u[1];\n//     matr[7] = u[2];\n\n//     matr[2] = -v[0];\n//     matr[5] = -v[1];\n//     matr[8] = -v[2];\n//     return this.fromMat3(_matrix).normalize();\n//   }", "import { Opaque } from \"./common\";\nimport { quat, quatIdentity, vec3, vec3Zero, vec4, vec4One } from \"./gl-matrix-ts\";\n\ninterface Light\n{\n    position: vec3;\n    radius: number;\n    colour: vec4;\n}\nexport const lightDataSize = 3 + 1 + 4;\n\nexport interface Camera\n{\n    position: vec3;\n    rotation: quat;\n    fieldOfView: number;\n}\n\nexport type SdfOpCode = 'none' | 'union' | 'intersection' | 'subtraction' | 'xor';\nexport type SdfOpCodeInt = Opaque<number, \"sdfOpCode\">;\nexport const SdfOpCodeNone = -5e2 as SdfOpCodeInt;\nexport const SdfOpCodeUnion = -6e2 as SdfOpCodeInt;\nexport const SdfOpCodeIntersection = -7e2 as SdfOpCodeInt;\nexport const SdfOpCodeSubtraction = -8e2 as SdfOpCodeInt;\nexport const SdfOpCodeXor = -9e2 as SdfOpCodeInt;\n\nexport type ShapeType = 'none' | 'box' | 'sphere' | 'hexPrism';\nexport type ShapeTypeInt = Opaque<number, \"shapeType\">;\nexport const ShapeTypeNone = -5e3 as ShapeTypeInt;\nexport const ShapeTypeBox = -6e3 as ShapeTypeInt;\nexport const ShapeTypeSphere = -7e3 as ShapeTypeInt;\nexport const ShapeTypeHexPrism = -8e3 as ShapeTypeInt;\ninterface Shape\n{\n    position: vec3;\n    rotation: quat;\n    maxSize: number;\n    type: ShapeType;\n    shapeParams: vec3;\n    diffuseColour: vec4;\n    specularColour: vec4;\n}\n\nconst SdfOpCodeMap: { readonly [key: string]: SdfOpCodeInt } =\n{\n    'none': SdfOpCodeNone,\n    'union': SdfOpCodeUnion,\n    'intersection': SdfOpCodeIntersection,\n    'subtraction': SdfOpCodeSubtraction,\n    'xor': SdfOpCodeXor,\n}\nconst ShapeTypeMap: { readonly [key: string]: ShapeTypeInt } =\n{\n    'none': ShapeTypeNone,\n    'box': ShapeTypeBox,\n    'sphere': ShapeTypeSphere,\n    'hexPrism': ShapeTypeHexPrism,\n}\n\nfunction toShapeTypeInt(type: ShapeType): ShapeTypeInt\n{\n    return ShapeTypeMap[type] || ShapeTypeNone;\n}\nfunction toOpCodeInt(type: SdfOpCode): SdfOpCodeInt\n{\n    return SdfOpCodeMap[type] || SdfOpCodeNone;\n}\n\nexport const shapeDataSize = 4 + 4 + 4 + 4;\n\nexport type ShapeOperation = number | SdfOpCode;\n\nexport class SdfScene\n{\n    private lights: Light[] = [];\n    private lightDataArray: number[] = [];\n\n    private shapes: Shape[] = [];\n    private shapeDataArray: number[] = [];\n\n    private operations: ShapeOperation[] = [];\n    private numberOperations: number[] = [];\n\n    public getLightDataArray()\n    {\n        return this.lightDataArray;\n    }\n\n    public getLights()\n    {\n        return this.lights;\n    }\n\n    public getNumLights()\n    {\n        return this.lights.length;\n    }\n\n    public getShapeDataArray()\n    {\n        return this.shapeDataArray;\n    }\n\n    public getShapes()\n    {\n        return this.shapes;\n    }\n\n    public getNumTotalShapes()\n    {\n        return this.shapes.length;\n    }\n\n    public setOperations(operations: ShapeOperation[])\n    {\n        this.operations = operations;\n        this.updateOperationNumbers();\n    }\n\n    public getOperations()\n    {\n        return this.operations;\n    }\n\n    public getOperationNumbers()\n    {\n        return this.numberOperations;\n    }\n\n    public setLight(index: number, light: Partial<Light>)\n    {\n        if (index < 0)\n        {\n            throw new Error(`Out of bounds light index ${index}`);\n        }\n\n        if (index >= this.lights.length)\n        {\n            this.lights[index] = { ...this.createNewLight(), ...light };\n        }\n        else\n        {\n            this.lights[index] = { ...this.lights[index], ...light };\n        }\n\n        this.updateLight(index);\n    }\n\n    public setShape(index: number, shape: Partial<Shape>)\n    {\n        if (index < 0)\n        {\n            throw new Error(`Out of bounds shape index ${index}`);\n        }\n\n        if (index >= this.shapes.length)\n        {\n            this.shapes[index] = { ...this.createNewShape(), ...shape };\n        }\n        else\n        {\n            this.shapes[index] = { ...this.shapes[index], ...shape };\n        }\n\n        this.updateShape(index);\n    }\n\n    private updateLight(index: number)\n    {\n        const dataIndex = index * lightDataSize;\n        const light = this.lights[index];\n\n        this.lightDataArray[dataIndex    ] = light.position.x;\n        this.lightDataArray[dataIndex + 1] = light.position.y;\n        this.lightDataArray[dataIndex + 2] = light.position.z;\n        this.lightDataArray[dataIndex + 3] = light.radius;\n        this.lightDataArray[dataIndex + 4] = light.colour.x;\n        this.lightDataArray[dataIndex + 5] = light.colour.y;\n        this.lightDataArray[dataIndex + 6] = light.colour.z;\n        this.lightDataArray[dataIndex + 7] = light.colour.w;\n    }\n\n    private updateShape(index: number)\n    {\n        const dataIndex = index * shapeDataSize;\n        const shape = this.shapes[index];\n\n        this.shapeDataArray[dataIndex     ] = shape.position.x;\n        this.shapeDataArray[dataIndex +  1] = shape.position.y;\n        this.shapeDataArray[dataIndex +  2] = shape.position.z;\n        this.shapeDataArray[dataIndex +  3] = shape.maxSize;\n\n        this.shapeDataArray[dataIndex +  4] = shape.rotation.x;\n        this.shapeDataArray[dataIndex +  5] = shape.rotation.y;\n        this.shapeDataArray[dataIndex +  6] = shape.rotation.z;\n        this.shapeDataArray[dataIndex +  7] = shape.rotation.w;\n\n        this.shapeDataArray[dataIndex +  8] = toShapeTypeInt(shape.type);\n        this.shapeDataArray[dataIndex +  9] = shape.shapeParams.x;\n        this.shapeDataArray[dataIndex + 10] = shape.shapeParams.y;\n        this.shapeDataArray[dataIndex + 11] = shape.shapeParams.z;\n\n        this.shapeDataArray[dataIndex + 12] = shape.diffuseColour.x;\n        this.shapeDataArray[dataIndex + 13] = shape.diffuseColour.y;\n        this.shapeDataArray[dataIndex + 14] = shape.diffuseColour.z;\n        this.shapeDataArray[dataIndex + 15] = shape.diffuseColour.w;\n\n        // this.shapeDataArray[dataIndex + 16] = shape.specularColour.x;\n        // this.shapeDataArray[dataIndex + 17] = shape.specularColour.y;\n        // this.shapeDataArray[dataIndex + 18] = shape.specularColour.z;\n        // this.shapeDataArray[dataIndex + 19] = shape.specularColour.w;\n    }\n\n    private updateOperationNumbers()\n    {\n        this.numberOperations = this.operations.map(i =>\n        {\n            if (typeof(i) === 'string')\n            {\n                return toOpCodeInt(i);\n            }\n            return i;\n        });\n    }\n\n    private createNewLight(): Light\n    {\n        return {\n            position: vec3Zero(),\n            radius: 10,\n            colour: vec4One()\n        }\n    }\n\n    private createNewShape(): Shape\n    {\n        return {\n            position: vec3Zero(),\n            rotation: quatIdentity(),\n            maxSize: 0,\n            type: \"none\",\n            shapeParams: vec3Zero(),\n            diffuseColour: {x: 0.7, y: 0.3, z: 0.2, w: 1.0},\n            specularColour: {x: 1.0, y: 0.8, z: 0.9, w: 1.0}\n        }\n    }\n}", "import { toRadian } from \"./common\";\nimport { mat3, rvec2, vec2, vec2Length, vec2LengthValues, vec3, rvec3, vec3Normalized, vec3Sub, vec3Cross, vec3Normalize, vec3Zero, vec3ScaleAndAddBy, vec3NormalizedValues, vec3Dot, vec3Negated, vec3Scale, vec3AddTo, vec3MulTo, vec3Mul, vec3Length, vec3Abs, vec3SubFrom, vec3Max, vec3CrossBy, vec2Dot, vec3ScaleBy, rvec4, vec4Zero, vec4One, vec3NormalizeValues } from \"./gl-matrix-ts\";\nimport mathf from \"./gl-matrix-ts/mathf\";\nimport { lightDataSize } from \"./sdf-scene\";\n\n// Many functions were ported from GLSL from this page:\n// https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\nexport const MAX_MARCHING_STEPS = 255;\nexport const EPSILON = 0.0001;\n\nexport interface RayWithMaterial\n{\n    distance: number,\n    diffuseColour: rvec4,\n    // specularColour: rvec4\n}\n\nexport type RayMarchSceneDist = (point: vec3) => number;\nexport type RayMarchSceneMaterial = (point: vec3) => RayWithMaterial;\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nlet f: vec3 = vec3Zero();\nlet s: vec3 = vec3Zero();\nlet u: vec3 = vec3Zero();\nexport function createViewMatrix(out: mat3, eye: rvec3, center: rvec3, up: rvec3)\n{\n    vec3SubFrom(f, center, eye);\n    vec3Normalize(f, f);\n\n    vec3CrossBy(s, f, up);\n    vec3Normalize(s, s)\n\n    vec3CrossBy(u, s, f);\n\n    out.m00 =  s.x; out.m01 =  s.y; out.m02 =  s.z;\n    out.m10 =  u.x; out.m11 =  u.y; out.m12 =  u.z;\n    out.m20 = -f.x; out.m21 = -f.y; out.m22 = -f.z;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n *\n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nexport function rayDirection(result: vec3, z: number, size: rvec2, fragCoord: rvec2): vec3\n{\n    const x = fragCoord.x + size.x * -0.5;\n    const y = fragCoord.y + size.y * -0.5;\n\n    result.x = x;\n    result.y = y;\n    result.z = -z;\n    vec3Normalize(result, result);\n    return result;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n *\n * @param rayOrigin the eye point, acting as the origin of the ray\n * @param rayDirection the normalized direction to march in\n * @param near the starting distance away from the eye\n * @param far the max distance away from the ey to march before giving up\n * @returns the shortest distance found, if nothing is found then end is returned\n */\nconst rayMarchPoint = vec3Zero();\nexport function rayMarchDist(rayOrigin: rvec3, rayDirection: rvec3, near: number, far: number, scene: RayMarchSceneDist): number\n{\n    rayMarchPoint.x = rayMarchPoint.y = rayMarchPoint.z = 0;\n    let depth = near;\n\n    for (let i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3ScaleAndAddBy(rayMarchPoint, rayOrigin, rayDirection, depth);\n        const dist = scene(rayMarchPoint);\n        if (dist <= EPSILON)\n        {\n            return depth;\n        }\n\n        depth += dist;\n        if (depth >= far)\n        {\n            return far;\n        }\n    }\n\n    return far;\n}\n\nexport const zeroColour = vec4Zero();\nexport function rayMarchMaterial(rayOrigin: rvec3, rayDirection: rvec3, near: number, far: number, scene: RayMarchSceneMaterial): RayWithMaterial\n{\n    rayMarchPoint.x = rayMarchPoint.y = rayMarchPoint.z = 0;\n    let depth = near;\n\n    for (let i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3ScaleAndAddBy(rayMarchPoint, rayOrigin, rayDirection, depth);\n        const dist = scene(rayMarchPoint);\n        if (dist.distance <= EPSILON)\n        {\n            return { distance: depth, diffuseColour: dist.diffuseColour };\n        }\n\n        depth += dist.distance;\n        if (depth >= far)\n        {\n            break;\n        }\n    }\n\n    return { distance: far, diffuseColour: zeroColour };\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nlet debugCount = 100;\nexport function estimateNormal(point: rvec3, currentDepth: number, scene: RayMarchSceneDist): vec3\n{\n    const eps = currentDepth * 0.0015;\n    const p1: vec3 = {x: point.x + eps, y: point.y, z: point.z};\n    const p2: vec3 = {x: point.x - eps, y: point.y, z: point.z};\n\n    const d1 = scene(p1);\n    const d2 = scene(p2);\n    const x = d1 - d2;\n\n    p1.x = point.x;\n    p1.y = point.y + eps;\n    p2.x = point.x;\n    p2.y = point.y - eps;\n\n    const d3 = scene(p1);\n    const d4 = scene(p2);\n    const y = d3 - d4;\n\n    p1.y = point.y;\n    p1.z = point.z + eps;\n    p2.y = point.y;\n    p2.z = point.z - eps;\n\n    const d5 = scene(p1);\n    const d6 = scene(p2);\n    const z = d5 - d6;\n\n    return vec3NormalizedValues(x, y, z);\n}\n\nexport function estimateNormalMaterial(point: rvec3, currentDepth: number, scene: RayMarchSceneMaterial): vec3\n{\n    const eps = currentDepth * 0.0015;\n    const p1: vec3 = {x: point.x + eps, y: point.y, z: point.z};\n    const p2: vec3 = {x: point.x - eps, y: point.y, z: point.z};\n\n    const d1 = scene(p1);\n    const d2 = scene(p2);\n    const x = d1.distance - d2.distance;\n\n    p1.x = point.x;\n    p1.y = point.y + eps;\n    p2.x = point.x;\n    p2.y = point.y - eps;\n\n    const d3 = scene(p1);\n    const d4 = scene(p2);\n    const y = d3.distance - d4.distance;\n\n    p1.y = point.y;\n    p1.z = point.z + eps;\n    p2.y = point.y;\n    p2.z = point.z - eps;\n\n    const d5 = scene(p1);\n    const d6 = scene(p2);\n    const z = d5.distance - d6.distance;\n\n    return vec3NormalizedValues(x, y, z);\n}\n\n// Lambert\n// vec3 calcNormal(vec3 pos)\n// {\n//     // Center sample\n//     float c = sdf(pos);\n//     // Use offset samples to compute gradient / normal\n//     vec2 eps_zero = vec2(0.001, 0.0);\n    // return normalize(vec3(\n    //     sdf(pos + eps_zero.xyy),\n    //     sdf(pos + eps_zero.yxy),\n    //     sdf(pos + eps_zero.yyx)\n    // ) - c);\n// }\nexport function estimateNormalMaterialLambert(point: rvec3, currentDepth: number, scene: RayMarchSceneMaterial): vec3\n{\n    const eps = currentDepth * 0.0015;\n\n    const testPoint: vec3 = {x: point.x + eps, y: point.y, z: point.z};\n    const x = scene(testPoint).distance;\n\n    testPoint.x = point.x;\n    testPoint.y = point.y + eps;\n    const y = scene(testPoint).distance;\n\n    testPoint.y = point.y;\n    testPoint.z = point.z + eps;\n    const z = scene(testPoint).distance;\n\n    return vec3NormalizeValues(testPoint, x - currentDepth, y - currentDepth, z - currentDepth);\n}\n\n// https://asawicki.info/news_1301_reflect_and_refract_functions.html\nexport function reflect(out: vec3, incidentVec: rvec3, normal: rvec3)\n{\n    const dot = vec3Dot(incidentVec, normal);\n    vec3ScaleAndAddBy(out, incidentVec, normal, -2 * dot);\n    return out;\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n *\n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nexport function phongContribForLight(scene: RayMarchSceneDist,\n    currentDepth: number,\n    diffuseColour: rvec4, specularColour: rvec3,\n    point: rvec3, eye: rvec3,\n    lightPos: rvec3, lightIntensity: rvec3): vec3\n{\n    const N = estimateNormal(point, currentDepth, scene);\n\n    const L = vec3Normalized(vec3Sub(lightPos, point));\n    const nL = vec3Negated(L);\n\n    const V = vec3Normalized(vec3Sub(eye, point));\n    const R = vec3Normalized(reflect(vec3Zero(), nL, N));\n\n    const dotLN = vec3Dot(L, N);\n    const dotRV = vec3Dot(R, V);\n\n    if (dotLN < 0.0)\n    {\n        // Light not visible from this point on the surface\n        return vec3Zero();\n    }\n\n    let r1: vec3;\n\n    if (dotRV < 0.0)\n    {\n        // Light reflection in opposite direction as viewer, apply only diffuse component\n        r1 = vec3Scale(diffuseColour, dotLN);\n    }\n    else\n    {\n        const r2 = vec3Scale(diffuseColour, dotLN);\n        const pow = Math.pow(dotRV, diffuseColour.w);\n        r1 = vec3Scale(specularColour, pow);\n\n        vec3AddTo(r1, r1, r2);\n    }\n\n    vec3MulTo(r1, r1, lightIntensity);\n    return r1;\n}\n\nexport function phongContribForLightMaterial(scene: RayMarchSceneMaterial,\n    currentDepth: number,\n    diffuseColour: rvec4, specularColour: rvec3,\n    point: rvec3, eye: rvec3,\n    lightPos: rvec3, lightIntensity: rvec3): vec3\n{\n    const N = estimateNormalMaterial(point, currentDepth, scene);\n\n    const L = vec3Normalized(vec3Sub(lightPos, point));\n    const nL = vec3Negated(L);\n\n    const V = vec3Normalized(vec3Sub(eye, point));\n    const R = vec3Normalized(reflect(vec3Zero(), nL, N));\n\n    const dotLN = vec3Dot(L, N);\n    const dotRV = vec3Dot(R, V);\n\n    if (dotLN < 0.0)\n    {\n        // Light not visible from this point on the surface\n        return vec3Zero();\n    }\n\n    let r1: vec3;\n\n    if (dotRV < 0.0)\n    {\n        // Light reflection in opposite direction as viewer, apply only diffuse component\n        r1 = vec3Scale(diffuseColour, dotLN);\n    }\n    else\n    {\n        const r2 = vec3Scale(diffuseColour, dotLN);\n        const pow = Math.pow(dotRV, diffuseColour.w);\n        r1 = vec3Scale(specularColour, pow);\n\n        vec3AddTo(r1, r1, r2);\n    }\n\n    vec3MulTo(r1, r1, lightIntensity);\n    return r1;\n}\n\n/**\n * Lighting via Phong illumination.\n *\n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\nconst fixedAmbientLight: rvec3 = {x: 0.1, y: 0.1, z: 0.1};\nexport function phongIllumination(scene: RayMarchSceneDist, currentDepth: number, diffuseColour: rvec4, specularColour: rvec3, point: rvec3, rayOrigin: rvec3, numLights: number, lightData: number[]): vec3\n{\n    const colour: vec3 = { x: fixedAmbientLight.x, y: fixedAmbientLight.y, z: fixedAmbientLight.z };\n\n    for (let i = 0; i < numLights; i++)\n    {\n        const lightIndex = i * lightDataSize;\n        const lightPos = {\n            x: lightData[lightIndex    ],\n            y: lightData[lightIndex + 1],\n            z: lightData[lightIndex + 2]\n        }\n        const lightRadius = lightData[lightIndex + 3];\n        const lightColour = {\n            x: lightData[lightIndex + 4],\n            y: lightData[lightIndex + 5],\n            z: lightData[lightIndex + 6]\n        }\n\n        const toLight = vec3Normalized(vec3Sub(lightPos, point));\n        const shadow = softShadow(scene, point, toLight, 0.1, 100);\n        const lightContrib = phongContribForLight(scene, currentDepth, diffuseColour, specularColour, point, rayOrigin, lightPos, lightColour);\n        vec3AddTo(colour, colour, vec3ScaleBy(lightContrib, lightContrib, shadow));\n    }\n\n    return colour;\n}\n\nconst whiteColour = vec4One();\nexport function phongIlluminationMaterial(scene: RayMarchSceneMaterial, currentPoint: RayWithMaterial, point: rvec3, rayOrigin: rvec3, numLights: number, lightData: number[]): vec3\n{\n    const colour: vec3 = { x: fixedAmbientLight.x, y: fixedAmbientLight.y, z: fixedAmbientLight.z };\n\n    for (let i = 0; i < numLights; i++)\n    {\n        const lightIndex = i * lightDataSize;\n        const lightPos = {\n            x: lightData[lightIndex    ],\n            y: lightData[lightIndex + 1],\n            z: lightData[lightIndex + 2]\n        }\n        const lightRadius = lightData[lightIndex + 3];\n        const lightColour = {\n            x: lightData[lightIndex + 4],\n            y: lightData[lightIndex + 5],\n            z: lightData[lightIndex + 6]\n        }\n\n        const toLight = vec3Normalized(vec3Sub(lightPos, point));\n        const shadow = softShadowMaterial(scene, point, toLight, 0.1, 100);\n        const lightContrib = phongContribForLightMaterial(scene, currentPoint.distance, currentPoint.diffuseColour, whiteColour, point, rayOrigin, lightPos, lightColour);\n        vec3AddTo(colour, colour, vec3ScaleBy(lightContrib, lightContrib, shadow));\n    }\n\n    return colour;\n}\n\nconst shadowSharpness = 32;\nconst shadowPoint = vec3Zero();\nexport function softShadow(scene: RayMarchSceneDist, rayOrigin: rvec3, rayDirection: rvec3, near: number, far: number)\n{\n    let result = 1.0;\n    shadowPoint.x = shadowPoint.y = shadowPoint.z = 0;\n\n    let t = near;\n    for (let i = 0; i < MAX_MARCHING_STEPS && t < far; i++)\n    {\n        vec3ScaleAndAddBy(shadowPoint, rayOrigin, rayDirection, t);\n        const dist = scene(shadowPoint);\n        if (dist < EPSILON)\n        {\n            return 0.0;\n        }\n\n        result = Math.min(result, shadowSharpness * dist / t);\n        t += dist;\n    }\n\n    return result;\n}\nexport function softShadowMaterial(scene: RayMarchSceneMaterial, rayOrigin: rvec3, rayDirection: rvec3, near: number, far: number)\n{\n    let result = 1.0;\n    shadowPoint.x = shadowPoint.y = shadowPoint.z = 0;\n\n    let t = near;\n    for (let i = 0; i < MAX_MARCHING_STEPS && t < far; i++)\n    {\n        vec3ScaleAndAddBy(shadowPoint, rayOrigin, rayDirection, t);\n        const dist = scene(shadowPoint);\n        if (dist.distance < EPSILON)\n        {\n            return dist.distance;\n        }\n\n        result = Math.min(result, shadowSharpness * dist.distance / t);\n        t += dist.distance;\n    }\n\n    return result;\n}\n\n\nexport function sdfSphere(point: rvec3, radius: number)\n{\n    return vec3Length(point) - radius;\n}\n\nexport function sdfTorus(p: rvec3, t: rvec2)\n{\n  const q: vec2 = {x: vec2LengthValues(p.x, p.z) - t.x, y: p.y};\n  return vec2Length(q) - t.y;\n}\n\nexport function sdfBox(p: rvec3, size: rvec3)\n{\n    const d = vec3Sub(vec3Abs(p), size);\n    const outsideDistance = vec3Length(vec3Max(d, 0.0));\n    const insideDistance = Math.min(Math.max(d.x, Math.max(d.y, d.z)), 0);\n    return outsideDistance + insideDistance;\n}\n\nconst hexConsts: rvec3 = {x: -0.8660254, y: 0.5, z: 0.57735};\nexport function sdfHexPrim(p: rvec3, h: rvec2)\n{\n    const absP = vec3Abs(p);\n    const dot = 2.0 * Math.min(vec2Dot(hexConsts, absP), 0);\n    absP.x -= dot * hexConsts.x;\n    absP.y -= dot * hexConsts.y;\n\n    const clamped = mathf.clamp(absP.x, -hexConsts.z * h.x, hexConsts.z * h.x);\n    const dx = vec2LengthValues(absP.x - clamped, absP.y - h.x) * Math.sign(absP.y - h.x);\n    const dy = absP.z - h.y;\n    const maxDx = Math.max(dx, 0);\n    const maxDy = Math.max(dy, 0);\n\n    return Math.min(Math.max(dx, dy), 0) + vec2LengthValues(maxDx, maxDy);\n}\n\nexport function sdfOpUnion(d1: number, d2: number)\n{\n    return Math.min(d1, d2);\n}\n\nexport function sdfOpSub(d1: number, d2: number)\n{\n    return Math.max(-d1, d2);\n}\n\nexport function sdfOpIntersection(d1: number, d2: number)\n{\n    return Math.max(d1, d2);\n}\n\nexport function sdfOpXor(d1: number, d2: number)\n{\n    return Math.max(Math.min(d1, d2), -Math.max(d1, d2));\n}", "import { WorkerRenderRequest } from \"./states\";\nimport { sdfSphere, rayDirection, phongIllumination, sdfBox, sdfOpSub, sdfHexPrim, sdfOpIntersection, sdfOpUnion, sdfOpXor, RayWithMaterial, zeroColour, rayMarchMaterial, phongIlluminationMaterial, rayMarchDist } from \"./ray-marching\";\nimport { mat4GetTranslation, mat4Identity, quatIdentity, quatSetAxisAngle, rvec2, rvec3, rvec4, vec2Zero, vec3Length, vec3ScaleAndAddBy, vec3SubFrom, vec3TransformMat3, vec3TransformQuat, vec3Zero } from \"./gl-matrix-ts\";\nimport { SdfOpCodeInt, SdfOpCodeIntersection, SdfOpCodeNone, SdfOpCodeSubtraction, SdfOpCodeUnion, SdfOpCodeXor, shapeDataSize, ShapeTypeBox, ShapeTypeHexPrism, ShapeTypeInt, ShapeTypeNone, ShapeTypeSphere } from \"./sdf-scene\";\nimport mathf from \"./gl-matrix-ts/mathf\";\n\nconst maxSize = 1.5;\nconst transform = mat4Identity();\nconst transPoint = vec3Zero();\nconst rotation = quatIdentity();\n\nconst depthStack: number[] = [];\nconst depthMaterialStack: RayWithMaterial[] = [];\n\nconst testPoint = vec3Zero();\n\nfunction calculateDist(index: number, point: rvec3, shapeData: number[])\n{\n    const i = index * shapeDataSize;\n\n    testPoint.x = shapeData[i];\n    testPoint.y = shapeData[i + 1];\n    testPoint.z = shapeData[i + 2];\n\n    const radius = shapeData[i + 3];\n    vec3SubFrom(testPoint, testPoint, point);\n\n    if (radius > 0)\n    {\n        const diff = vec3Length(testPoint);\n        if (diff > radius + 3)\n        {\n            return diff - 3;\n        }\n    }\n\n    rotation.x = shapeData[i + 4];\n    rotation.y = shapeData[i + 5];\n    rotation.z = shapeData[i + 6];\n    rotation.w = shapeData[i + 7];\n\n    vec3TransformQuat(transPoint, testPoint, rotation);\n\n    const type = shapeData[i + 8] as ShapeTypeInt;\n    const params: rvec3 = {\n        x: shapeData[i + 9],\n        y: shapeData[i + 10],\n        z: shapeData[i + 11],\n    };\n\n    return getDistToType(type, transPoint, params);\n}\n\nfunction calculateDistMaterial(index: number, point: rvec3, shapeData: number[]): RayWithMaterial\n{\n    const i = index * shapeDataSize;\n\n    testPoint.x = shapeData[i];\n    testPoint.y = shapeData[i + 1];\n    testPoint.z = shapeData[i + 2];\n\n    const radius = shapeData[i + 3];\n    vec3SubFrom(testPoint, testPoint, point);\n\n    if (radius > 0)\n    {\n        const diff = vec3Length(testPoint);\n        if (diff > radius + 3)\n        {\n            return { distance: diff - 3, diffuseColour: zeroColour };\n        }\n    }\n\n    rotation.x = shapeData[i + 4];\n    rotation.y = shapeData[i + 5];\n    rotation.z = shapeData[i + 6];\n    rotation.w = shapeData[i + 7];\n\n    vec3TransformQuat(transPoint, testPoint, rotation);\n\n    const type = shapeData[i + 8] as ShapeTypeInt;\n    const params: rvec3 = {\n        x: shapeData[i + 9],\n        y: shapeData[i + 10],\n        z: shapeData[i + 11],\n    };\n\n    const distance = getDistToType(type, transPoint, params);\n\n    const diffuseColour = {\n        x: shapeData[i + 12],\n        y: shapeData[i + 13],\n        z: shapeData[i + 14],\n        w: shapeData[i + 15],\n    }\n    // const specularColour = {\n    //     x: shapeData[i + 16],\n    //     y: shapeData[i + 17],\n    //     z: shapeData[i + 18],\n    //     w: shapeData[i + 19],\n    // }\n\n    return { distance, diffuseColour };\n}\n\nfunction sceneFromDataNoRecursive(point: rvec3, shapeData: number[], operations: number[]): number\n{\n    let operationsIndex = 0;\n    let depthStackIndex = -1;\n\n    while (operationsIndex < operations.length)\n    {\n        const operation = operations[operationsIndex++];\n\n        if (operation <= SdfOpCodeNone)\n        {\n            const lastD2 = depthStack[depthStackIndex--];\n            const lastD1 = depthStack[depthStackIndex--];\n            const dist = applyOpCode(operation as SdfOpCodeInt, lastD2, lastD1);\n            depthStack[++depthStackIndex] = dist;\n        }\n        else\n        {\n            // Calculate dist of object at index\n            const dist = calculateDist(operation, point, shapeData);\n            depthStack[++depthStackIndex] = dist;\n        }\n    }\n\n    return depthStack[0];\n}\n\nfunction sceneFromDataNoRecursiveMaterial(point: rvec3, shapeData: number[], operations: number[]): RayWithMaterial\n{\n    let operationsIndex = 0;\n    let depthStackIndex = -1;\n\n    while (operationsIndex < operations.length)\n    {\n        const operation = operations[operationsIndex++];\n\n        if (operation <= SdfOpCodeNone)\n        {\n            const lastD2 = depthMaterialStack[depthStackIndex--];\n            const lastD1 = depthMaterialStack[depthStackIndex--];\n            const dist = applyOpCodeMaterial(operation as SdfOpCodeInt, lastD2, lastD1);\n            depthMaterialStack[++depthStackIndex] = dist;\n        }\n        else\n        {\n            // Calculate dist of object at index\n            const dist = calculateDistMaterial(operation, point, shapeData);\n            depthMaterialStack[++depthStackIndex] = dist;\n        }\n    }\n\n    return depthMaterialStack[0];\n}\n\nfunction getDistToType(opCode: ShapeTypeInt, point: rvec3, params: rvec3)\n{\n    switch (opCode)\n    {\n        case ShapeTypeBox: return sdfBox(point, params);\n        case ShapeTypeSphere: return sdfSphere(point, params.x);\n        case ShapeTypeHexPrism: return sdfHexPrim(point, params);\n    }\n    return 100;\n}\n\nfunction applyOpCode(opCode: SdfOpCodeInt, dist1: number, dist2: number)\n{\n    switch (opCode)\n    {\n        case SdfOpCodeUnion: return sdfOpUnion(dist1, dist2);\n        case SdfOpCodeIntersection: return sdfOpIntersection(dist1, dist2);\n        case SdfOpCodeSubtraction: return sdfOpSub(dist1, dist2);\n        case SdfOpCodeXor: return sdfOpXor(dist1, dist2);\n    }\n    return 100;\n}\n\nfunction applyOpCodeMaterial(opCode: SdfOpCodeInt, dist1: RayWithMaterial, dist2: RayWithMaterial): RayWithMaterial\n{\n    switch (opCode)\n    {\n        case SdfOpCodeUnion:\n            return dist1.distance < dist2.distance ? dist1 : dist2;\n        case SdfOpCodeIntersection:\n            return dist1.distance > dist2.distance ? dist1 : dist2;\n        case SdfOpCodeSubtraction:\n            return -dist1.distance > dist2.distance ? {\n                distance: -dist1.distance,\n                diffuseColour: dist1.diffuseColour,\n            } : dist2;\n        case SdfOpCodeXor:\n            return {\n                distance: sdfOpXor(dist1.distance, dist2.distance),\n                diffuseColour: dist1.diffuseColour,\n            };\n    }\n\n    return {\n        distance: 100,\n        diffuseColour: zeroColour,\n    }\n}\n\nfunction scene(point: rvec3): number\n{\n    mat4GetTranslation(transform, transPoint);\n    const diff = vec3Length(transPoint);\n    if (diff > maxSize + 3)\n    {\n        return diff - 3;\n    }\n\n    // vec3TransformMat4(transPoint, point, transform);\n    vec3TransformQuat(transPoint, point, rotation);\n\n    const sphere = sdfSphere(transPoint, 1.5);\n    // const sphere = sdfSphere(point, 1.2);\n    // sdfTorus(point, {x: 1, y: 0.5});\n    const hex = sdfHexPrim(transPoint, {x: 2, y: 1.5});\n    const box = sdfBox(transPoint, {x: 2, y: 1.5, z: 1});\n\n    // const sphere = sdfSphere(point, 1.5);\n    // const sphere = diff - 1.5;\n    // return sphere;\n    // const torus = sdfTorus(point, {x: 2, y: 1.5});\n    // // const op = sdfOpSub(sphere, box);\n    return sdfOpSub(mathf.lerp(sphere, hex, lerpTime), box);\n    // return mathf.lerp(sphere, hex, lerpTime);\n}\n\nconst emptyColour: rvec4 = {x: 0, y: 0, z: 0, w: 255};\nconst redColour: rvec4 = {x: 255, y: 0, z: 0, w: 255};\nlet lerpTime = 0;\n\nexport function renderScene1(request: WorkerRenderRequest)\n{\n    let index = 0;\n\n    const {\n        buffer,\n        width,\n        height,\n        totalHeight,\n        totalWidth,\n        xPos,\n        yPos,\n        cameraMatrix,\n        cameraPosition,\n        cameraZDir,\n        time,\n        numLights,\n        lightData,\n        operations,\n        shapeData\n    } = request;\n    const view = new Uint8ClampedArray(buffer);\n\n    lerpTime = Math.sin(time) * 0.5 + 0.5;\n\n    const viewSize: rvec2 = {x: totalWidth, y: totalHeight};\n    const rayDir = vec3Zero();\n    const closestPoint = vec3Zero();\n    const fragCoord = vec2Zero();\n\n    const K_d: rvec4 = {x: 0.7, y: 0.2, z: 0.2, w: 1};\n    const K_s: rvec3 = {x: 1.0, y: 1.0, z: 1.0};\n    const shininess = 10.0;\n\n    quatSetAxisAngle(rotation, {x: 0, y: 1, z: 0}, time);\n\n    for (let y = 0; y < height; y++)\n    {\n        for (let x = 0; x < width; x++)\n        {\n            fragCoord.x = x + xPos;\n            fragCoord.y = totalHeight - (y + yPos);\n\n            const viewDir = rayDirection(rayDir, cameraZDir, viewSize, fragCoord);\n            vec3TransformMat3(viewDir, viewDir, cameraMatrix);\n\n            let dist = 100;\n            const newDist = rayMarchDist(cameraPosition, viewDir, 0, 100, (p) => sceneFromDataNoRecursive(p, shapeData, operations));\n            if (newDist < dist)\n            {\n                dist = newDist;\n            }\n\n            let colour = redColour;\n\n            if (dist > 99)\n            {\n                colour = emptyColour;\n            }\n            else\n            {\n                // The closest point on the surface to the eyepoint along the view ray\n                vec3ScaleAndAddBy(closestPoint, cameraPosition, viewDir, dist);\n\n                const colouredLight = phongIllumination((p) => sceneFromDataNoRecursive(p, shapeData, operations), dist, K_d, K_s, closestPoint, cameraPosition, numLights, lightData);\n                colour = {\n                    x: colouredLight.x * 255,\n                    y: colouredLight.y * 255,\n                    z: colouredLight.z * 255,\n                    w: 255,\n                };\n            }\n\n            view[index] = colour.x;\n            view[index + 1] = colour.y;\n            view[index + 2] = colour.z;\n            view[index + 3] = colour.w;\n\n            index += 4;\n        }\n    }\n}\n\nexport function renderScene2(request: WorkerRenderRequest)\n{\n    let index = 0;\n\n    const {\n        buffer,\n        width,\n        height,\n        totalHeight,\n        totalWidth,\n        xPos,\n        yPos,\n        cameraMatrix,\n        cameraPosition,\n        cameraZDir,\n        time,\n        numLights,\n        lightData,\n        operations,\n        shapeData\n    } = request;\n    const view = new Uint8ClampedArray(buffer);\n\n    lerpTime = Math.sin(time) * 0.5 + 0.5;\n\n    const viewSize: rvec2 = {x: totalWidth, y: totalHeight};\n    const rayDir = vec3Zero();\n    const closestPoint = vec3Zero();\n    const fragCoord = vec2Zero();\n\n    quatSetAxisAngle(rotation, {x: 0, y: 1, z: 0}, time);\n\n    for (let y = 0; y < height; y++)\n    {\n        for (let x = 0; x < width; x++)\n        {\n            fragCoord.x = x + xPos;\n            fragCoord.y = totalHeight - (y + yPos);\n\n            const viewDir = rayDirection(rayDir, cameraZDir, viewSize, fragCoord);\n            vec3TransformMat3(viewDir, viewDir, cameraMatrix);\n\n            let dist: RayWithMaterial = { distance: 100, diffuseColour: zeroColour };\n            const newDist = rayMarchMaterial(cameraPosition, viewDir, 0, 100, (p) => sceneFromDataNoRecursiveMaterial(p, shapeData, operations));\n            if (newDist.distance < dist.distance)\n            {\n                dist = newDist;\n            }\n\n            let colour = redColour;\n\n            if (dist.distance > 99)\n            {\n                colour = emptyColour;\n            }\n            else\n            {\n                // The closest point on the surface to the eyepoint along the view ray\n                vec3ScaleAndAddBy(closestPoint, cameraPosition, viewDir, dist.distance);\n\n                const sceneCalc = (p: rvec3) => sceneFromDataNoRecursiveMaterial(p, shapeData, operations);\n                const colouredLight = phongIlluminationMaterial(sceneCalc, dist, closestPoint, cameraPosition, numLights, lightData);\n                colour = {\n                    x: Math.pow(colouredLight.x, 0.4545) * 255,\n                    y: Math.pow(colouredLight.y, 0.4545) * 255, // Gamma correction is colour ^ (1 / 2.2)\n                    z: Math.pow(colouredLight.z, 0.4545) * 255,\n                    w: 255,\n                };\n            }\n\n            view[index] = colour.x;\n            view[index + 1] = colour.y;\n            view[index + 2] = colour.z;\n            view[index + 3] = colour.w;\n\n            index += 4;\n        }\n    }\n}", "import { WorkerRequests } from \"./states\";\nimport { renderScene2 } from \"./render-scenes\";\n\nself.addEventListener('message', (e: MessageEvent<WorkerRequests>) =>\n{\n    if (e.data.type === 'render')\n    {\n        renderScene2(e.data);\n        self.postMessage({ type: \"render\", buffer: e.data.buffer }, [e.data.buffer]);\n    }\n});"],
  "mappings": "MAMA,IAAqBA,EAArB,MAAqBC,CAAM,CAEvB,OAAgB,QAAU,KAC1B,OAAgB,YAA0B,MAC1C,OAAgB,SAAW,KAAK,GAAK,IACrC,OAAgB,SAAW,IAAM,KAAK,GAOtC,OAAO,SAASC,EAAW,CACvB,OAAOA,EAAI,KAAK,QACpB,CAWA,OAAOA,EAAWC,EAAW,CACzB,OAAO,KAAK,IAAID,EAAIC,CAAC,GAAKF,EAAM,QAAU,KAAK,IAAI,EAAK,KAAK,IAAIC,CAAC,EAAG,KAAK,IAAIC,CAAC,CAAC,CACpF,CASA,OAAc,MAAMC,EAAeC,EAAaC,EAAa,CACzD,OAAO,KAAK,IAAI,KAAK,IAAIF,EAAOE,CAAG,EAAGD,CAAG,CAC7C,CASA,OAAc,KAAKH,EAAWC,EAAWI,EAAW,CAChD,OAAOL,GAAKC,EAAID,GAAKK,CACzB,CASA,OAAc,YAAYC,EAAiBC,EAAgBC,EAAkB,CACzE,IAAMC,EAAaF,EAASD,EAC5B,OAAI,KAAK,IAAIG,CAAU,GAAKD,EACjBD,EAEAD,EAAU,KAAK,KAAKG,CAAU,EAAID,CAEjD,CASA,YAAYR,EAAWC,EAAWI,EAAW,CACzC,OAAIL,IAAMC,EACC,GAECI,EAAIL,IAAMC,EAAID,EAE9B,CACJ,EC1BO,SAASU,EAAWC,EAC3B,CACI,OAAO,KAAK,KAAKA,EAAE,GAAK,EAAIA,EAAE,GAAK,EAAIA,EAAE,GAAK,CAAC,CACnD,CAOO,SAASC,EAAkBD,EAClC,CACI,OAAOA,EAAE,GAAK,EAAIA,EAAE,GAAK,EAAIA,EAAE,GAAK,CACxC,CAUO,SAASE,EAAUF,EAASG,EAAoBC,EACvD,CACI,OAAAJ,EAAE,EAAIG,EAAK,EAAIC,EAAM,EACrBJ,EAAE,EAAIG,EAAK,EAAIC,EAAM,EACrBJ,EAAE,EAAIG,EAAK,EAAIC,EAAM,EACdJ,CACX,CA0BO,SAASK,EAAYC,EAASC,EAAoBC,EACzD,CACI,OAAAF,EAAE,EAAIC,EAAK,EAAIC,EAAM,EACrBF,EAAE,EAAIC,EAAK,EAAIC,EAAM,EACrBF,EAAE,EAAIC,EAAK,EAAIC,EAAM,EACdF,CACX,CAQO,SAASG,EAAQF,EAAaC,EACrC,CACI,MAAO,CACH,EAAGD,EAAK,EAAIC,EAAM,EAClB,EAAGD,EAAK,EAAIC,EAAM,EAClB,EAAGD,EAAK,EAAIC,EAAM,CACtB,CACJ,CAUO,SAASE,EAAUJ,EAASC,EAAoBC,EACvD,CACI,OAAAF,EAAE,EAAIC,EAAK,EAAIC,EAAM,EACrBF,EAAE,EAAIC,EAAK,EAAIC,EAAM,EACrBF,EAAE,EAAIC,EAAK,EAAIC,EAAM,EACdF,CACX,CAuDO,SAASK,EAAYC,EAASC,EAAoBC,EACzD,CACI,OAAAF,EAAE,EAAIC,EAAK,EAAIC,EACfF,EAAE,EAAIC,EAAK,EAAIC,EACfF,EAAE,EAAIC,EAAK,EAAIC,EACRF,CACX,CAQO,SAASG,EAAUH,EAAUI,EACpC,CACI,MAAO,CACH,EAAGJ,EAAE,EAAII,EACT,EAAGJ,EAAE,EAAII,EACT,EAAGJ,EAAE,EAAII,CACb,CACJ,CAQO,SAASC,EAAkBC,EAAcL,EAAaC,EAAcE,EAC3E,CACI,OAAAE,EAAO,EAAIL,EAAK,EAAKC,EAAM,EAAIE,EAC/BE,EAAO,EAAIL,EAAK,EAAKC,EAAM,EAAIE,EAC/BE,EAAO,EAAIL,EAAK,EAAKC,EAAM,EAAIE,EACxBE,CACX,CAgDO,SAASC,GAAYC,EAC5B,CACI,MAAO,CACH,EAAG,CAACA,EAAE,EACN,EAAG,CAACA,EAAE,EACN,EAAG,CAACA,EAAE,CACV,CACJ,CAqCO,SAASC,EAAcC,EAASC,EACvC,CACI,IAAIC,EAAUC,EAAkBF,CAAM,EACtC,OAAIC,EAAU,IAEVA,EAAU,EAAM,KAAK,KAAKA,CAAO,GAGrCF,EAAE,EAAIC,EAAO,EAAIC,EACjBF,EAAE,EAAIC,EAAO,EAAIC,EACjBF,EAAE,EAAIC,EAAO,EAAIC,EACVF,CACX,CAqBO,SAASI,EAAeC,EAC/B,CACI,IAAIC,EAAUC,EAAkBF,CAAC,EACjC,OAAIC,EAAU,IAEVA,EAAU,EAAM,KAAK,KAAKA,CAAO,GAG9B,CACH,EAAGD,EAAE,EAAIC,EACT,EAAGD,EAAE,EAAIC,EACT,EAAGD,EAAE,EAAIC,CACb,CACJ,CAOO,SAASE,GAAqBC,EAAWC,EAAWC,EAC3D,CACI,IAAIL,EAAUG,GAAK,EAAIC,GAAK,EAAIC,GAAK,EACrC,OAAIL,EAAU,IAEVA,EAAU,EAAM,KAAK,KAAKA,CAAO,GAG9B,CACH,EAAGG,EAAIH,EACP,EAAGI,EAAIJ,EACP,EAAGK,EAAIL,CACX,CACJ,CAQO,SAASM,EAAQC,EAAaC,EACrC,CACI,OAAOD,EAAK,EAAIC,EAAM,EAAID,EAAK,EAAIC,EAAM,EAAID,EAAK,EAAIC,EAAM,CAChE,CAiMO,SAASC,GAAkBC,EAAWC,EAAiBC,EAC9D,CACI,IAAMC,EAAKF,EAAE,EACTG,EAAKH,EAAE,EACPI,EAAKJ,EAAE,EAEX,OAAAD,EAAI,EAAIG,EAAKD,EAAE,IAAME,EAAKF,EAAE,IAAMG,EAAKH,EAAE,IACzCF,EAAI,EAAIG,EAAKD,EAAE,IAAME,EAAKF,EAAE,IAAMG,EAAKH,EAAE,IACzCF,EAAI,EAAIG,EAAKD,EAAE,IAAME,EAAKF,EAAE,IAAMG,EAAKH,EAAE,IAClCF,CACX,CAWO,SAASM,GAAkBN,EAAWC,EAAiBM,EAC9D,CACI,GAAIA,EAAE,IAAM,GAAKA,EAAE,IAAM,GAAKA,EAAE,IAAM,GAAKA,EAAE,IAAM,EAE/C,OAAAP,EAAI,EAAIC,EAAE,EACVD,EAAI,EAAIC,EAAE,EACVD,EAAI,EAAIC,EAAE,EACHD,EAIX,IAAMQ,EAAIP,EAAE,EACRQ,EAAIR,EAAE,EACNS,EAAIT,EAAE,EAEJU,EAAKJ,EAAE,EAAI,EACbK,EAAML,EAAE,EAAIG,EAAIH,EAAE,EAAIE,EACtBI,EAAMN,EAAE,EAAIC,EAAID,EAAE,EAAIG,EACtBI,EAAMP,EAAE,EAAIE,EAAIF,EAAE,EAAIC,EAEpBO,GAAQR,EAAE,EAAIO,EAAMP,EAAE,EAAIM,GAAO,EACnCG,GAAQT,EAAE,EAAIK,EAAML,EAAE,EAAIO,GAAO,EACjCG,GAAQV,EAAE,EAAIM,EAAMN,EAAE,EAAIK,GAAO,EAErC,OAAAA,GAAOD,EACPE,GAAOF,EACPG,GAAOH,EAGPX,EAAI,EAAIQ,EAAII,EAAMG,EAClBf,EAAI,EAAIS,EAAII,EAAMG,EAClBhB,EAAI,EAAIU,EAAII,EAAMG,EACXjB,CACX,CAkHO,SAASkB,GAChB,CACI,MAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAC5B,CAUO,SAASC,EAAQC,EACxB,CACI,MAAO,CACH,EAAG,KAAK,IAAIA,EAAE,CAAC,EACf,EAAG,KAAK,IAAIA,EAAE,CAAC,EACf,EAAG,KAAK,IAAIA,EAAE,CAAC,CACnB,CACJ,CAEO,SAASC,GAAQD,EAAUE,EAClC,CACI,MAAO,CACH,EAAG,KAAK,IAAIF,EAAE,EAAGE,CAAC,EAClB,EAAG,KAAK,IAAIF,EAAE,EAAGE,CAAC,EAClB,EAAG,KAAK,IAAIF,EAAE,EAAGE,CAAC,CACtB,CACJ,CC9pBO,SAASC,IAChB,CACI,MAAO,CACH,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAC7B,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAC7B,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAC7B,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,CACjC,CACJ,CCzEO,SAASC,EAAiBC,EAAWC,EAC5C,CACI,OAAO,KAAK,KAAKD,GAAK,EAAIC,GAAK,CAAC,CACpC,CAsRO,SAASC,GAAQC,EAAaC,EACrC,CACI,OAAOD,EAAK,EAAIC,EAAM,EAAID,EAAK,EAAIC,EAAM,CAC7C,CAgIO,SAASC,IAChB,CACI,MAAO,CAAC,EAAG,EAAG,EAAG,CAAC,CACtB,CCJO,SAASC,IAChB,CACI,MAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAClC,CAEO,SAASC,GAChB,CACI,MAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAClC,CCzdO,SAASC,GAChB,CACI,MAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAClC,CA0CO,SAASC,GAAiBC,EAASC,EAAaC,EACvD,CACIA,EAAMA,EAAM,GACZ,IAAMC,EAAI,KAAK,IAAID,CAAG,EAEtB,OAAAF,EAAE,EAAIG,EAAIF,EAAK,EACfD,EAAE,EAAIG,EAAIF,EAAK,EACfD,EAAE,EAAIG,EAAIF,EAAK,EACfD,EAAE,EAAI,KAAK,IAAIE,CAAG,EACXF,CACX,CC3DO,IAAMI,GAAgB,EAWhBC,GAAgB,KAChBC,GAAiB,KACjBC,GAAwB,KACxBC,GAAuB,KACvBC,GAAe,KAKrB,IAAMC,GAAe,KACfC,GAAkB,KAClBC,GAAoB,KAqC1B,IAAMC,GAAgB,GC5DtB,IAAMC,GAAqB,IACrBC,GAAU,KAmBnBC,GAAUC,EAAS,EACnBC,GAAUD,EAAS,EACnBE,GAAUF,EAAS,EAuBhB,SAASG,GAAaC,EAAcC,EAAWC,EAAaC,EACnE,CACI,IAAMC,EAAID,EAAU,EAAID,EAAK,EAAI,IAC3BG,EAAIF,EAAU,EAAID,EAAK,EAAI,IAEjC,OAAAF,EAAO,EAAII,EACXJ,EAAO,EAAIK,EACXL,EAAO,EAAI,CAACC,EACZK,EAAcN,EAAQA,CAAM,EACrBA,CACX,CAaA,IAAMO,EAAgBC,EAAS,EAyBxB,IAAMC,EAAaC,GAAS,EAC5B,SAASC,GAAiBC,EAAkBC,EAAqBC,EAAcC,EAAaC,EACnG,CACIC,EAAc,EAAIA,EAAc,EAAIA,EAAc,EAAI,EACtD,IAAIC,EAAQJ,EAEZ,QAASK,EAAI,EAAGA,EAAIC,GAAoBD,IACxC,CACIE,EAAkBJ,EAAeL,EAAWC,EAAcK,CAAK,EAC/D,IAAMI,EAAON,EAAMC,CAAa,EAChC,GAAIK,EAAK,UAAYC,GAEjB,MAAO,CAAE,SAAUL,EAAO,cAAeI,EAAK,aAAc,EAIhE,GADAJ,GAASI,EAAK,SACVJ,GAASH,EAET,KAER,CAEA,MAAO,CAAE,SAAUA,EAAK,cAAeN,CAAW,CACtD,CAqCO,SAASe,GAAuBC,EAAcC,EAAsBC,EAC3E,CACI,IAAMC,EAAMF,EAAe,MACrBG,EAAW,CAAC,EAAGJ,EAAM,EAAIG,EAAK,EAAGH,EAAM,EAAG,EAAGA,EAAM,CAAC,EACpDK,EAAW,CAAC,EAAGL,EAAM,EAAIG,EAAK,EAAGH,EAAM,EAAG,EAAGA,EAAM,CAAC,EAEpDM,EAAKJ,EAAME,CAAE,EACbG,EAAKL,EAAMG,CAAE,EACbG,EAAIF,EAAG,SAAWC,EAAG,SAE3BH,EAAG,EAAIJ,EAAM,EACbI,EAAG,EAAIJ,EAAM,EAAIG,EACjBE,EAAG,EAAIL,EAAM,EACbK,EAAG,EAAIL,EAAM,EAAIG,EAEjB,IAAMM,EAAKP,EAAME,CAAE,EACbM,EAAKR,EAAMG,CAAE,EACbM,EAAIF,EAAG,SAAWC,EAAG,SAE3BN,EAAG,EAAIJ,EAAM,EACbI,EAAG,EAAIJ,EAAM,EAAIG,EACjBE,EAAG,EAAIL,EAAM,EACbK,EAAG,EAAIL,EAAM,EAAIG,EAEjB,IAAMS,EAAKV,EAAME,CAAE,EACbS,EAAKX,EAAMG,CAAE,EACbS,EAAIF,EAAG,SAAWC,EAAG,SAE3B,OAAOE,GAAqBP,EAAGG,EAAGG,CAAC,CACvC,CAkCO,SAASE,GAAQC,EAAWC,EAAoBC,EACvD,CACI,IAAMC,EAAMC,EAAQH,EAAaC,CAAM,EACvC,OAAAG,EAAkBL,EAAKC,EAAaC,EAAQ,GAAKC,CAAG,EAC7CH,CACX,CA6DO,SAASM,GAA6BC,EACzCC,EACAC,EAAsBC,EACtBC,EAAcC,EACdC,EAAiBC,EACrB,CACI,IAAMC,EAAIC,GAAuBL,EAAOH,EAAcD,CAAK,EAErDU,EAAIC,EAAeC,EAAQN,EAAUF,CAAK,CAAC,EAC3CS,EAAKC,GAAYJ,CAAC,EAElBK,EAAIJ,EAAeC,EAAQP,EAAKD,CAAK,CAAC,EACtCY,EAAIL,EAAeM,GAAQC,EAAS,EAAGL,EAAIL,CAAC,CAAC,EAE7CW,EAAQC,EAAQV,EAAGF,CAAC,EACpBa,EAAQD,EAAQJ,EAAGD,CAAC,EAE1B,GAAII,EAAQ,EAGR,OAAOD,EAAS,EAGpB,IAAII,EAEJ,GAAID,EAAQ,EAGRC,EAAKC,EAAUrB,EAAeiB,CAAK,MAGvC,CACI,IAAMK,EAAKD,EAAUrB,EAAeiB,CAAK,EACnCM,EAAM,KAAK,IAAIJ,EAAOnB,EAAc,CAAC,EAC3CoB,EAAKC,EAAUpB,EAAgBsB,CAAG,EAElCC,EAAUJ,EAAIA,EAAIE,CAAE,CACxB,CAEA,OAAAG,EAAUL,EAAIA,EAAIf,CAAc,EACzBe,CACX,CAgBA,IAAMM,EAA2B,CAAC,EAAG,GAAK,EAAG,GAAK,EAAG,EAAG,EA6BxD,IAAMC,GAAcC,EAAQ,EACrB,SAASC,GAA0BC,EAA8BC,EAA+BC,EAAcC,EAAkBC,EAAmBC,EAC1J,CACI,IAAMC,EAAe,CAAE,EAAGC,EAAkB,EAAG,EAAGA,EAAkB,EAAG,EAAGA,EAAkB,CAAE,EAE9F,QAASC,EAAI,EAAGA,EAAIJ,EAAWI,IAC/B,CACI,IAAMC,EAAaD,EAAIE,GACjBC,EAAW,CACb,EAAGN,EAAUI,CAAc,EAC3B,EAAGJ,EAAUI,EAAa,CAAC,EAC3B,EAAGJ,EAAUI,EAAa,CAAC,CAC/B,EACMG,EAAcP,EAAUI,EAAa,CAAC,EACtCI,EAAc,CAChB,EAAGR,EAAUI,EAAa,CAAC,EAC3B,EAAGJ,EAAUI,EAAa,CAAC,EAC3B,EAAGJ,EAAUI,EAAa,CAAC,CAC/B,EAEMK,EAAUC,EAAeC,EAAQL,EAAUT,CAAK,CAAC,EACjDe,EAASC,GAAmBlB,EAAOE,EAAOY,EAAS,GAAK,GAAG,EAC3DK,EAAeC,GAA6BpB,EAAOC,EAAa,SAAUA,EAAa,cAAeJ,GAAaK,EAAOC,EAAWQ,EAAUE,CAAW,EAChKQ,EAAUf,EAAQA,EAAQgB,EAAYH,EAAcA,EAAcF,CAAM,CAAC,CAC7E,CAEA,OAAOX,CACX,CAEA,IAAMiB,GAAkB,GAClBC,EAAcC,EAAS,EAsBtB,SAASC,GAAmBC,EAA8BC,EAAkBC,EAAqBC,EAAcC,EACtH,CACI,IAAIC,EAAS,EACbC,EAAY,EAAIA,EAAY,EAAIA,EAAY,EAAI,EAEhD,IAAIC,EAAIJ,EACR,QAASK,EAAI,EAAGA,EAAIC,IAAsBF,EAAIH,EAAKI,IACnD,CACIE,EAAkBJ,EAAaL,EAAWC,EAAcK,CAAC,EACzD,IAAMI,EAAOX,EAAMM,CAAW,EAC9B,GAAIK,EAAK,SAAWC,GAEhB,OAAOD,EAAK,SAGhBN,EAAS,KAAK,IAAIA,EAAQQ,GAAkBF,EAAK,SAAWJ,CAAC,EAC7DA,GAAKI,EAAK,QACd,CAEA,OAAON,CACX,CAGO,SAASS,GAAUC,EAAcC,EACxC,CACI,OAAOC,EAAWF,CAAK,EAAIC,CAC/B,CAQO,SAASE,GAAOC,EAAUC,EACjC,CACI,IAAMC,EAAIC,EAAQC,EAAQJ,CAAC,EAAGC,CAAI,EAC5BI,EAAkBC,EAAWC,GAAQL,EAAG,CAAG,CAAC,EAC5CM,EAAiB,KAAK,IAAI,KAAK,IAAIN,EAAE,EAAG,KAAK,IAAIA,EAAE,EAAGA,EAAE,CAAC,CAAC,EAAG,CAAC,EACpE,OAAOG,EAAkBG,CAC7B,CAEA,IAAMC,EAAmB,CAAC,EAAG,UAAY,EAAG,GAAK,EAAG,MAAO,EACpD,SAASC,GAAWV,EAAUW,EACrC,CACI,IAAMC,EAAOR,EAAQJ,CAAC,EAChBa,EAAM,EAAM,KAAK,IAAIC,GAAQL,EAAWG,CAAI,EAAG,CAAC,EACtDA,EAAK,GAAKC,EAAMJ,EAAU,EAC1BG,EAAK,GAAKC,EAAMJ,EAAU,EAE1B,IAAMM,EAAUC,EAAM,MAAMJ,EAAK,EAAG,CAACH,EAAU,EAAIE,EAAE,EAAGF,EAAU,EAAIE,EAAE,CAAC,EACnEM,EAAKC,EAAiBN,EAAK,EAAIG,EAASH,EAAK,EAAID,EAAE,CAAC,EAAI,KAAK,KAAKC,EAAK,EAAID,EAAE,CAAC,EAC9EQ,EAAKP,EAAK,EAAID,EAAE,EAChBS,EAAQ,KAAK,IAAIH,EAAI,CAAC,EACtBI,EAAQ,KAAK,IAAIF,EAAI,CAAC,EAE5B,OAAO,KAAK,IAAI,KAAK,IAAIF,EAAIE,CAAE,EAAG,CAAC,EAAID,EAAiBE,EAAOC,CAAK,CACxE,CAiBO,SAASC,GAASC,EAAYC,EACrC,CACI,OAAO,KAAK,IAAI,KAAK,IAAID,EAAIC,CAAE,EAAG,CAAC,KAAK,IAAID,EAAIC,CAAE,CAAC,CACvD,CClfA,IAAMC,GAAYC,GAAa,EACzBC,GAAaC,EAAS,EACtBC,EAAWC,EAAa,EAG9B,IAAMC,EAAwC,CAAC,EAEzCC,EAAYC,EAAS,EAuC3B,SAASC,GAAsBC,EAAeC,EAAcC,EAC5D,CACI,IAAMC,EAAIH,EAAQI,GAElBC,EAAU,EAAIH,EAAUC,CAAC,EACzBE,EAAU,EAAIH,EAAUC,EAAI,CAAC,EAC7BE,EAAU,EAAIH,EAAUC,EAAI,CAAC,EAE7B,IAAMG,EAASJ,EAAUC,EAAI,CAAC,EAG9B,GAFAI,EAAYF,EAAWA,EAAWJ,CAAK,EAEnCK,EAAS,EACb,CACI,IAAME,EAAOC,EAAWJ,CAAS,EACjC,GAAIG,EAAOF,EAAS,EAEhB,MAAO,CAAE,SAAUE,EAAO,EAAG,cAAeE,CAAW,CAE/D,CAEAC,EAAS,EAAIT,EAAUC,EAAI,CAAC,EAC5BQ,EAAS,EAAIT,EAAUC,EAAI,CAAC,EAC5BQ,EAAS,EAAIT,EAAUC,EAAI,CAAC,EAC5BQ,EAAS,EAAIT,EAAUC,EAAI,CAAC,EAE5BS,GAAkBC,GAAYR,EAAWM,CAAQ,EAEjD,IAAMG,EAAOZ,EAAUC,EAAI,CAAC,EACtBY,EAAgB,CAClB,EAAGb,EAAUC,EAAI,CAAC,EAClB,EAAGD,EAAUC,EAAI,EAAE,EACnB,EAAGD,EAAUC,EAAI,EAAE,CACvB,EAEMa,EAAWC,GAAcH,EAAMD,GAAYE,CAAM,EAEjDG,EAAgB,CAClB,EAAGhB,EAAUC,EAAI,EAAE,EACnB,EAAGD,EAAUC,EAAI,EAAE,EACnB,EAAGD,EAAUC,EAAI,EAAE,EACnB,EAAGD,EAAUC,EAAI,EAAE,CACvB,EAQA,MAAO,CAAE,SAAAa,EAAU,cAAAE,CAAc,CACrC,CA6BA,SAASC,GAAiCC,EAAcC,EAAqBC,EAC7E,CACI,IAAIC,EAAkB,EAClBC,EAAkB,GAEtB,KAAOD,EAAkBD,EAAW,QACpC,CACI,IAAMG,EAAYH,EAAWC,GAAiB,EAE9C,GAAIE,GAAaC,GACjB,CACI,IAAMC,EAASC,EAAmBJ,GAAiB,EAC7CK,EAASD,EAAmBJ,GAAiB,EAC7CM,EAAOC,GAAoBN,EAA2BE,EAAQE,CAAM,EAC1ED,EAAmB,EAAEJ,CAAe,EAAIM,CAC5C,KAEA,CAEI,IAAMA,EAAOE,GAAsBP,EAAWL,EAAOC,CAAS,EAC9DO,EAAmB,EAAEJ,CAAe,EAAIM,CAC5C,CACJ,CAEA,OAAOF,EAAmB,CAAC,CAC/B,CAEA,SAASK,GAAcC,EAAsBd,EAAce,EAC3D,CACI,OAAQD,EACR,CACI,KAAKE,GAAc,OAAOC,GAAOjB,EAAOe,CAAM,EAC9C,KAAKG,GAAiB,OAAOC,GAAUnB,EAAOe,EAAO,CAAC,EACtD,KAAKK,GAAmB,OAAOC,GAAWrB,EAAOe,CAAM,CAC3D,CACA,MAAO,IACX,CAcA,SAASO,GAAoBC,EAAsBC,EAAwBC,EAC3E,CACI,OAAQF,EACR,CACI,KAAKG,GACD,OAAOF,EAAM,SAAWC,EAAM,SAAWD,EAAQC,EACrD,KAAKE,GACD,OAAOH,EAAM,SAAWC,EAAM,SAAWD,EAAQC,EACrD,KAAKG,GACD,MAAO,CAACJ,EAAM,SAAWC,EAAM,SAAW,CACtC,SAAU,CAACD,EAAM,SACjB,cAAeA,EAAM,aACzB,EAAIC,EACR,KAAKI,GACD,MAAO,CACH,SAAUC,GAASN,EAAM,SAAUC,EAAM,QAAQ,EACjD,cAAeD,EAAM,aACzB,CACR,CAEA,MAAO,CACH,SAAU,IACV,cAAeO,CACnB,CACJ,CA6BA,IAAMC,GAAqB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAG,EAC9CC,GAAmB,CAAC,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAG,EAChDC,GAAW,EAqFR,SAASC,GAAaC,EAC7B,CACI,IAAIC,EAAQ,EAEN,CACF,OAAAC,EACA,MAAAC,EACA,OAAAC,EACA,YAAAC,EACA,WAAAC,EACA,KAAAC,EACA,KAAAC,EACA,aAAAC,EACA,eAAAC,EACA,WAAAC,EACA,KAAAC,EACA,UAAAC,EACA,UAAAC,EACA,WAAAC,EACA,UAAAC,CACJ,EAAIhB,EACEiB,EAAO,IAAI,kBAAkBf,CAAM,EAEzCgB,GAAW,KAAK,IAAIN,CAAI,EAAI,GAAM,GAElC,IAAMO,GAAkB,CAAC,EAAGb,EAAY,EAAGD,CAAW,EAChDe,GAASC,EAAS,EAClBC,EAAeD,EAAS,EACxBE,EAAYC,GAAS,EAE3BC,GAAiBC,EAAU,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAAGd,CAAI,EAEnD,QAASe,EAAI,EAAGA,EAAIvB,EAAQuB,IAExB,QAASC,EAAI,EAAGA,EAAIzB,EAAOyB,IAC3B,CACIL,EAAU,EAAIK,EAAIrB,EAClBgB,EAAU,EAAIlB,GAAesB,EAAInB,GAEjC,IAAMqB,EAAUC,GAAaV,GAAQT,EAAYQ,GAAUI,CAAS,EACpEQ,GAAkBF,EAASA,EAASpB,CAAY,EAEhD,IAAIuB,EAAwB,CAAE,SAAU,IAAK,cAAeC,CAAW,EACjEC,EAAUC,GAAiBzB,EAAgBmB,EAAS,EAAG,IAAMO,GAAMC,GAAiCD,EAAGpB,EAAWD,CAAU,CAAC,EAC/HmB,EAAQ,SAAWF,EAAK,WAExBA,EAAOE,GAGX,IAAII,EAASC,GAEb,GAAIP,EAAK,SAAW,GAEhBM,EAASE,OAGb,CAEIC,EAAkBnB,EAAcZ,EAAgBmB,EAASG,EAAK,QAAQ,EAGtE,IAAMU,EAAgBC,GADHP,IAAaC,GAAiCD,GAAGpB,EAAWD,CAAU,EAC9BiB,EAAMV,EAAcZ,EAAgBG,EAAWC,CAAS,EACnHwB,EAAS,CACL,EAAG,KAAK,IAAII,EAAc,EAAG,KAAM,EAAI,IACvC,EAAG,KAAK,IAAIA,EAAc,EAAG,KAAM,EAAI,IACvC,EAAG,KAAK,IAAIA,EAAc,EAAG,KAAM,EAAI,IACvC,EAAG,GACP,CACJ,CAEAzB,EAAKhB,CAAK,EAAIqC,EAAO,EACrBrB,EAAKhB,EAAQ,CAAC,EAAIqC,EAAO,EACzBrB,EAAKhB,EAAQ,CAAC,EAAIqC,EAAO,EACzBrB,EAAKhB,EAAQ,CAAC,EAAIqC,EAAO,EAEzBrC,GAAS,CACb,CAER,CC7YA,KAAK,iBAAiB,UAAY2C,GAClC,CACQA,EAAE,KAAK,OAAS,WAEhBC,GAAaD,EAAE,IAAI,EACnB,KAAK,YAAY,CAAE,KAAM,SAAU,OAAQA,EAAE,KAAK,MAAO,EAAG,CAACA,EAAE,KAAK,MAAM,CAAC,EAEnF,CAAC",
  "names": ["mathf", "_mathf", "a", "b", "value", "min", "max", "t", "current", "target", "maxDelta", "difference", "vec3Length", "v", "vec3SquaredLength", "vec3AddTo", "left", "right", "vec3SubFrom", "v", "left", "right", "vec3Sub", "vec3MulTo", "vec3ScaleBy", "v", "left", "right", "vec3Scale", "scale", "vec3ScaleAndAddBy", "target", "vec3Negated", "v", "vec3Normalize", "v", "source", "sqrtLen", "vec3SquaredLength", "vec3Normalized", "v", "sqrtLen", "vec3SquaredLength", "vec3NormalizedValues", "x", "y", "z", "vec3Dot", "left", "right", "vec3TransformMat3", "out", "v", "m", "vx", "vy", "vz", "vec3TransformQuat", "q", "x", "y", "z", "w2", "uvx", "uvy", "uvz", "uuvx", "uuvy", "uuvz", "vec3Zero", "vec3Abs", "v", "vec3Max", "s", "mat4Identity", "vec2LengthValues", "x", "y", "vec2Dot", "left", "right", "vec2Zero", "vec4Zero", "vec4One", "quatIdentity", "quatSetAxisAngle", "q", "axis", "rad", "s", "lightDataSize", "SdfOpCodeNone", "SdfOpCodeUnion", "SdfOpCodeIntersection", "SdfOpCodeSubtraction", "SdfOpCodeXor", "ShapeTypeBox", "ShapeTypeSphere", "ShapeTypeHexPrism", "shapeDataSize", "MAX_MARCHING_STEPS", "EPSILON", "f", "vec3Zero", "s", "u", "rayDirection", "result", "z", "size", "fragCoord", "x", "y", "vec3Normalize", "rayMarchPoint", "vec3Zero", "zeroColour", "vec4Zero", "rayMarchMaterial", "rayOrigin", "rayDirection", "near", "far", "scene", "rayMarchPoint", "depth", "i", "MAX_MARCHING_STEPS", "vec3ScaleAndAddBy", "dist", "EPSILON", "estimateNormalMaterial", "point", "currentDepth", "scene", "eps", "p1", "p2", "d1", "d2", "x", "d3", "d4", "y", "d5", "d6", "z", "vec3NormalizedValues", "reflect", "out", "incidentVec", "normal", "dot", "vec3Dot", "vec3ScaleAndAddBy", "phongContribForLightMaterial", "scene", "currentDepth", "diffuseColour", "specularColour", "point", "eye", "lightPos", "lightIntensity", "N", "estimateNormalMaterial", "L", "vec3Normalized", "vec3Sub", "nL", "vec3Negated", "V", "R", "reflect", "vec3Zero", "dotLN", "vec3Dot", "dotRV", "r1", "vec3Scale", "r2", "pow", "vec3AddTo", "vec3MulTo", "fixedAmbientLight", "whiteColour", "vec4One", "phongIlluminationMaterial", "scene", "currentPoint", "point", "rayOrigin", "numLights", "lightData", "colour", "fixedAmbientLight", "i", "lightIndex", "lightDataSize", "lightPos", "lightRadius", "lightColour", "toLight", "vec3Normalized", "vec3Sub", "shadow", "softShadowMaterial", "lightContrib", "phongContribForLightMaterial", "vec3AddTo", "vec3ScaleBy", "shadowSharpness", "shadowPoint", "vec3Zero", "softShadowMaterial", "scene", "rayOrigin", "rayDirection", "near", "far", "result", "shadowPoint", "t", "i", "MAX_MARCHING_STEPS", "vec3ScaleAndAddBy", "dist", "EPSILON", "shadowSharpness", "sdfSphere", "point", "radius", "vec3Length", "sdfBox", "p", "size", "d", "vec3Sub", "vec3Abs", "outsideDistance", "vec3Length", "vec3Max", "insideDistance", "hexConsts", "sdfHexPrim", "h", "absP", "dot", "vec2Dot", "clamped", "mathf", "dx", "vec2LengthValues", "dy", "maxDx", "maxDy", "sdfOpXor", "d1", "d2", "transform", "mat4Identity", "transPoint", "vec3Zero", "rotation", "quatIdentity", "depthMaterialStack", "testPoint", "vec3Zero", "calculateDistMaterial", "index", "point", "shapeData", "i", "shapeDataSize", "testPoint", "radius", "vec3SubFrom", "diff", "vec3Length", "zeroColour", "rotation", "vec3TransformQuat", "transPoint", "type", "params", "distance", "getDistToType", "diffuseColour", "sceneFromDataNoRecursiveMaterial", "point", "shapeData", "operations", "operationsIndex", "depthStackIndex", "operation", "SdfOpCodeNone", "lastD2", "depthMaterialStack", "lastD1", "dist", "applyOpCodeMaterial", "calculateDistMaterial", "getDistToType", "opCode", "params", "ShapeTypeBox", "sdfBox", "ShapeTypeSphere", "sdfSphere", "ShapeTypeHexPrism", "sdfHexPrim", "applyOpCodeMaterial", "opCode", "dist1", "dist2", "SdfOpCodeUnion", "SdfOpCodeIntersection", "SdfOpCodeSubtraction", "SdfOpCodeXor", "sdfOpXor", "zeroColour", "emptyColour", "redColour", "lerpTime", "renderScene2", "request", "index", "buffer", "width", "height", "totalHeight", "totalWidth", "xPos", "yPos", "cameraMatrix", "cameraPosition", "cameraZDir", "time", "numLights", "lightData", "operations", "shapeData", "view", "lerpTime", "viewSize", "rayDir", "vec3Zero", "closestPoint", "fragCoord", "vec2Zero", "quatSetAxisAngle", "rotation", "y", "x", "viewDir", "rayDirection", "vec3TransformMat3", "dist", "zeroColour", "newDist", "rayMarchMaterial", "p", "sceneFromDataNoRecursiveMaterial", "colour", "redColour", "emptyColour", "vec3ScaleAndAddBy", "colouredLight", "phongIlluminationMaterial", "e", "renderScene2"]
}
